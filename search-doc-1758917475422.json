{"searchDocs":[{"title":"Inleiding","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course","content":"","keywords":"","version":"Next"},{"title":"Verschillende platformen​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#verschillende-platformen","content":"   ","version":"Next","tagName":"h2"},{"title":"Android​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#android","content":" Android is een open source operating system dat ontwikkeld wordt door Google. Het is een van de meest gebruikte mobiele operating systems ter wereld.  Android Studio is een IDE die ontwikkeld is voor Android ontwikkelaars. Het is een volledige IDE die ondersteuning biedt voor het ontwikkelen van Android apps. Het is een gratis IDE die je kan downloaden op de Android Studio website. Je kan apps maken voor Android met behulp van Java, Kotlin of C++.  Apps worden gepubliceerd op de Google Play Store. De kostprijs om een app te publiceren is 25 euro.  ","version":"Next","tagName":"h3"},{"title":"iOS​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#ios","content":" iOS is een gesloten operating system dat ontwikkeld wordt door Apple.  XCode is een IDE die ontwikkeld is voor iOS ontwikkelaars. Je kan deze IDE enkel op een Mac installeren. Je kan apps maken voor iOS met behulp van Swift of Objective-C.  Apps worden gepubliceerd op de App Store. De kostprijs om een app te publiceren is 99 euro per jaar.  ","version":"Next","tagName":"h3"},{"title":"Problemen​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#problemen","content":" Verschillen in platforms​  We zitten dus met een probleem. Als je een app wil maken voor Android en iOS, moet je twee verschillende IDE's gebruiken. Je moet ook twee verschillende programmeertalen leren. Het is dus niet mogelijk om een app te maken voor beide platformen met behulp van één IDE en één programmeertaal.  Versie fragmentatie​    Om het nog moeilijker te maken hebben zijn er ook nog veel verschillende versies van elk platform. Android heeft veel verschillende fabrikanten die niet allemaal even snel updates uitbrengen. Dit zorgt ervoor dat je rekening moet houden met veel verschillende versies van android.  Het voordeel van Apple is dat zij het eco systeem (hardware, software,...) volledig in handen hebben. Dit zorgt ervoor dat ze sneller updates kunnen uitbrengen en langer ondersteuning geven voor oudere apparaten. Dit zorgt ervoor dat je minder rekening moet houden met verschillende versies van iOS.  ","version":"Next","tagName":"h3"},{"title":"Native vs Cross-platform​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#native-vs-cross-platform","content":" ","version":"Next","tagName":"h2"},{"title":"Native​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#native","content":" Er wordt een app ontwikkeld voor elk platform. Dit zorgt ervoor dat je gebruik kan maken van alle features van het platform. Het nadeel hierbij is dat je twee verschillende apps moet ontwikkelen. Je moet dus twee verschillende IDE's gebruiken en twee verschillende programmeertalen leren.  Voordelen:  Gebruik kan maken van alle features van het platformSnellere performanceBetere user experience  Nadelen:  Twee verschillende apps moeten ontwikkeld wordenDuurder (meer developers/tijd nodig)Apps kunnen verschillen in functionaliteit (en look &amp; feel)  In deze cursus gaan we niet dieper in op ontwikkelen van native apps.  ","version":"Next","tagName":"h3"},{"title":"Cross-platform​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#cross-platform","content":" Er wordt één app ontwikkeld die op beide platformen kan uitgevoerd worden. Dit zorgt ervoor dat je maar één app hoeft te ontwikkelen in 1 programmeertaal. Soms heb je nog wel kleine aanpassingen nodig voor elk platform.  Voordelen:  Veel goedkoper (minder developers/tijd nodig)Apps kunnen dezelfde functionaliteit hebben (en look &amp; feel)Snellere ontwikkeling  Nadelen:  Je kan niet alle features van het platform gebruikenLagere performanceSlechtere user experience  ","version":"Next","tagName":"h3"},{"title":"Cross-platform types​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#cross-platform-types","content":" Progressive Web Apps (PWA)​  Een PWA is een webapp die op een mobiele telefoon kan uitgevoerd worden. Het is een webapp die eruit ziet als een native app.  Eigenlijk gebruikt de PWA gewoon de browser van je mobiele telefoon. Het is dus niet echt een native app. Het is een webapp die eruit ziet als een native app. Je gebruikt dus ook gewoon een combinatie van HTML, CSS en JavaScript. Je kan hiervoor ook gebruik maken van een framework zoals React/Angular/Vue.  Het is zelfs mogelijk om deze apps te installeren op je mobiele telefoon. Daarvoor heb je dan wel een tool nodig zoals Cordova,Phonegap, Ionic,...  Cross platform applicaties met native componenten​  Echte cross platform applicaties gebruiken echte native componenten. Alle UI componenten zijn gebouwd uit echte componenten van het platform zelf. Bijvoorbeeld een button zal dus in iOS en Android er anders uitzien. Je schrijft dus gewoon code in één programmeertaal en een framework zorgt ervoor dat de code omgezet wordt naar native code.  Bekende frameworks zijn React Native, Flutter, NativeScript,...  ","version":"Next","tagName":"h3"},{"title":"React Native​","type":1,"pageTitle":"Inleiding","url":"/webframeworks-cursus/react-native-course#react-native","content":" In deze cursus gaan we leren werken met React Native!  React Native is een framework om native apps te maken voor iOS en Android. Het is gebaseerd op React.js, een JavaScript library voor het maken van webapps. React Native is ontwikkeld door Meta en wordt veel gebruikt door grote bedrijven zoals Airbnb, Facebook, Instagram, Tesla, Uber en Walmart.  React Native lijkt heel hard op React.js. De meeste React.js code kan je gewoon gebruiken in React Native. De grootste verschillen zijn:  React Native gebruikt native componenten in plaats van webcomponenten. Dit betekent dat je geen HTML tags gebruikt, maar native componenten zoals &lt;View&gt;, &lt;Text&gt; en &lt;Image&gt;.React Native gebruikt geen CSS bestanden of modules maar inline styles. Dit betekent dat je geen CSS classes kan gebruiken, maar inline styles zoals style={{ color: 'red' }}.React Native gebruikt geen HTML bestanden maar JavaScript bestanden met de extensie .js of .jsx. ","version":"Next","tagName":"h2"},{"title":"Expo","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/expo","content":"","keywords":"","version":"Next"},{"title":"Expo CLI​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#expo-cli","content":" Expo CLI is een command line interface die je kan gebruiken om een nieuwe React Native app aan te maken.  ","version":"Next","tagName":"h2"},{"title":"Hoe Expo CLI gebruiken​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#hoe-expo-cli-gebruiken","content":" Je kan de Expo CLI gebruiken zonder het eerst te installeren. Je kan het gewoon gebruiken met npx. Zo heb je ook altijd de laatste versie.  Je kan zien welke commando's je kan gebruiken met npx expo --help.  Het wordt aangeraden om eerst een Expo account aan te maken. Je kan zien of je al een account hebt door het volgende commando uit te voeren:  npx expo whoami   Als je nog geen account hebt, kan je er een aanmaken met het volgende commando:  npx expo register   Als je een account hebt, kan je inloggen met het volgende commando:  npx expo login   ","version":"Next","tagName":"h3"},{"title":"Expo Go App voor iOS en Android​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#expo-go-app-voor-ios-en-android","content":" Om je app te testen op je smartphone of tablet, moet je de Expo Go app installeren. Deze app kan je vinden in de App Store en de Play Store.  Android Play Store - Android Lollipop (5) and greateriOS App Store - iOS 11 and greater  Na de installatie kan je via de app met dezelfde account inloggen. Als je ingelogd bent is het veel eenvoudiger om projecten te openen. Ze zullen automatisch onder het &quot;Projects&quot; onderdeel staan.  ","version":"Next","tagName":"h3"},{"title":"Nieuwe app aanmaken​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#nieuwe-app-aanmaken","content":" Om een nieuwe app aan te maken, kan je het volgende commando gebruiken:  npx create-expo-app &lt;project-name&gt; --template expo-template-blank-typescript   of korter:  npx create-expo-app -t expo-template-blank-typescript &lt;project-name&gt;   Omdat we typescript gaan gebruiken in deze cursus, gebruiken we het --template argument. Als je geen typescript wil gebruiken, kan je het argument weglaten.  ","version":"Next","tagName":"h2"},{"title":"Development server​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#development-server","content":" Je kan de development server starten met het volgende commando:  npx expo start   Als je dit commando uitvoert dan wordt de Metro bundler gestart. Deze bundler is een http server die de javascript code compileert en bundelt. De bundler is ook verantwoordelijk voor het hot reloading. Als je een bestand aanpast, dan zal de bundler de code opnieuw compileren en de app opnieuw laden.  ","version":"Next","tagName":"h2"},{"title":"De app openen op je telefoon of tablet​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#de-app-openen-op-je-telefoon-of-tablet","content":" Om de app te openen:  Op android devices druk je op de &quot;Scan QR Code&quot; knop en scan je de QR code die in de terminal verschijnt.Op een iPhone of iPad moet je de default camera app gebruiken om de QR code te scannen. Als je de QR code scant, dan zal de Expo Go app automatisch geopend worden.  waarschuwing Zorg ervoor dat je op hetzelfde netwerk zit als je telefoon of tablet. Als je op een ander netwerk zit, dan zal de bundler niet kunnen verbinden met je telefoon of tablet. Gebruik desnoods een hotspot van je telefoon.  ","version":"Next","tagName":"h2"},{"title":"Expo gebruiken via een tunnel​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#expo-gebruiken-via-een-tunnel","content":" Op sommige netwerken kan het zijn dat je geen verbinding kan maken met je telefoon of tablet. In dat geval kan je een tunnel gebruiken. Je kan dit doen met het volgende commando:  npx expo start --tunnel   De bundler zal nu een tunnel opzetten en een url genereren. Je kan deze url gebruiken om je app te openen op je smartphone of tablet.  Het kan zijn dat je nog een extra dependency moet installeren. Je kan dit doen met het volgende commando:  npm install --save-dev @expo/ngrok@^4.1.1 npm install --global @expo/ngrok@^4.1.1   Ook kan het gebeuren dat het npx create-expo-app command niet de nieuwste versie van expo installeert. De volgende commando's verhelpen dit probleem:  npm install expo@latest npx expo install --fix   In het bestand babel.config.json moet je dan vervolgens de plugin expo-router/babel verwijderen.  ","version":"Next","tagName":"h3"},{"title":"De app openen in de browser​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#de-app-openen-in-de-browser","content":" Als je de app in de browser wil openen, dan kan je het volgende commando gebruiken:  npx expo start --web   of je kan de w toets indrukken in de terminal als je opgestart bent met npx expo start.  Het kan zijn dat je de volgende foutmelding krijgt:  CommandError: It looks like you're trying to use web support but don't have the required dependencies installed. Please install react-native-web@~0.19.10, react-dom@18.2.0, @expo/metro-runtime@~3.2.3 by running: npx expo install react-native-web react-dom @expo/metro-runtime If you're not using web, please ensure you remove the &quot;web&quot; string from the platforms array in the project Expo config.   Zoals de instructies zeggen moet je zelf deze dependencies installeren. Als je daarna opnieuw npx expo start --web uitvoert, dan zou het moeten werken.  ","version":"Next","tagName":"h2"},{"title":"Eerste wijziging aanbrengen​","type":1,"pageTitle":"Expo","url":"/webframeworks-cursus/react-native-course/expo#eerste-wijziging-aanbrengen","content":" Open de App.tsx file in de src folder. Verander de tekst in de Text component naar &quot;Hello World&quot;. Als je de app nu opnieuw laadt, dan zal je de tekst zien veranderen.  import * as React from 'react'; import { Text, View, StyleSheet } from 'react-native'; import Constants from 'expo-constants'; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.paragraph}&gt; Change this code &lt;/Text&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: 'center', alignItems: 'center', paddingTop: Constants.statusBarHeight, backgroundColor: '#ecf0f1', padding: 8, }, paragraph: { margin: 24, fontSize: 18, fontWeight: 'bold', textAlign: 'center', }, }); export default App;  ","version":"Next","tagName":"h2"},{"title":"Custom Components","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/custom-components","content":"","keywords":"","version":"Next"},{"title":"Properties​","type":1,"pageTitle":"Custom Components","url":"/webframeworks-cursus/react-native-course/custom-components#properties","content":" Net zoals in React.js kunnen we ook in React Native onze eigen componenten maken. We gaan zoveel mogelijk onze componenten opsplitsen in kleine deeltjes. We kunnen ook gebruik maken van properties om informatie door te geven aan onze componenten.  We doen dit helemaal hetzelfde als in React.js:  import {View, StyleSheet} from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; interface BoxProps { color: string, size: number } const Box = ({color, size}: BoxProps) =&gt; { return ( &lt;View style={{ backgroundColor: color, width: size, height: size, }} /&gt; ); }; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Box size={40} color=&quot;red&quot;/&gt; &lt;Box size={40} color=&quot;green&quot;/&gt; &lt;Box size={40} color=&quot;blue&quot;/&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;   ","version":"Next","tagName":"h2"},{"title":"Styles doorgeven als props​","type":1,"pageTitle":"Custom Components","url":"/webframeworks-cursus/react-native-course/custom-components#styles-doorgeven-als-props","content":" We kunnen zelfs ons style object meegeven als property om zo onze componenten nog flexibeler te maken.  import {View, StyleSheet} from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; interface BoxProps { boxStyle: StyleProp&lt;ViewStyle&gt; } const Box = ({boxStyle}: BoxProps) =&gt; { return ( &lt;View style={boxStyle} /&gt; ); }; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Box boxStyle={{backgroundColor: &quot;red&quot;, width: 40, height: 40}}/&gt; &lt;Box boxStyle={{backgroundColor: &quot;green&quot;, width: 40, height: 40}}/&gt; &lt;Box boxStyle={{backgroundColor: &quot;blue&quot;, width: 40, height: 40}}/&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;   ","version":"Next","tagName":"h2"},{"title":"Default styles​","type":1,"pageTitle":"Custom Components","url":"/webframeworks-cursus/react-native-course/custom-components#default-styles","content":" We kunnen ook default styles meegeven aan onze componenten. Dit doen we door een default waarde mee te geven aan onze property.  import {View, StyleSheet} from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; interface BoxProps { boxStyle?: StyleProp&lt;ViewStyle&gt; } const Box = ({boxStyle = {backgroundColor: &quot;red&quot;, width: 40, height: 40}}: BoxProps) =&gt; { return ( &lt;View style={boxStyle} /&gt; ); }; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Box/&gt; &lt;Box/&gt; &lt;Box/&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;   Style array  Een heel belangrijke techniek die je in React Native kan toepassen en niet in React.js is het gebruik van een array van styles. De laatste style in de array heeft altijd voorrang. Zo kan je style inheritance toepassen.  import {View, StyleSheet} from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; interface BoxProps { boxStyle?: StyleProp&lt;ViewStyle&gt; } const DefaultBoxStyle = StyleSheet.create({ box: { backgroundColor: &quot;red&quot;, width: 40, height: 40 } }) const Box = ({boxStyle}: BoxProps) =&gt; { return ( &lt;View style={[DefaultBoxStyle.box, boxStyle]} /&gt; ); }; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Box/&gt; &lt;Box boxStyle={{backgroundColor: &quot;green&quot;}}/&gt; &lt;Box boxStyle={{backgroundColor: &quot;blue&quot;}}/&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;  ","version":"Next","tagName":"h2"},{"title":"Controlled Components","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/controlled-components","content":"","keywords":"","version":"Next"},{"title":"TextInput​","type":1,"pageTitle":"Controlled Components","url":"/webframeworks-cursus/react-native-course/controlled-components#textinput","content":" Om een TextInput een controlled component te maken, moeten we de value property meegeven aan de TextInput component. We moeten ook een onChangeText handler meegeven om de state te updaten.  import React, {useState} from &quot;react&quot;; import {View, TextInput, Button, Alert, Text} from &quot;react-native&quot;; const App = () =&gt; { const [text, setText] = useState(&quot;&quot;); return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;TextInput style={{height: 40, borderColor: &quot;gray&quot;, borderWidth: 1}} onChangeText={text =&gt; setText(text)} value={text} /&gt; &lt;Text&gt;You typed: {text}&lt;/Text&gt; &lt;Button title=&quot;Show Value&quot; onPress={() =&gt; { Alert.alert(text); }}/&gt; &lt;/View&gt; ) } export default App;   Het is ook mogelijk om meerdere componenten aan 1 state te binden. In dit voorbeeld binden we 2 TextInput componenten aan 1 state. Beide zullen up to date blijven bij de huidige waarde van de state.  import React, {useState} from &quot;react&quot;; import {View, TextInput, Button, Alert, Text} from &quot;react-native&quot;; const App = () =&gt; { const [text, setText] = useState(&quot;&quot;); return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;TextInput style={{height: 40, borderColor: &quot;gray&quot;, borderWidth: 1}} onChangeText={text =&gt; setText(text)} value={text} /&gt; &lt;TextInput style={{height: 40, borderColor: &quot;gray&quot;, borderWidth: 1}} onChangeText={text =&gt; setText(text)} value={text} /&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"TextInput met getallen​","type":1,"pageTitle":"Controlled Components","url":"/webframeworks-cursus/react-native-course/controlled-components#textinput-met-getallen","content":" Als we een TextInput component willen gebruiken om getallen in te geven, moeten we de keyboardType property meegeven aan de TextInput component. Niet alle keyboards in Android hebben een numeriek keyboard. Dus de gebruiker kan nog steeds niet numerieke waarden ingeven.  De beste manier om dit op te lossen is toch een string als state te gebruiken en deze te converteren naar een numerieke waarde wanneer we deze nodig hebben.  import React, {useState} from &quot;react&quot;; import {View, TextInput, Button, Alert, Text} from &quot;react-native&quot;; const App = () =&gt; { const [number, setNumber] = useState(&quot;0&quot;); const validateAndMultiply = () =&gt; { if (isNaN(number)) { Alert.alert(&quot;This is not a number!&quot;); setNumber(&quot;0&quot;); } else { setNumber((parseInt(number) * 2).toString()) } } return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;TextInput keyboardType=&quot;number-pad&quot; style={{height: 40, borderColor: &quot;gray&quot;, borderWidth: 1}} onChangeText={text =&gt; setNumber(text)} value={number} /&gt; &lt;Button title=&quot;Multiply&quot; onPress={validateAndMultiply}/&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"Button​","type":1,"pageTitle":"Controlled Components","url":"/webframeworks-cursus/react-native-course/controlled-components#button","content":" We kunnen ook een Button component gebruiken om de state te updaten. We kunnen dit doen door een onPress handler mee te geven aan de Button component. Buttons zijn geen controlled components.  We zullen in het onderstaande voorbeeld een teller tonen die we aan de hand van de Button kunnen verhogen.  import React, {useState} from &quot;react&quot;; import {View, Button, Text} from &quot;react-native&quot;; const App = () =&gt; { const [counter, setCounter] = useState(0); return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;Text&gt;Counter: {counter}&lt;/Text&gt; &lt;Button title=&quot;Increase Counter&quot; onPress={() =&gt; { setCounter(counter + 1); }}/&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"Switch​","type":1,"pageTitle":"Controlled Components","url":"/webframeworks-cursus/react-native-course/controlled-components#switch","content":" Een Switch component heeft een value property en een onValueChange handler. We kunnen deze gebruiken om een Switch component te maken die een controlled component is.  import React, {useState} from &quot;react&quot;; import {View, Switch, Text} from &quot;react-native&quot;; const App = () =&gt; { const [isEnabled, setIsEnabled] = useState(false); return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;Switch onValueChange={() =&gt; setIsEnabled(previousState =&gt; !previousState)} value={isEnabled} /&gt; &lt;Text&gt;Switch is {isEnabled ? &quot;On&quot; : &quot;Off&quot;}&lt;/Text&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"Conditioneel renderen​","type":1,"pageTitle":"Controlled Components","url":"/webframeworks-cursus/react-native-course/controlled-components#conditioneel-renderen","content":" We kunnen ook conditioneel renderen in React Native. We gebruiken hier vooral de &amp;&amp; operator voor of de ternary operator.  import React, {useState} from &quot;react&quot;; import {View, Switch, Text, Image} from &quot;react-native&quot;; const App = () =&gt; { const [isEnabled, setIsEnabled] = useState(false); return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;Switch onValueChange={() =&gt; setIsEnabled(previousState =&gt; !previousState)} value={isEnabled} /&gt; {isEnabled ? &lt;Image style={{width: 60, height: 60}} source={{uri: &quot;https://raw.githubusercontent.com/Templarian/MaterialDesign/master/svg/alarm-light.svg&quot;}}/&gt; : &lt;Image style={{width: 60, height: 60}} source={{uri: &quot;https://raw.githubusercontent.com/Templarian/MaterialDesign/master/svg/alarm-light-off.svg&quot;}}/&gt; } &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"ActivityIndicator​","type":1,"pageTitle":"Controlled Components","url":"/webframeworks-cursus/react-native-course/controlled-components#activityindicator","content":" Een ActivityIndicator component heeft een animating property en een size property. Meestal is de animating property afhankelijk van de waarde van een state. Als we bijvoorbeeld iets willen laden, dan zetten we de animating property op true en als we klaar zijn met laden, dan zetten we de animating property op false.  import React, {useState} from &quot;react&quot;; import {View, Button, Text, ActivityIndicator} from &quot;react-native&quot;; interface TimezoneInterface { datetime: string; } const App = () =&gt; { const [loading, setLoading] = useState(false); const [result, setResult] = useState(&quot;&quot;); const loadData = async() =&gt; { setLoading(true); let result = await fetch(&quot;https://worldtimeapi.org/api/timezone/Europe/Brussels&quot;); let json : TimezoneInterface = await result.json(); setResult(json.datetime); setLoading(false); } return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;Button title=&quot;Load data&quot; onPress={() =&gt; loadData() }/&gt; &lt;ActivityIndicator animating={loading}/&gt; &lt;Text&gt;{result}&lt;/Text&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"FlatList refreshing​","type":1,"pageTitle":"Controlled Components","url":"/webframeworks-cursus/react-native-course/controlled-components#flatlist-refreshing","content":" Een FlatList component heeft een refreshing property en een onRefresh handler. We kunnen deze gebruiken om een FlatList component te maken die een pull to refresh heeft. Hiervoor moeten we de refreshing state bijhouden en deze updaten wanneer de gebruiker de lijst heeft gerefreshed.  import React, {useState} from &quot;react&quot;; import {View, FlatList, Text} from &quot;react-native&quot;; const generateRandomColors = (amount: number) =&gt; { let colors : string[] = []; for (let i = 0; i &lt; amount; i++) { colors.push(&quot;#&quot; + Math.floor(Math.random()*16777215).toString(16)); } return colors; } const App = () =&gt; { const [colors, setColors] = useState(generateRandomColors(10)); const [refreshing, setRefreshing] = useState(false); const refreshColors = async() =&gt; { setRefreshing(true); // wait 2 seconds to simulate API call (or whatever) await new Promise((resolve, reject) =&gt; setTimeout(resolve, 2000)); setColors(generateRandomColors(10)); setRefreshing(false); } return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;FlatList data={colors} renderItem={({item}) =&gt; &lt;View style={{height: 100, backgroundColor: item}}/&gt;} keyExtractor={(item, index) =&gt; index.toString()} refreshing={refreshing} onRefresh={() =&gt; refreshColors()} /&gt; &lt;/View&gt; ) } export default App;  ","version":"Next","tagName":"h2"},{"title":"Android Emulator","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/expo/emulator","content":"","keywords":"","version":"Next"},{"title":"Android Studio​","type":1,"pageTitle":"Android Emulator","url":"/webframeworks-cursus/react-native-course/expo/emulator#android-studio","content":" ","version":"Next","tagName":"h2"},{"title":"Installeren​","type":1,"pageTitle":"Android Emulator","url":"/webframeworks-cursus/react-native-course/expo/emulator#installeren","content":" We gaan de ingebouwde emulator van Android Studio gebruiken. Als je Android Studio nog niet hebt geïnstalleerd, kan je dat hier doen. Gebruik alle standaardinstellingen tijdens de installatie. Daarna kan je Android Studio starten.  De eerste keer dat je Android Studio opstart, moet je doorheen een aantal stappen gaan in een wizard. Ook deze kan je doorlopen door de standaardinstellingen te gebruiken. Deze wizard zal ook alle Android SDK's downloaden die nodig zijn om de emulator te gebruiken. Dit kan even duren.    Na de wizard krijg je het volgende scherm te zien. Je klikt hier op More Actions en dan op Virtual Device Manager.    Normaal gezien zou er standaard al een emulator beschikbaar moeten zijn. Als dit niet het geval is, kan je een nieuwe emulator aanmaken door op Create Device te klikken.  Let op dat je emulator genoeg geheugen en opslagruimte heeft. Als je een emulator aanmaakt, kan je de instellingen aanpassen door het pen-icoontje te gebruiken. Als je dan de Advanced Settings opent, kan je de instellingen aanpassen. 2gb storage en 2gb RAM zou voldoende moeten zijn.    Als dit allemaal gedaan is kan je de emulator starten door op Play te klikken. Je krijgt dan een scherm te zien waarin je de emulator kan starten. Als je de emulator start, zal je een virtuele Android-telefoon zien. Je kan de emulator nu gebruiken om je app te testen.    waarschuwing Wacht tot de emulator helemaal geladen is voor je de app opstart. Als je de app opstart voor de emulator helemaal geladen is, kan het zijn dat de app niet correct werkt.  ","version":"Next","tagName":"h3"},{"title":"Gebruiken met Expo CLI​","type":1,"pageTitle":"Android Emulator","url":"/webframeworks-cursus/react-native-course/expo/emulator#gebruiken-met-expo-cli","content":" Als je expo gebruikt om je app te testen, kan je de emulator gebruiken door de volgende stappen te volgen:  Open Android Studio en start de emulator op.Open een terminal in de map waar je je app in hebt staan.Voer het volgende commando uit: expo start --android of door a te drukken in de terminal waarin je expo start hebt uitgevoerd.  info De eerste keer kan dit een tijdje duren want de Expo Go app moet gedownload en geinstalleerd worden op de emulator. Dit gebeurt automatisch door de Expo CLI. ","version":"Next","tagName":"h3"},{"title":"Extra","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra","content":"Extra","keywords":"","version":"Next"},{"title":"Camera","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra/camera","content":"","keywords":"","version":"Next"},{"title":"Installatie​","type":1,"pageTitle":"Camera","url":"/webframeworks-cursus/react-native-course/extra/camera#installatie","content":" Om expo-camera te gebruiken moeten we eerst de expo-camera library installeren:  npx expo install expo-camera   ","version":"Next","tagName":"h2"},{"title":"Gebruik​","type":1,"pageTitle":"Camera","url":"/webframeworks-cursus/react-native-course/extra/camera#gebruik","content":" ","version":"Next","tagName":"h2"},{"title":"Permissie vragen​","type":1,"pageTitle":"Camera","url":"/webframeworks-cursus/react-native-course/extra/camera#permissie-vragen","content":" Het is belangrijk om te weten dat je de Camera component pas kan gebruiken als de gebruiker hiervoor toestemming heeft gegeven. Dit kan je doen met de requestPermission functie afkomstig uit de useCameraPermissions hook.  import React, { useState } from &quot;react&quot;; import { Camera, CameraType } from &quot;expo-camera&quot;; import { Button, StyleSheet, Text, TouchableOpacity, View } from &quot;react-native&quot;; const App = () =&gt; { const [permission, requestPermission] = Camera.useCameraPermissions(); if (!permission) { // De permissies zijn nog aan het laden return &lt;View/&gt; } if (!permission.granted) { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;You don&quot;t have permission to use the camera&lt;/Text&gt; &lt;Button title=&quot;Toestemming vragen&quot; onPress={requestPermission} /&gt; &lt;/View&gt; ); } return ( &lt;View&gt; &lt;Text&gt;You have permission to use the camera&lt;/Text&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h3"},{"title":"Camera gebruiken​","type":1,"pageTitle":"Camera","url":"/webframeworks-cursus/react-native-course/extra/camera#camera-gebruiken","content":" Eenmaal je de permissie hebt gekregen kan je de Camera component gebruiken.  import React, { useState } from &quot;react&quot;; import { Camera, CameraType } from &quot;expo-camera&quot;; import { Button, StyleSheet, Text, TouchableOpacity, View } from &quot;react-native&quot;; const App = () =&gt; { const [permission, requestPermission] = Camera.useCameraPermissions(); if (!permission) { // De permissies zijn nog aan het laden return &lt;View/&gt; } if (!permission.granted) { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;You don&quot;t have permission to use the camera&lt;/Text&gt; &lt;Button title=&quot;Toestemming vragen&quot; onPress={requestPermission} /&gt; &lt;/View&gt; ); } return ( &lt;View style={{alignItems: &quot;stretch&quot;}}&gt; &lt;Camera style={{flex: 1}} type={CameraType.front}/&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h3"},{"title":"Foto maken​","type":1,"pageTitle":"Camera","url":"/webframeworks-cursus/react-native-course/extra/camera#foto-maken","content":" Om een foto te maken kan je de takePictureAsync functie gebruiken. We hebben hier wel een referentie nodig naar het camera object. Dit kan je doen door de useRef hook te gebruiken. Deze biedt je dan een object aan waarmee je de camera kan aanroepen.  De referentie naar de camera kan je als volgt verkrijgen:  const cameraRef = React.useRef&lt;Camera&gt;(null);   Je moet dan ook nog het Camera component aanpassen zodat het de cameraRef gebruikt:  &lt;Camera ref={cameraRef}&gt;   daarna kunnen we de takePictureAsync functie aanroepen op deze cameraRef. Deze functie geeft ons een Photo object terug. Dit object bevat de uri van de foto.  import React, { useState } from &quot;react&quot;; import { Camera, CameraType } from &quot;expo-camera&quot;; import { Button, StyleSheet, Text, TouchableOpacity, View } from &quot;react-native&quot;; const App = () =&gt; { const [permission, requestPermission] = Camera.useCameraPermissions(); const cameraRef = React.useRef&lt;Camera&gt;(null); const [photo, setPhoto] = useState&lt;string | null&gt;(null); const takePicture = () =&gt; { if (cameraRef.current) { cameraRef.current.takePictureAsync().then((photo) =&gt; { setPhoto(photo.uri); }); } } if (!permission) { // De permissies zijn nog aan het laden return &lt;View/&gt; } if (!permission.granted) { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;You don&quot;t have permission to use the camera&lt;/Text&gt; &lt;Button title=&quot;Toestemming vragen&quot; onPress={requestPermission} /&gt; &lt;/View&gt; ); } return ( &lt;View style={{alignItems: &quot;stretch&quot;, flex: 1}}&gt; &lt;Camera ref={cameraRef} style={{flex: 1}} type={CameraType.front}/&gt; {photo ? &lt;Image source={{uri: photo}} style={{flex: 1}} /&gt; : &lt;View style={{flex:1}} /&gt;} &lt;Button title=&quot;Take picture&quot; onPress={takePicture} /&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h3"},{"title":"Meer informatie​","type":1,"pageTitle":"Camera","url":"/webframeworks-cursus/react-native-course/extra/camera#meer-informatie","content":" Voor meer informatie over de expo-camera package kan je de documentatie raadplegen. ","version":"Next","tagName":"h3"},{"title":"AsyncStorage","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra/async-storage","content":"","keywords":"","version":"Next"},{"title":"Installatie​","type":1,"pageTitle":"AsyncStorage","url":"/webframeworks-cursus/react-native-course/extra/async-storage#installatie","content":" Om AsyncStorage te gebruiken moeten we eerst de @react-native-async-storage/async-storage library installeren:  npx expo install @react-native-async-storage/async-storage   ","version":"Next","tagName":"h2"},{"title":"Opslaan/uitlezen van een string​","type":1,"pageTitle":"AsyncStorage","url":"/webframeworks-cursus/react-native-course/extra/async-storage#opslaanuitlezen-van-een-string","content":" Om een string op te slaan in AsyncStorage gebruiken we de setItem functie. Deze functie heeft twee parameters: de key en de value. De key is een string die we gebruiken om de value later terug op te halen. De value is de string die we willen opslaan.  import React from &quot;react&quot;; import { View, Text, Button } from &quot;react-native&quot;; import AsyncStorage from &quot;@react-native-async-storage/async-storage&quot;; const storeData = async () =&gt; { await AsyncStorage.setItem(&quot;name&quot;, &quot;John Doe&quot;); }; const getData = async () =&gt; { const value = await AsyncStorage.getItem(&quot;name&quot;); if (value !== null) { alert(value); } else { alert(&quot;No Data found&quot;); } }; const App = () =&gt; { return ( &lt;View&gt; &lt;Text&gt;AsyncStorage&lt;/Text&gt; &lt;Button title=&quot;Store Data&quot; onPress={storeData} /&gt; &lt;Button title=&quot;Load Data&quot; onPress={getData } /&gt; &lt;/View&gt; ); }; export default App;   ","version":"Next","tagName":"h2"},{"title":"Opslaan/uitlezen van een getal​","type":1,"pageTitle":"AsyncStorage","url":"/webframeworks-cursus/react-native-course/extra/async-storage#opslaanuitlezen-van-een-getal","content":" Wil je een getal rechtstreeks opslagen in AsyncStorage dan moet je eerst de waarde omzetten naar een string. Dit kan je doen met de toString functie. Om een getal terug te halen uit AsyncStorage moet je eerst de string omzetten naar een getal. Dit kan je doen met de parseInt functie.  import React from &quot;react&quot;; import { View, Text, Button } from &quot;react-native&quot;; import AsyncStorage from &quot;@react-native-async-storage/async-storage&quot;; const storeData = async () =&gt; { let randomNumber : number = Math.floor(Math.random() * 100); await AsyncStorage.setItem(&quot;randomNumber&quot;, randomNumber.toString()); }; const getData = async () =&gt; { const value : string = await AsyncStorage.getItem(&quot;randomNumber&quot;); if (value !== null) { alert(parseInt(value)); } else { alert(&quot;No Data found&quot;); } }; const App = () =&gt; { return ( &lt;View&gt; &lt;Text&gt;AsyncStorage&lt;/Text&gt; &lt;Button title=&quot;Store Data&quot; onPress={storeData} /&gt; &lt;Button title=&quot;Load Data&quot; onPress={getData } /&gt; &lt;/View&gt; ); }; export default App;   ","version":"Next","tagName":"h2"},{"title":"Opslaan/uitlezen van een object​","type":1,"pageTitle":"AsyncStorage","url":"/webframeworks-cursus/react-native-course/extra/async-storage#opslaanuitlezen-van-een-object","content":" Om een object op te slaan in AsyncStorage moet je eerst het object omzetten naar een string. Dit kan je doen met de JSON.stringify functie. Om een object terug te halen uit AsyncStorage moet je eerst de string omzetten naar een object. Dit kan je doen met de JSON.parse functie.  import React from &quot;react&quot;; import { View, Text, Button } from &quot;react-native&quot;; import AsyncStorage from &quot;@react-native-async-storage/async-storage&quot;; interface Student { name: string; age: number; } const storeData = async () =&gt; { let student : Student = { name: &quot;John Doe&quot;, age: Math.floor(Math.random() * 10) + 18 }; await AsyncStorage.setItem(&quot;randomStudent&quot;, JSON.stringify(student)); }; const getData = async () =&gt; { const value : string = await AsyncStorage.getItem(&quot;randomStudent&quot;); if (value !== null) { let student : Student = JSON.parse(value); alert(student.name + &quot; is &quot; + student.age + &quot; years old&quot;); } else { alert(&quot;No Data found&quot;); } }; const App = () =&gt; { return ( &lt;View&gt; &lt;Text&gt;AsyncStorage&lt;/Text&gt; &lt;Button title=&quot;Store Data&quot; onPress={storeData} /&gt; &lt;Button title=&quot;Load Data&quot; onPress={getData } /&gt; &lt;/View&gt; ); }; export default App;   Je kan ook een array van objecten opslaan in AsyncStorage. Dit werkt op dezelfde manier als een enkel object.  ","version":"Next","tagName":"h2"},{"title":"State in AsyncStorage​","type":1,"pageTitle":"AsyncStorage","url":"/webframeworks-cursus/react-native-course/extra/async-storage#state-in-asyncstorage","content":" We kunnen ook de state van een component opslaan in AsyncStorage. Dit kan handig zijn als we de state willen bijhouden als de gebruiker de applicatie sluit. We moeten er dan voor zorgen dat elke wijziging in state ook opgeslagen wordt in AsyncStorage.  import React, { useState, useEffect } from &quot;react&quot;; import { View, Text, Button } from &quot;react-native&quot;; import AsyncStorage from &quot;@react-native-async-storage/async-storage&quot;; const App = () =&gt; { const [counter, setCounter] = useState(0); useEffect(() =&gt; { const getData = async () =&gt; { const value = await AsyncStorage.getItem(&quot;counter&quot;); if (value !== null) { setCounter(parseInt(value)); } }; getData(); }, []); useEffect(() =&gt; { const storeData = async () =&gt; { await AsyncStorage.setItem(&quot;counter&quot;, counter.toString()); }; storeData(); }, [counter]); return ( &lt;View&gt; &lt;Text&gt;AsyncStorage&lt;/Text&gt; &lt;Text&gt;Counter: {counter}&lt;/Text&gt; &lt;Button title=&quot;Increment&quot; onPress={() =&gt; setCounter(counter + 1)} /&gt; &lt;/View&gt; ); }; export default App;   We gebruiken hier twee useEffect hooks. De eerste useEffect hook wordt uitgevoerd als het component voor het eerst geladen wordt. In deze useEffect hook halen we de waarde van counter op uit AsyncStorage. Als er een waarde gevonden wordt dan zetten we deze waarde in de state van het component. Als er geen waarde gevonden wordt dan blijft de state op 0 staan.  De tweede useEffect hook wordt uitgevoerd als de state van counter verandert. In deze useEffect hook slaan we de nieuwe waarde van counter op in AsyncStorage.  ","version":"Next","tagName":"h2"},{"title":"Meer informatie​","type":1,"pageTitle":"AsyncStorage","url":"/webframeworks-cursus/react-native-course/extra/async-storage#meer-informatie","content":" Voor meer informatie over de AsyncStorage package kan je de documentatie raadplegen. ","version":"Next","tagName":"h2"},{"title":"Core Components","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/core-components","content":"","keywords":"","version":"Next"},{"title":"View​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#view","content":" De View component is het meest gebruikte component in React Native. Het is een container component die andere componenten kan bevatten. De View component is vergelijkbaar met de div tag in HTML.  import React from &quot;react&quot;; import { StyleSheet, Text, View } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;Hello World&lt;/Text&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, paddingTop: Constants.statusBarHeight, backgroundColor: &quot;#fff&quot;, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot;, }, }); export default App;   Dezelfde app zou er in React.js als volgt uitzien:  import React from &quot;react&quot;; const App = () =&gt; { return ( &lt;div style={styles.container}&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/div&gt; ); } const styles = { container: { display: &quot;flex&quot;, flex: 1, height: &quot;100vh&quot;, width: &quot;100vw&quot;, backgroundColor: &quot;#fff&quot;, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot;, }, } export default App;   Je ziet dat deze twee componenten erg veel op elkaar lijken. De View component is een container component die andere componenten kan bevatten. De div tag in HTML is ook een container component die andere elementen kan bevatten. Een belangrijk verschil is dat alle Views by default flexbox containers zijn. Je hoeft dit niet expliciet aan te geven. In React.js moet je dit wel expliciet aangeven door de display: flex property toe te voegen aan de div tag.  ","version":"Next","tagName":"h2"},{"title":"StyleSheet​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#stylesheet","content":" Het StyleSheet component is een object dat alle styling informatie bevat. In React.js wordt dit meestal gedaan met CSS. In React Native wordt dit gedaan in JavaScript. Het StyleSheet component is een object dat alle styling informatie bevat.  Een stylesheet kan je als volgt aanmaken:  import React from &quot;react&quot;; import { StyleSheet, Text, View } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;View style={styles.box}/&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight, }, box: { width: 100, height: 100, backgroundColor: &quot;red&quot;, borderWidth: 1, borderColor: &quot;black&quot;, borderRadius: 10 } }); export default App;   We maken hier een vierkant aan met een rode achtergrond. De borderWidth property geeft aan hoe dik de rand van het vierkant moet zijn. De borderColor property geeft aan welke kleur de rand moet hebben. De borderRadius property geeft aan hoeveel de hoeken van het vierkant afgerond moeten worden.  Merk op dat we hier gebruik maken van Constants.statusBarHeight. Dit is een variabele die de hoogte van de statusbalk bevat. Zo kunnen we ervoor zorgen dat de app niet onder de statusbalk komt te staan.  Je kan nog meer styling properties toevoegen aan een View. Je kan deze hier vinden:  https://reactnative.dev/docs/view-style-props  ","version":"Next","tagName":"h2"},{"title":"Inline styles​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#inline-styles","content":" Het is ook mogelijk rechstreeks in de style property van een View een object mee te geven. Dit is echter niet aan te raden. Het is beter om een stylesheet aan te maken en deze te gebruiken. Dit is beter voor de performance van je app. Inline styles zijn echter wel handig als je snel een style wilt testen.  import React from &quot;react&quot;; import { StyleSheet, Text, View } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={{paddingTop: Constants.statusBarHeight}}&gt; &lt;View style={{width: 100,height: 100, backgroundColor: &quot;red&quot;,borderWidth: 1,borderColor: &quot;black&quot;,borderRadius: 10}}/&gt; &lt;/View&gt; ); } export default App;   ","version":"Next","tagName":"h2"},{"title":"Text​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#text","content":" De Text component is een component die tekst kan weergeven. De Text component is vergelijkbaar met de p tag in HTML.  Hieronder een aantal voorbeelden van veel voorkomende style properties  import React from &quot;react&quot;; import { StyleSheet, Text, View } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.hello}&gt;Hello World&lt;/Text&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight }, hello: { fontSize: 20, fontWeight: &quot;bold&quot;, fontStyle: &quot;italic&quot;, textDecorationLine: &quot;underline&quot;, textAlign: &quot;center&quot;, color: &quot;red&quot; } }); export default App;   Meer informatie over de styling props van het Text component kan je hier vinden:  https://reactnative.dev/docs/text-style-props  ","version":"Next","tagName":"h2"},{"title":"Text nesting​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#text-nesting","content":" Het is mogelijk om een Text component in een andere Text component te nesten.  import React from &quot;react&quot;; import { StyleSheet, Text, View } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;Hello&lt;Text style={styles.world}&gt; World&lt;/Text&gt;&lt;/Text&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight }, world: { color: &quot;blue&quot;, fontWeight: &quot;bold&quot; } }); export default App;   ","version":"Next","tagName":"h3"},{"title":"Image​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#image","content":" Een Image is een react component om verschillende types van afbeeldingen te laten zien:  Afbeeldingen van het internetStatic image resourcesAfbeeldingen van local storage (zoals fotos van de camera)  ","version":"Next","tagName":"h2"},{"title":"Static image resources​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#static-image-resources","content":" De afbeeldingen komen mee in je project directory staan bij de source bestanden. Je kan deze afbeeldingen gebruiken door de require functie te gebruiken.  &lt;Image source={require(&quot;./bunny.jpg&quot;)}/&gt;   ","version":"Next","tagName":"h3"},{"title":"Afbeeldingen van het internet​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#afbeeldingen-van-het-internet","content":" Je kan ook afbeeldingen van het internet gebruiken. Dit doe je door de uri property te gebruiken. Images van het internet moeten altijd een width en een height style hebben.  import React from &quot;react&quot;; import { StyleSheet, Text, View, Image } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Image style={styles.image} source={{ uri: &quot;https://reactnative.dev/img/tiny_logo.png&quot;, }} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight }, image: { width: 100, height: 100 } }); export default App;   ","version":"Next","tagName":"h3"},{"title":"Styling​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#styling","content":" Images zijn ook View objecten, dus je kan ze ook stylen.  Meer informatie over de styling props van het Image component kan je hier vinden:  https://reactnative.dev/docs/image-style-props  ","version":"Next","tagName":"h3"},{"title":"Resize mode​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#resize-mode","content":" De resizeMode property kan je gebruiken om de manier waarop een image wordt weergegeven in het geval dat de afmetingen van de image niet overeenkomen met de afmetingen van de Image component.  De volgende waarden zijn mogelijk:  repeat - herhaalt de afbeeldingcontain - De afbeelding wordt zo groot mogelijk gemaakt, maar er wordt wel rekening gehouden met de aspect ratio van de afbeelding. De afbeelding wordt niet uitgerekt.center - De afbeelding wordt niet veranderd van grootte. De afbeelding wordt gecentreerd in de Image component.stretch - De afbeelding wordt zo groot mogelijk gemaakt. Er wordt geen rekening gehouden met de aspect ratio van de afbeelding. De afbeelding wordt uitgerekt.  import React from &quot;react&quot;; import { StyleSheet, Text, View, Image } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Image style={styles.image} source={{ uri: &quot;https://reactnative.dev/img/tiny_logo.png&quot;, }} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight }, image: { width: 150, height: 200, resizeMode: &quot;center&quot; } }); export default App;   ","version":"Next","tagName":"h3"},{"title":"TextInput​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#textinput","content":" De TextInput component is een component die gebruikt kan worden om tekst in te voeren. De TextInput component is vergelijkbaar met de input tag in HTML.  import React from &quot;react&quot;; import { StyleSheet, Text, View, TextInput } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;TextInput secureTextEntry={false} autoCapitalize=&quot;characters&quot; placeholder=&quot;Enter your name&quot; keyboardType=&quot;default&quot; style={styles.textinput} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight}, textinput: { borderColor: &quot;red&quot;, borderWidth: 1} }); export default App;   Meer informatie over de props van het TextInput component kan je hier vinden:  https://reactnative.dev/docs/textinput#props  ","version":"Next","tagName":"h2"},{"title":"Button​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#button","content":" De Button component is een component die gebruikt kan worden om een button te maken. De Button component is vergelijkbaar met de button tag in HTML.  Op beide platformen zal de button een native feel hebben en button heeft beperkte styling mogelijkheden.  import React from &quot;react&quot;; import { StyleSheet, Button, View} from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Button title=&quot;Hello World&quot; color=&quot;green&quot; disabled={false}/&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight } }); export default App;   ","version":"Next","tagName":"h2"},{"title":"Pressable​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#pressable","content":" Zoals we hiervoor hebben vermeld is de Button component beperkt in styling mogelijkheden. Het Pressable component maakt het mogelijk andere Views te gebruiken als button.  Zelfs als je een Button component gebruikt, wordt er achter de schermen een Pressable component gebruikt om de button te maken.  import React from &quot;react&quot;; import { StyleSheet, Text, View, Pressable, Alert } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Pressable style={styles.pressable} onPress={() =&gt; { Alert.alert(&quot;Pressed!&quot;); }} &gt; &lt;Text&gt;Press Me&lt;/Text&gt; &lt;/Pressable&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight}, pressable: { backgroundColor: &quot;red&quot; } }); export default App;   Je kan de stijl van de Pressable laten aanpassen afhankelijk hij ingedrukt is of niet. Dit doe je door in plaats van een style object mee te geven een functie mee te geven die een style object teruggeeft.  import React from &quot;react&quot;; import { StyleSheet, Text, View, Pressable, Alert } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Pressable style={(style) =&gt; (style.pressed) ? styles.pressedTrue : styles.pressedFalse} onPress={() =&gt; Alert.alert(&quot;Pressed!&quot;)} &gt; &lt;Text style={{color: &quot;white&quot;}}&gt;Press Me&lt;/Text&gt; &lt;/Pressable&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight}, pressedTrue: { backgroundColor: &quot;red&quot;, padding: 10, borderRadius: 5}, pressedFalse: { backgroundColor: &quot;blue&quot;, padding: 10, borderRadius: 5} }); export default App;   ","version":"Next","tagName":"h2"},{"title":"Handling events​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#handling-events","content":" Zoals we al bij de pressable hebben gezien, kan je events afhandelen door een functie mee te geven aan de onPress prop.  Pas op in html zijn events altijd in lowercase geschreven, in react native zijn events altijd in camelCase geschreven.  ","version":"Next","tagName":"h2"},{"title":"Button​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#button-1","content":" import React from &quot;react&quot;; import { StyleSheet, Button, View, Alert } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Button title=&quot;Press me&quot; onPress={() =&gt; { Alert.alert(&quot;Pressed!&quot;); }} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight} }); export default App;   ","version":"Next","tagName":"h3"},{"title":"TextInput​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#textinput-1","content":" TextInput heeft een aantal event handlers die je kan gebruiken:  onChange: wordt aangeroepen wanneer de tekst in de input verandert.onChangeText: wordt aangeroepen wanneer de tekst in de input verandert. Het verschil met onChange is dat onChangeText de nieuwe tekst als argument meekrijgt.onSubmitEditing: wordt aangeroepen wanneer de gebruiker op de submit knop drukt.onFocus: wordt aangeroepen wanneer de gebruiker de input selecteert.onKeyPress: wordt aangeroepen wanneer de gebruiker een toets indrukt.  import React from &quot;react&quot;; import { StyleSheet, View, TextInput, Alert } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;TextInput placeholder=&quot;Enter your name&quot; onChangeText={(text) =&gt; { console.log(text); }} onChange={(event) =&gt; { console.log(event.nativeEvent.text); }} onSubmitEditing={(event) =&gt; { console.log(event.nativeEvent.text); }} onFocus={() =&gt; { console.log(&quot;Focused&quot;); }} onKeyPress={(event) =&gt; { console.log(event.nativeEvent.key); }} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight} }); export default App;   ","version":"Next","tagName":"h3"},{"title":"Pressable​","type":1,"pageTitle":"Core Components","url":"/webframeworks-cursus/react-native-course/core-components#pressable-1","content":" Pressable heeft een aantal event handlers die je kan gebruiken:  onPress: wordt aangeroepen wanneer de gebruiker op de button drukt.onPressIn: wordt aangeroepen wanneer de gebruiker op de button begint te drukken.onPressOut: wordt aangeroepen wanneer de gebruiker de button loslaat.onLongPress: wordt aangeroepen wanneer de gebruiker de button lang ingedrukt houdt. Standaard op 500ms. Kan aangepast worden met de delayLongPress prop.  import React from &quot;react&quot;; import { StyleSheet, View, Pressable, Alert, Text } from &quot;react-native&quot;; import Constants from &quot;expo-constants&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Pressable delayLongPress={1000} onPress={() =&gt; { Alert.alert(&quot;Pressed!&quot;); }} onPressIn={() =&gt; { Alert.alert(&quot;Pressed in!&quot;); }} onPressOut={() =&gt; { Alert.alert(&quot;Pressed out!&quot;); }} onLongPress={() =&gt; { Alert.alert(&quot;Long pressed!&quot;); }} &gt; &lt;Text&gt;Press Me&lt;/Text&gt; &lt;/Pressable&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { paddingTop: Constants.statusBarHeight} }); export default App;  ","version":"Next","tagName":"h3"},{"title":"Expo Application Services","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra/eas","content":"","keywords":"","version":"Next"},{"title":"Installeren​","type":1,"pageTitle":"Expo Application Services","url":"/webframeworks-cursus/react-native-course/extra/eas#installeren","content":" Het eerste wat je moet doen is de EAS CLI installeren. Dit kan je doen met het volgende commando:  npm install -g eas-cli   vervolgens kan je inloggen met het volgende commando:  eas login   Hier moet je inloggen met je Expo account die je ook gebruikt om in te loggen in de Expo Go app.  ","version":"Next","tagName":"h2"},{"title":"Configuratie​","type":1,"pageTitle":"Expo Application Services","url":"/webframeworks-cursus/react-native-course/extra/eas#configuratie","content":" Om EAS te gebruiken moet je een configuratie bestand toevoegen aan je project. Je kan een basis configuratie bestand toevoegen met het volgende commando:  eas build:configure   Dit commando zal een bestand eas.json toevoegen aan je project. In dit bestand kan je verschillende configuratie opties toevoegen.  Hieronder een voorbeeld van een eas.json bestand:  { &quot;cli&quot;: { &quot;version&quot;: &quot;&gt;= 13.4.2&quot;, &quot;appVersionSource&quot;: &quot;remote&quot; }, &quot;build&quot;: { &quot;development&quot;: { &quot;distribution&quot;: &quot;internal&quot;, &quot;ios&quot;: { &quot;simulator&quot;: true }, &quot;android&quot;: { &quot;buildType&quot;: &quot;apk&quot; } }, &quot;preview&quot;: { &quot;distribution&quot;: &quot;internal&quot; }, &quot;production&quot;: { &quot;autoIncrement&quot;: true } }, &quot;submit&quot;: { &quot;production&quot;: {} } }   Dit bestand zorgt ervoor dat we development builds kunnen maken voor iOS en Android. Voor iOS maken we gebruik van de simulator en voor Android maken we een APK bestand.  ","version":"Next","tagName":"h2"},{"title":"Builden​","type":1,"pageTitle":"Expo Application Services","url":"/webframeworks-cursus/react-native-course/extra/eas#builden","content":" Als we een build willen maken voor android kunnen we het volgende commando gebruiken:  eas build --platform android --profile development   Dit commando zal in de cloud een build maken voor Android. Als je een build wil maken voor iOS kan je het volgende commando gebruiken:  eas build --platform ios --profile development   Dit kan enige tijd in beslag nemen omdat de build in de cloud gebeurt en we op de free tier zitten. Je krijgt een link naar de build zodat je deze kan opvolgen.  ","version":"Next","tagName":"h2"},{"title":"Installeren op je telefoon​","type":1,"pageTitle":"Expo Application Services","url":"/webframeworks-cursus/react-native-course/extra/eas#installeren-op-je-telefoon","content":" Als je naar de link gaat die je krijgt na het builden van je applicatie kan je de applicatie downloaden op je telefoon. Dit kan je doen door de QR code te scannen of door de link te openen in de browser van je telefoon. Je kan de applicatie dan installeren op je telefoon. Dit werkt alleen bij Android. Jammer genoeg moet je voor iOS een betalende developer account hebben om de applicatie te installeren op je telefoon. Je kan wel de applicatie installeren op een simulator door het bestand te slepen naar de simulator. ","version":"Next","tagName":"h2"},{"title":"Location","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra/location","content":"","keywords":"","version":"Next"},{"title":"installatie​","type":1,"pageTitle":"Location","url":"/webframeworks-cursus/react-native-course/extra/location#installatie","content":" expo-location is een aparte package die je moet installeren. Dit doe je met de volgende commando:  npx expo install expo-location   ","version":"Next","tagName":"h2"},{"title":"Gebruik​","type":1,"pageTitle":"Location","url":"/webframeworks-cursus/react-native-course/extra/location#gebruik","content":" Ook voor het gebruik van expo-location moet je eerst de permissies vragen. Dit doe je aan de hand van de requestForegroundPermissionsAsync functie. We gaan in dit voorbeeld de permissies direct vragen wanneer het App component wordt gerenderd. We doen dit aan de hand van een useEffect hook.  import React, { useState, useEffect } from &quot;react&quot;; import { Platform, Text, View, StyleSheet } from &quot;react-native&quot;; import { requestForegroundPermissionsAsync, LocationObject, getCurrentPositionAsync, } from &quot;expo-location&quot;; const App = () =&gt; { const [location, setLocation] = useState&lt;LocationObject | null&gt;(null); const [errorMsg, setErrorMsg] = useState&lt;string | null&gt;(null); useEffect(() =&gt; { (async () =&gt; { let { status } = await requestForegroundPermissionsAsync(); if (status !== &quot;granted&quot;) { setErrorMsg(&quot;Permission to access location was denied&quot;); return; } let location = await getCurrentPositionAsync({}); setLocation(location); })(); }, []); let text = &quot;Waiting..&quot;; if (errorMsg) { text = errorMsg; } else if (location) { text = JSON.stringify(location); } return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.paragraph}&gt;{text}&lt;/Text&gt; &lt;/View&gt; ); }; export default App;   ","version":"Next","tagName":"h2"},{"title":"Meer informatie​","type":1,"pageTitle":"Location","url":"/webframeworks-cursus/react-native-course/extra/location#meer-informatie","content":" Voor meer informatie over expo-location kan je de documentatie raadplegen. ","version":"Next","tagName":"h2"},{"title":"CSS Frameworks in React Native","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra/Nativewind","content":"","keywords":"","version":"Next"},{"title":"Nativewind Installeren​","type":1,"pageTitle":"CSS Frameworks in React Native","url":"/webframeworks-cursus/react-native-course/extra/Nativewind#nativewind-installeren","content":" ","version":"Next","tagName":"h2"},{"title":"Nativewind configureren​","type":1,"pageTitle":"CSS Frameworks in React Native","url":"/webframeworks-cursus/react-native-course/extra/Nativewind#nativewind-configureren","content":" In dit voorbeeld vertrekken we vanuit een expo-router project. Dit project werd aangemaakt met behulp van volgend commando:  npx create-expo-app -t expo-template-typescript-router nativewind-voorbeeld   Wanneer je een project hebt aangemaakt, kan je Nativewind installeren.  Opgelet, zorg dat je eerst cd naar je nieuwe project-folder.  npx expo install nativewind tailwindcss react-native-reanimated react-native-safe-area-context   Open het bestand genaamd babel.config.js in je project root folder. In dit bestand zal je Nativewind moeten toevoegen als importSource en als preset:  module.exports = function (api) { api.cache(true); return { presets: [ [&quot;babel-preset-expo&quot;, { jsxImportSource: &quot;nativewind&quot; }], &quot;nativewind/babel&quot;, ], }; };   Als laatste willen we ook de types toevoegen voor Typescript support. Maak een bestand nativewind-env.d.ts aan in je project root folder (dus niet in de app folder).  /// &lt;reference types=&quot;nativewind/types&quot; /&gt;   ","version":"Next","tagName":"h3"},{"title":"TailwindCSS configureren​","type":1,"pageTitle":"CSS Frameworks in React Native","url":"/webframeworks-cursus/react-native-course/extra/Nativewind#tailwindcss-configureren","content":" Om Nativewind te gebruiken, wordt TailwindCSS geinstalleerd en in het build-proces van React Native geintegreerd. Om dit te doen werken, is er nog wat extra configuratie nodig van je project. Het volgende commando maakt een config bestand voor TailwindCSS genaamd tailwind.config.js.  npx tailwindcss init   Open het bestand tailwind.config.js. Hierin vind je een object met 4 arrays:  content: welke bestanden gebruik maken van de TailwindCSS stylingpresets: welke presets deze bestanden altijd zullen bevattentheme: aanpassingen die je wilt maken aan de default-styling van TailwindCSSplugins: verschillende plugins voor TailwindCSS die je kan gebruiken in je project  Pas de inhoud van het bestand aan, zodat je content en presets ingevuld zijn.  /** @type {import('tailwindcss').Config} */ module.exports = { // NOTE: Update this to include the paths to all of your component files. content: [&quot;./app/**/*.{js,jsx,ts,tsx}&quot;], presets: [require(&quot;nativewind/preset&quot;)], theme: { extend: {}, }, plugins: [], }   Maak nu een bestand aan genaamd global.css in je project root folder (dus niet in de app folder). Voeg daarin de verwijzingen toe naar de 3 hoofd-onderdelen van TailwindCSS  @tailwind base; @tailwind components; @tailwind utilities;   Gebruik vervolgens dit CSS bestand in de main _layout.tsx van je app folder.  import &quot;../global.css&quot;;   ","version":"Next","tagName":"h3"},{"title":"Metro configureren​","type":1,"pageTitle":"CSS Frameworks in React Native","url":"/webframeworks-cursus/react-native-course/extra/Nativewind#metro-configureren","content":" Als laatste stap moet Metro zelf ook geconfigureerd worden. Standaard zal Metro geen config bestand aanmaken, en daardoor z'n default waardes gebruiken. Wij willen nu enkele van die default waardes aanpassen, dus maken we een config bestand aan voor metro met het volgende commando:  npx expo customize metro.config.js   Open vervolgens het bestand metro.config.js en pas dit aan als volgt:  const { getDefaultConfig } = require(&quot;expo/metro-config&quot;); const { withNativeWind } = require(&quot;nativewind/metro&quot;); const config = getDefaultConfig(__dirname); module.exports = withNativeWind(config, { input: &quot;./global.css&quot; });   ","version":"Next","tagName":"h3"},{"title":"Nativewind Gebruiken​","type":1,"pageTitle":"CSS Frameworks in React Native","url":"/webframeworks-cursus/react-native-course/extra/Nativewind#nativewind-gebruiken","content":" Nativewind zorgt ervoor dat je het classname attribute terug kunt gebruiken (dat je kent vanuit React).  Open het bestand index.tsx. Voeg daarin het volgende Text element toe aan het return-statement:  &lt;Text className=&quot;bg-black text-white font-bold italic&quot;&gt;Edit app/index.tsx to edit this screen.&lt;/Text&gt;   Je kan nog steeds gebruik maken van inline styles en eigen styles, net zoals ervoor.  function Index() { return ( &lt;View style={{ flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, }} &gt; &lt;Text className=&quot;bg-black text-white font-bold italic&quot;&gt;Edit app/index.tsx to edit this screen.&lt;/Text&gt; &lt;/View&gt; ); }  ","version":"Next","tagName":"h2"},{"title":"Platform Specific Code","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra/platform-specific-code","content":"","keywords":"","version":"Next"},{"title":"Platform API​","type":1,"pageTitle":"Platform Specific Code","url":"/webframeworks-cursus/react-native-course/extra/platform-specific-code#platform-api","content":" De Platform API is een globale variabele die je kunt importeren vanuit react-native. Deze variabele heeft twee eigenschappen: OS en Version. De OS eigenschap geeft aan of je op iOS of Android werkt. De Version eigenschap geeft het versienummer van het platform.  De onderstaande code laat zien hoe je alle informatie van het platform kan ophalen:  import React from &quot;react&quot;; import { Platform, View, Text } from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View&gt; &lt;Text&gt;Platform&lt;/Text&gt; &lt;Text&gt;OS: {Platform.OS}&lt;/Text&gt; &lt;Text&gt;Version: {Platform.Version}&lt;/Text&gt; {Platform.OS === &quot;ios&quot; &amp;&amp; &lt;Text&gt;Je werkt op iOS&lt;/Text&gt;} {Platform.OS === &quot;android&quot; &amp;&amp; &lt;Text&gt;Je werkt op Android&lt;/Text&gt;} &lt;/View&gt; ); }; export default App;   ","version":"Next","tagName":"h2"},{"title":"Platform specifieke style​","type":1,"pageTitle":"Platform Specific Code","url":"/webframeworks-cursus/react-native-course/extra/platform-specific-code#platform-specifieke-style","content":" Soms wil je een style toepassen die alleen op een bepaald platform werkt. In dit geval kun je de Platform.select functie gebruiken om een style te selecteren op basis van het platform.  De onderstaande code laat zien hoe je een style kan selecteren op basis van het platform:  import React from &quot;react&quot;; import { Platform, View, Text, StyleSheet } from &quot;react-native&quot;; const styles = StyleSheet.create({ container: { flex: 1, ...Platform.select({ android: { backgroundColor: &quot;green&quot;, }, ios: { backgroundColor: &quot;red&quot;, }, default: { backgroundColor: &quot;blue&quot;, }, }), }, }); const App = () =&gt; { return &lt;View style={styles.container}&gt;&lt;/View&gt;; }; export default App;  ","version":"Next","tagName":"h2"},{"title":"Expo Router","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/expo-router","content":"","keywords":"","version":"Next"},{"title":"Installatie​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#installatie","content":" Als je expo-router wil gebruiken in je project moet je eerst enkele packages installeren en een aantal bestanden aanpassen. Deze stappen worden hieronder uitgelegd.  ","version":"Next","tagName":"h2"},{"title":"Nieuw project​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#nieuw-project","content":" Als je nog geen project hebt kan je een nieuw project aanmaken met een template en hoef je geen ingewikkelde installatie te doen.  npx create-expo-app &lt;my-project&gt; --template expo-template-typescript-router   of korter:  npx create-expo-app -t expo-template-typescript-router &lt;my-project&gt;   Je moet nog wel de scheme property aanpassen in je app.json (zie verder).  ","version":"Next","tagName":"h3"},{"title":"Bestaand project​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#bestaand-project","content":" Packages installeren​  Installeer de library in je project:  npx expo install expo-router react-native-safe-area-context react-native-screens expo-linking expo-constants expo-status-bar react-native-gesture-handler react-native-web react-dom @react-navigation/drawer react-native-reanimated   Package.json aanpassen​  Pas de main property in je package.json aan:  { &quot;main&quot;: &quot;expo-router/entry&quot; }   app.json aanpassen​  Pas je app.json aan:  { ... &quot;scheme&quot;: &quot;your-app-scheme&quot; ... &quot;web&quot;: { ... &quot;bundler&quot;: &quot;metro&quot; } }   Je moet de scheme property aanpassen naar een unieke naam voor je app. Dit is nodig voor deep linking. Je kan hier bijvoorbeeld de naam van je app voor gebruiken. Je moet er wel voor zorgen dat deze naam uniek is.  babel.config.js aanpassen​  Je moet de babel.config.js aanpassen zodat expo-router en react-native-reanimated correct werken.  module.exports = function (api) { ... return { ... plugins: ['expo-router/babel','react-native-reanimated/plugin'], }; };   ","version":"Next","tagName":"h3"},{"title":"Schermen toevoegen​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#schermen-toevoegen","content":" Als een bestand wordt aangemaakt in de app directory, wordt het automatisch een route in de app. Bijvoorbeeld, de volgende bestanden zullen de volgende routes maken:  app/index.tsx komt overeen met /app/home.tsx komt overeen met /homeapp/settings/index.tsx komt overeen met /settingsapp/[user].tsx komt overeen met dynamische paden zoals /expo of /joske  Deze paden kunnen worden gebruikt in de Link component om te navigeren naar een bepaald scherm. Als je de applicatie op een webbrowser opent, kan je ook de URL aanpassen om naar een bepaald scherm te navigeren.  ","version":"Next","tagName":"h2"},{"title":"Het eerste scherm​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#het-eerste-scherm","content":" Als je nu de applicatie opstart met expo start dan krijg je de volgende pagina te zien:    Zoals de melding aangeeft moet je een directory app aanmaken met daarin een bestand index.tsx. Dit bestand wordt gebruikt als eerste scherm van je applicatie.  import React from &quot;react&quot;; import { View, StyleSheet, Text } from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; } }) export default App;   Als je dan de applicatie opnieuw opstart zal de home pagina getoond worden.  ","version":"Next","tagName":"h3"},{"title":"Nog een scherm toevoegen​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#nog-een-scherm-toevoegen","content":" Willen we een tweede scherm toevoegen voor een bepaalde route dan maken we een bestand aan in de app directory met de naam van de route. Bijvoorbeeld app/about.tsx voor de route /about.  import React from &quot;react&quot;; import { View, StyleSheet, Text } from &quot;react-native&quot;; const About = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Text&gt;About Screen&lt;/Text&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; } }) export default About;   ","version":"Next","tagName":"h3"},{"title":"Dynamische routes​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#dynamische-routes","content":" Je kan ook dynamische routes maken. Dit doe je door een bestand aan te maken met de naam van de route en tussen vierkante haken de naam van de parameter. Bijvoorbeeld app/users/[name].tsx voor de route /users/expo of /users/joske.  import { useLocalSearchParams } from &quot;expo-router&quot;; import React from &quot;react&quot;; import { View, StyleSheet, Text } from &quot;react-native&quot;; const User = () =&gt; { const { name } = useLocalSearchParams&lt;{name: string}(); return ( &lt;View style={styles.container}&gt; &lt;Text&gt;User : { name }&lt;/Text&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; } }) export default User;   ","version":"Next","tagName":"h3"},{"title":"Navigeren tussen schermen​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#navigeren-tussen-schermen","content":" Expo Router gebruikt het Link component om te navigeren tussen schermen. Dit component heeft een href property die de route bepaalt.  &lt;Link href=&quot;/about&quot;&gt;About&lt;/Link&gt;   Het Link component wrapt de children in een &lt;Text&gt; component. Dit is handig voor accessibility maar niet altijd gewenst. Je kan het component aanpassen door de asChild property te gebruiken. Deze property zal alle props doorgeven aan het eerste child van het Link component. Het child component moet de onPress en onClick props ondersteunen.  &lt;Link href=&quot;/about&quot; asChild&gt; &lt;Button title=&quot;About&quot; /&gt; &lt;/Link&gt;   of gebruik makende van de Pressable component:  &lt;Link href=&quot;/about&quot; asChild&gt; &lt;Pressable&gt; &lt;Text&gt;About&lt;/Text&gt; &lt;/Pressable&gt; &lt;/Link&gt;   ","version":"Next","tagName":"h2"},{"title":"Imperatief navigeren​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#imperatief-navigeren","content":" Je kan ook imperatief (via programma code) navigeren. Bijvoorbeeld als je een formulier hebt en je wil na het indienen van het formulier naar een andere pagina navigeren.  import { router } from 'expo-router'; ... router.replace(&quot;/about&quot;); ...   Op het router object kan je de volgende methodes gebruiken:  push : voegt een nieuwe pagina toe aan de navigatie stackreplace : vervangt de huidige pagina in de navigatie stackback : gaat terug naar de vorige pagina in de navigatie stackcanGoBack: geeft aan of er een vorige pagina is in de navigatie stacksetParams: verandert de parameters van de huidige pagina in de navigatie stack  ","version":"Next","tagName":"h3"},{"title":"Dynamische routes linken​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#dynamische-routes-linken","content":" Je kan dynamische router linken door zelf de route aan te maken door concatenatie van de route en de parameters. Of je kan hiervoor het Href object gebruiken.  &lt;Link href={{ pathname: &quot;/users/[name]&quot;, params: { name: 'bacon' } }}&gt; View user &lt;/Link&gt;   ","version":"Next","tagName":"h3"},{"title":"Route vervangen​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#route-vervangen","content":" Per default worden routes toegevoegd aan de navigatie stack. Dit betekent dat de vorige pagina beschikbaar is als de gebruiker terug navigeert. Je kan de replace property gebruiken om de huidige pagina te vervangen in plaats van een nieuwe toe te voegen.  &lt;Link href=&quot;/about&quot; replace&gt; &lt;Text&gt;About&lt;/Text&gt; &lt;/Link&gt;   ","version":"Next","tagName":"h3"},{"title":"Layout routes​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#layout-routes","content":" Normaal gezien vult een route het volledige scherm. Als je tussen schermen navigeert is dit een volledige pagina transitie zonder animatie. In native apps verwachten gebruikers dat gedeelde elementen zoals headers en tab bars behouden blijven tussen pagina's. Deze worden gemaakt met behulp van layout routes.  ","version":"Next","tagName":"h2"},{"title":"Layout route aanmaken​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#layout-route-aanmaken","content":" Om een layout route aan te maken maak je een bestand aan met de naam _layout.tsx in de app directory.  import { Slot } from 'expo-router'; const HomeLayout = () =&gt; { return &lt;Slot /&gt;; } export default HomeLayout;   In het voorbeeld hierboven zal de Slot component de huidige child route renderen. Dit is vergelijkbaar met de children prop in React. Deze component kan gewrapt worden met andere componenten om een layout te maken.  import { Slot } from 'expo-router'; const HomeLayout = () =&gt; { return ( &lt;View&gt; &lt;Text&gt;Header&lt;/Text&gt; &lt;Slot /&gt; &lt;Text&gt;Footer&lt;/Text&gt; &lt;/View&gt; ); } export default HomeLayout;   Expo Router ondersteunt slechts één layout route per directory. Als je meerdere layout routes wil gebruiken moet je meerdere directories aanmaken.  - app - _layout.tsx - home - _layout.tsx - index.tsx   Het nadeel hiervan is dat het pad hierdoor &quot;vervuilt&quot; wordt met overbodige directories. Je kan dit probleem oplossen door een deel van de directory structuur te verbergen door een deel van het pad te omringen met ronde haakjes.  app/root/home.tsx komt overeen met /root/homeapp/(root)/home.tsx komt overeen met /home  Dit is handig om layouts toe te voegen zonder extra segmenten aan de URL toe te voegen. Je kan zoveel groepen toevoegen als je wil.  ","version":"Next","tagName":"h3"},{"title":"Native layouts​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#native-layouts","content":" Uiteraard wordt er niet vaak gebruik gemaakt van eigen layouts en wordt er vooral gebruik gemaakt van de ingebouwde native layouts van het platform. Expo Router ondersteunt de volgende native layouts:  Stack NavigationTab NavigationDrawer NavigationModals  ","version":"Next","tagName":"h2"},{"title":"Stack Navigation​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#stack-navigation","content":" Stack Navigation is de meest gebruikte layout. Het is een layout waarbij de schermen op elkaar gestapeld worden. Je kan navigeren naar een volgend scherm en terugkeren naar het vorige scherm.  Om de schermen te stacken moet je het _layout.tsx bestand aanpassen en een Stack component gebruiken.  import { Stack } from 'expo-router'; const HomeLayout = () =&gt; { return ( &lt;Stack/&gt; ); } export default HomeLayout;   Configuratie​  Je kan de header van de schermen aanpassen door de screenOptions property te gebruiken van het Stack component.  &lt;Stack screenOptions={{ headerStyle: { backgroundColor: '#f4511e', }, headerTintColor: '#fff', headerTitleStyle: { fontWeight: 'bold', }, }} /&gt;     Je kan als children van het Stack component de schermen individueel configureren door ze Stack.Screen componenten te gebruiken. Dit is handig om bijvoorbeeld de titel van de header aan te passen.  &lt;Stack screenOptions={{ headerStyle: { backgroundColor: '#f4511e', }, headerTintColor: '#fff', headerTitleStyle: { fontWeight: 'bold', }, }} &gt; &lt;Stack.Screen name=&quot;index&quot; options={{title: &quot;Home&quot;}}&gt;&lt;/Stack.Screen&gt; &lt;Stack.Screen name=&quot;users/[name]&quot; options={{title: &quot;User&quot;}}&gt;&lt;/Stack.Screen&gt; &lt;/Stack&gt;   Hierboven gaan we dus de titel van de header aanpassen voor de home pagina en de mische route.  Het is ook mogelijk om het Stack.Screen component te gebruiken in het component zelf. Dus in plaats van de Stack component te gebruiken in het _layout.tsx bestand kan je het Stack.Screen component gebruiken in het index.tsx bestand.  const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;Stack.Screen options={{title: &quot;Home&quot;}}&gt;&lt;/Stack.Screen&gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; ) }   Dit maakt het mogelijk om de header iets dynamischer te maken met informatie uit de pagina. Dit is bijvoorbeeld interessant voor pagina's met dynamische routes.  const User = () =&gt; { const { name } = useLocalSearchParams&lt;{name: string}&gt;(); return ( &lt;View style={styles.container}&gt; &lt;Stack.Screen options={{title: &quot;User: &quot; + name}}&gt;&lt;/Stack.Screen&gt; &lt;Text&gt;User : { name }&lt;/Text&gt; &lt;/View&gt; ) }   Omdat expo router gebaseerd is op React Navigation kan je alle mogelijke opties voor het Stack.Screen component kan je hier terugvinden.  Animation​  Je kan de animatie van de transitie tussen schermen aanpassen door de animation property mee te geven in het options object van het Stack.Screen component.  &lt;Stack.Screen name=&quot;index&quot; options={{ animation: 'slide_from_right', }} /&gt;   De volgende animaties zijn beschikbaar:  default : de standaard animatiefade : fade in en fade outslide_from_right : slide in van rechts en slide out naar rechtsslide_from_left : slide in van links en slide out naar linksslide_from_bottom : slide in van onder en slide out naar ondernone: geen animatiemeer animaties zijn beschikbaar in de documentatie  ","version":"Next","tagName":"h3"},{"title":"Tab Navigation​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#tab-navigation","content":" De werking van een Tab Navigation is vergelijkbaar met een Stack Navigation. Het verschil is dat de schermen niet op elkaar gestapeld worden maar dat er een tab bar wordt toegevoegd.  Om een Tab Navigation te gebruiken moet je het _layout.tsx bestand aanpassen en een Tabs component gebruiken.  import { Tabs } from 'expo-router'; const HomeLayout = () =&gt; { return ( &lt;Tabs&gt; &lt;Tabs.Screen // Name of the dynamic route. name=&quot;index&quot; options={{ title: 'Home', }} /&gt; &lt;Tabs.Screen // Name of the dynamic route. name=&quot;about&quot; options={{ title: 'About', }} /&gt; &lt;/Tabs&gt; ); } export default HomeLayout;   Je kan eventueel ook bepaalde paginas onzichtbaar maken uit de tab bar door de href property op null te zetten.  &lt;Tabs.Screen name=&quot;users/[name]&quot; options={{ href: null }} /&gt;   Je kan deze href property ook gebruiken om een andere route te linken aan de tab. Bv als je deze naar een specifieke user wil linken.  Je kan nog meer opties voor het Tabs.Screen component hier terugvinden. Een zeer interessante optie is de tabBarIcon property. Hiermee kan je een icoon toevoegen aan de tab bar.  import { Tabs } from 'expo-router'; import { FontAwesome } from &quot;@expo/vector-icons&quot;; const HomeLayout = () =&gt; { return ( &lt;Tabs&gt; &lt;Tabs.Screen name=&quot;index&quot; options={{ title: 'Home', tabBarIcon: ({color, size}) =&gt; &lt;FontAwesome name=&quot;home&quot; size={size} color={color} /&gt; }} /&gt; &lt;Tabs.Screen name=&quot;about&quot; options={{ title: 'About', tabBarIcon: ({color, size}) =&gt; &lt;FontAwesome name=&quot;adjust&quot; size={size} color={color} /&gt; }} /&gt; &lt;/Tabs&gt; ); } export default HomeLayout;   Een lijst van alle beschikbare icons kan je vinden op https://icons.expo.fyi. Je hoeft hier geen aparte package voor te installeren, deze icons zijn al beschikbaar in `@expo/vector-icons``.  ","version":"Next","tagName":"h3"},{"title":"Drawer Navigation​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#drawer-navigation","content":" Om een Drawer Navigation te gebruiken moet je het _layout.tsx bestand aanpassen en een Drawer component gebruiken.  import { Drawer } from 'expo-router/drawer'; const Layout = () =&gt; { return ( &lt;Drawer&gt; &lt;Drawer.Screen name=&quot;index&quot; options={{ title: 'Home', }} /&gt; &lt;Drawer.Screen name=&quot;about&quot; options={{ title: 'About', }} /&gt; &lt;/Drawer&gt; ); } export default Layout;   Je kan nog meer opties voor het Drawer.Screen component hier terugvinden.  ","version":"Next","tagName":"h3"},{"title":"Combineren van layouts​","type":1,"pageTitle":"Expo Router","url":"/webframeworks-cursus/react-native-course/expo-router#combineren-van-layouts","content":" Je kan layouts combineren door meerdere layouts te gebruiken in een directory. Bijvoorbeeld een Tab Navigation in combinatie met een Stack Navigation. Stel dat je eerst een pagina hebt zonder tab bar en als je op een bepaalde link klikt krijg je een pagina met een tab bar.  De structuur van de directory ziet er dan als volgt uit:  - app - _layout.tsx - home - _layout.tsx - screen1.tsx - screen2.tsx   De _layout.tsx in de app directory ziet er dan als volgt uit:  import { Stack } from 'expo-router'; const Layout = () =&gt; { return ( &lt;Stack&gt; &lt;Stack.Screen name=&quot;index&quot; options={{ // Hide the header for all other routes. headerShown: false, }} /&gt; &lt;Stack.Screen name=&quot;home&quot; options={{ // Set the presentation mode to modal for our modal route. presentation: 'modal', headerShown: false, }} /&gt; &lt;/Stack&gt; ); } export default Layout;   met de index.tsx:  import { View, Text, Button } from 'react-native'; import { Link } from 'expo-router'; const Home = () =&gt; { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text style={{fontWeight: &quot;bold&quot;, fontSize: 24}}&gt;Welcome to the app&lt;/Text&gt; &lt;Text style={{fontWeight: &quot;100&quot;, marginBottom: 20}}&gt;This is a dummy text&lt;/Text&gt; &lt;Link href=&quot;/home&quot; replace asChild&gt; &lt;Button title='Home Screen'/&gt; &lt;/Link&gt; &lt;/View&gt; ); } export default Home;   met de home/_layout.tsx:  import { Tabs } from &quot;expo-router&quot; import { FontAwesome } from &quot;@expo/vector-icons&quot;; const Layout = () =&gt; { return ( &lt;Tabs&gt; &lt;Tabs.Screen name=&quot;screen1&quot; options={{ // Hide the header for all other routes. headerShown: false, tabBarIcon: ({color, size}) =&gt; &lt;FontAwesome name=&quot;home&quot; size={size} color={color} /&gt; }} /&gt; &lt;Tabs.Screen name=&quot;screen1&quot; options={{ // Hide the header for all other routes. headerShown: false, tabBarIcon: ({color, size}) =&gt; &lt;FontAwesome name=&quot;address-card&quot; size={size} color={color} /&gt; }} /&gt; &lt;/Tabs&gt; ) } export default Layout;   met de home/screen1.tsx:  import { View, Text } from &quot;react-native&quot;; const Page1 = () =&gt; { return ( &lt;View style={{ flex: 1, alignItems: 'center', justifyContent: 'center' }}&gt; &lt;Text style={{ fontWeight: &quot;bold&quot;, fontSize: 24 }}&gt;Welcome to screen 1&lt;/Text&gt; &lt;Text style={{ fontWeight: &quot;100&quot;, marginBottom: 20 }}&gt;This is screen 1&lt;/Text&gt; &lt;/View&gt; ); } export default Page1;  ","version":"Next","tagName":"h3"},{"title":"Labo","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs","content":"Labo","keywords":"","version":"Next"},{"title":"Labo 1","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs/lab1","content":"","keywords":"","version":"Next"},{"title":"Opdracht: Core Components​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/react-native-course/labs/lab1#opdracht-core-components","content":" ","version":"Next","tagName":"h2"},{"title":"Maak een nieuw project aan​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/react-native-course/labs/lab1#maak-een-nieuw-project-aan","content":" Maak een nieuw project CoreComponents aan met expo. Vervang de inhoud van App.tsx door de volgende code:  import React from &quot;react&quot;; import { Text, View, StyleSheet, Button } from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, backgroundColor: &quot;#ff&quot;, }, }); export default App;   Verwijder alle styles in container maar laat backgroundColor staan.  ","version":"Next","tagName":"h3"},{"title":"Tekst toevoegen​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/react-native-course/labs/lab1#tekst-toevoegen","content":" Maak een functie die een willekeurig getal tussen 0 en 10 teruggeeft. Noem deze functie random0To10.Voeg een Text component toe aan de View van de App functie component. Als tekst toon je het getal dat random0To10 teruggeeft.Voeg daarna ook de tekst Het getal is toe aan deze Text component met daarachter het getal (zonder extra Text component te gebruiken)Gebruik nu een tweede Text component om het getal in drukletters te tonen. Maak hiervoor een style boldText aan die je gebruikt via het styles attribuut.  ","version":"Next","tagName":"h3"},{"title":"Styling​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/react-native-course/labs/lab1#styling","content":" Maak een nieuwe View als kind van de originele View aan. Plaats daarin een Text component met de tekst SubView.  Geef Subview een breedte van 100. Geef het een rode rand van breedte 2, een padding van 10.  Geef het nieuwe Text component in Subview een blauwe achtergrond met witte letters.  ","version":"Next","tagName":"h3"},{"title":"Images​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/react-native-course/labs/lab1#images","content":" Voeg 2 afbeeldingen toe aan de originele view: 1 afbeelding van een Pokemon die je lokaal toevoegt aan jouw project en een andere afbeelding van een filmposter die je via de URL aanspreekt (en dus niet downloadt).  Geef beide afbeeldingen een breedte en hoogte van 100.  Zorg dat beide afbeeldingen volledig te zien zijn.  ","version":"Next","tagName":"h3"},{"title":"Input​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/react-native-course/labs/lab1#input","content":" Voeg een TextInput component toe die  een zwarte rand heeftde tekst verstopt die je typt (als een password)als standaard text &quot;Enter Password&quot; toontde tekst aan de gebruiker toont via een alert wanneer de gebruiker de enter (return/submit) toets gebruikt  Voeg een Button component toe die  rood isde tekst Random bevatwanneer een gebruiker erop drukt, de alert The number is X waar X een waarde is die Random0To10 teruggeeft (dit hoeft niet dezelfde waarde te zijn als die in het tekst veld)  Zorg dat wanneer een gebruiker de Pokemon 3 seconden indrukt, je de naam van de Pokemon in een alert toont.    ","version":"Next","tagName":"h3"},{"title":"Opdracht: RandomMoviePosters​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/react-native-course/labs/lab1#opdracht-randommovieposters","content":" Maak een nieuw expo project aan met de naam RandomMoviePosters. Deze app toont 6 posters van films. Je mag zelf kiezen waar je deze filmposters vandaan haalt.  Zorg dat de app  de 6 posters onder mekaar toontde posters volledig te zien zijn met een maximum hoogte van 50de volgorde van de posters verandert elke keer de de app opnieuw laadtals je op een poster drukt, krijg je een alert met de filmnaam als titel en jaar als beschrijving eronder.  Zorg ook dat:  de data van posters (url, name, year) in een array van JSON objecten zitten (hoeft geen externe file te zijn, mag een variable zijn)een filmposter maar 1 keer op het scherm getoond wordttip: je gebruikt 6 keer de Image tag (dus geen loops, dat zien we later) ","version":"Next","tagName":"h2"},{"title":"Labo 2","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs/lab2","content":"","keywords":"","version":"Next"},{"title":"Opdracht: Rainbows​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/react-native-course/labs/lab2#opdracht-rainbows","content":" Maak een nieuw project Rainbows aan met expo. Vervang de inhoud van App.tsx door de volgende code:  import * as React from &quot;react&quot;; import { rainbow } from &quot;rainbow-colors-array-ts&quot;; import {View, StyleSheet} from &quot;react-native&quot;; import Constants from 'expo-constants'; export default function App() { return ( &lt;View style={styles.container}&gt; &lt;/View&gt; ); } const styles = StyleSheet.create({ container: { flex: 1, justifyContent: &quot;flex-start&quot;, paddingTop: Constants.statusBarHeight, } });   In dit labo gaan jullie spelen met Flexbox en Custom components. Ipv stapsgewijs de oefening op te bouwen, starten we deze keer met een screenshot. Het is de bedoeling dat jullie een React Native app maken die er exact hetzelfde uitziet:    We geven jullie hieronder enkele vereisten en tips:  ","version":"Next","tagName":"h2"},{"title":"Vereisten:​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/react-native-course/labs/lab2#vereisten","content":" Zorg dat elke regenboog voorgesteld wordt door 1 custom component RainbowGebruik een custom component Footer voor de tekst RainbowGebruik een custom component Letter voor elke letter van de tekst RainbowPlaats alle custom components in hun eigen bestandGebruik de npm library rainbow-colors-array-ts. Gebruik hier de functie als volgt: rainbow(10, &quot;hex&quot;,true); (lees de info op de npm pagina hoe je die gebruikt)  ","version":"Next","tagName":"h3"},{"title":"Tips:​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/react-native-course/labs/lab2#tips","content":" Geef de style van de de Rainbow component mee als propertyHet typescript type van deze property is: StyleProp&lt;ViewStyle&gt;Geef de array van kleuren van elk child element van Rainbow (dus elke &quot;blokje&quot; kleur) mee als propertyGeef de hoogte en breedte van elke child element van Rainbow mee als property (indien je niets meegeeft, zal de style van een element dit negeren)De eerste Rainbow heeft elementen van hoogte 10De tweede Rainbow heeft elementen van breedte 10De derde Rainbow heeft elementen van hoogte 50 en breedte 50De footer heeft een hoogte van 100de lettergrootte van de tekst Rainbow is 30Footer gebruik 7 maal de Letter componentDe tweede en derde Rainbow zitten samen in 1 View  Hier een screenshot met borders aan om een beter idee te krijgen van de layout:    ","version":"Next","tagName":"h3"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/react-native-course/labs/lab2#oplossingsvideo","content":"  ","version":"Next","tagName":"h3"},{"title":"MapView","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/extra/map-view","content":"","keywords":"","version":"Next"},{"title":"Installatie​","type":1,"pageTitle":"MapView","url":"/webframeworks-cursus/react-native-course/extra/map-view#installatie","content":" react-native-maps is een externe library die we moeten installeren. We kunnen dit doen met de expo install commando:  npx expo install react-native-maps   ","version":"Next","tagName":"h2"},{"title":"Gebruik​","type":1,"pageTitle":"MapView","url":"/webframeworks-cursus/react-native-course/extra/map-view#gebruik","content":" Om heel eenvoudig een kaart te tonen in React Native moeten we de MapView component gebruiken. Deze component heeft een region prop die we kunnen gebruiken om de initiele regio van de kaart te bepalen. We willen deze dynamisch maken, dus we zullen de region prop binden aan een state variabele.  latitudeDelta en longitudeDelta bepalen hoeveel van de kaart we willen tonen. Hoe kleiner deze waarden, hoe meer van de kaart we zien.  import React, { useState } from &quot;react&quot;; import { View, Text, Button } from &quot;react-native&quot;; import MapView, { Region, Coordinate } from &quot;react-native-maps&quot;; const App = () =&gt; { let [wonder, setWonder] = useState&lt;WorldWonder&gt;(worldWonders[0]); const showRandomWonder = () =&gt; { let randomIndex = Math.floor(Math.random() * worldWonders.length); setWonder(worldWonders[randomIndex]); }; return ( &lt;View style={{ flex: 1 }}&gt; &lt;MapView style={{ flex: 1 }} region={{ latitude: wonder.latitude, longitude: wonder.longitude, latitudeDelta: 0.0922, longitudeDelta: 0.0421, }} /&gt; &lt;Button title=&quot;Set random location&quot; onPress={showRandomWonder} /&gt; &lt;/View&gt; ); }; export default App;   ","version":"Next","tagName":"h2"},{"title":"Markers​","type":1,"pageTitle":"MapView","url":"/webframeworks-cursus/react-native-course/extra/map-view#markers","content":" We kunnen markers op de kaart plaatsen door de Marker component te gebruiken. Deze component heeft een coordinate prop die we kunnen gebruiken om de positie van de marker te bepalen. We gaan in volgend voorbeeld een marker plaatsen op de kaart per wereldwonder.  import React, { useState } from &quot;react&quot;; import { View, Text, Button } from &quot;react-native&quot;; import MapView, { Region, Coordinate } from &quot;react-native-maps&quot;; const App = () =&gt; { let [wonder, setWonder] = useState&lt;WorldWonder&gt;(worldWonders[0]); const showRandomWonder = () =&gt; { let randomIndex = Math.floor(Math.random() * worldWonders.length); setWonder(worldWonders[randomIndex]); }; return ( &lt;View style={{ flex: 1 }}&gt; &lt;MapView style={{ flex: 1 }} region={{ latitude: wonder.latitude, longitude: wonder.longitude, latitudeDelta: 0.0922, longitudeDelta: 0.0421, }} &gt; {worldWonders.map((wonder) =&gt; ( &lt;MapView.Marker key={wonder.name} coordinate={{ latitude: wonder.latitude, longitude: wonder.longitude, }} title={wonder.name} /&gt; ))} &lt;/MapView&gt; &lt;Button title=&quot;Set random location&quot; onPress={showRandomWonder} /&gt; &lt;/View&gt; ); }; export default App;   ","version":"Next","tagName":"h2"},{"title":"Meer informatie​","type":1,"pageTitle":"MapView","url":"/webframeworks-cursus/react-native-course/extra/map-view#meer-informatie","content":" Voor meer informatie over react-native-maps kan je de documentatie raadplegen. ","version":"Next","tagName":"h2"},{"title":"Labo 4","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs/lab4","content":"","keywords":"","version":"Next"},{"title":"Opdracht: Twitter​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/react-native-course/labs/lab4#opdracht-twitter","content":" Breidt de Twitter applicatie uit met expo router. De applicatie moet een Stack navigator combineren met een Tab navigator en een Drawer navigator.  De applicatie moet de volgende schermen bevatten:  Home: Een scherm met een lijst van tweets (vorige opgave)Profiles: Een scherm met een lijst van alle profielen.  Deze schermen moeten bereikbaar zijn via een tab navigator.    Als je op een profiel drukt, moet je naar een nieuw scherm gaan met de details van het profiel. Dit scherm moet bereikbaar zijn via een stack navigator (dus niet meer via de tab navigator). Het scherm zal dus boven de tab navigator komen.    Vervolgens heb je ook een drawer navigator nodig. Deze moet bereikbaar zijn via een hamburger menu in de header van het home scherm. De drawer moet momenteel enkel een settings scherm en het home scherm bevatten. De inhoud zullen we later nog uitbreiden.    ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/react-native-course/labs/lab4#oplossingsvideo","content":"     ","version":"Next","tagName":"h3"},{"title":"Opdracht: Rainbow Navigation​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/react-native-course/labs/lab4#opdracht-rainbow-navigation","content":" Ga verder met de code van labo 4 en kopieer deze naar een nieuw project.  We bouwen de volgende applicatie:    De applicatie bestaat uit drie schermen:  Een simpel &quot;Home&quot; scherm met een knop die naar scherm 3 gaatEen scherm dat de oefening van vorige week bevatEen scherm met een lijst van 200 kleuren verkregen via rainbow-colors-array-ts  Wanneer je op een kleur drukt, krijg je een detail scherm. Dit scherm heeft als achtergrondkleur de geselecteerde kleur en toont de hex waarde in de titel en in het midden van het scherm  Tips:​  Gebruik const colors = rainbow(200,&quot;hex&quot;,true); voor de 200 kleuren die je toont op het 3e scherm.Je hebt een custom component nodig voor de inhoud van het labo van vorige week.Je hebt hier een combinatie van Stack en Tab navigatie nodig.  ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/react-native-course/labs/lab4#oplossingsvideo-1","content":"    ","version":"Next","tagName":"h3"},{"title":"Labo 6","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs/lab6","content":"","keywords":"","version":"Next"},{"title":"Herhalingsopdracht: BPost app​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#herhalingsopdracht-bpost-app","content":" Maak de volgende app zo goed mogelijk na. De afbeeldingen tonen de verschillende schermen in de app. In de beschrijving onder elk scherm kan je de verschillende functies terugvinden van elk scherm.  Gebruik de volgende APIs om de data in te vullen en aan te passen:  https://sampleapis.assimilate.be/bpost/verzendenhttps://sampleapis.assimilate.be/bpost/ontvangenhttps://sampleapis.assimilate.be/bpost/profile  !LET OP! Knoppen die niet staan opgelijst in de functies hieronder, moet je niet implementeren of weergeven. Bv.: de rode icoontjes (3 puntjes, bewerk-icoontje, ...)  ","version":"Next","tagName":"h2"},{"title":"Home​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#home","content":" functies:  knoppen in het midden Details bekijken: &quot;ontvangen - actief&quot; schermverzenden: brengt je rechtstreeks naar het &quot;Verzenden - zending&quot; schermZending volgen: brengt je rechtstreeks naar het &quot;Ontvangen - zending volgen&quot; scherm menu (onderaan) home: dit schermontvangen: &quot;ontvangen - actief&quot; schermverzenden: &quot;verzenden - actief&quot; schermmeer: &quot;meer&quot; scherm    ","version":"Next","tagName":"h3"},{"title":"Ontvangen - actief​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#ontvangen---actief","content":" functies:  knoppen in het midden Bij leeg scherm: Naar Geschiedenis: &quot;ontvangen - geschiedenis&quot; scherm Bij actieve zendingen: Lijst met actieve zendingen. Elke zending brengt je naar het &quot;Ontvangen - detail&quot; scherm     ","version":"Next","tagName":"h3"},{"title":"Ontvangen - detail​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#ontvangen---detail","content":" functies:  terug knop bovenaan: brengt je terug naar het vorige scherm    ","version":"Next","tagName":"h3"},{"title":"Ontvangen - geschiedenis​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#ontvangen---geschiedenis","content":" functies:  knoppen in het midden Lijst met afgelopen/ontvangen zendingen. Elke zending brengt je naar het &quot;Ontvangen - detail&quot; scherm    ","version":"Next","tagName":"h3"},{"title":"Verzenden - actief​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#verzenden---actief","content":" functies:  knoppen in het midden Bij leeg scherm: Naar Geschiedenis: &quot;verzenden - geschiedenis&quot; scherm Bij actieve zendingen: Lijst met actieve zendingen. Elke zending brengt je naar het &quot;verzenden - detail&quot; scherm    ","version":"Next","tagName":"h3"},{"title":"Verzenden - detail​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#verzenden---detail","content":" functies:  terug knop bovenaan: brengt je terug naar het vorige scherm    ","version":"Next","tagName":"h3"},{"title":"Verzenden - geschiedenis​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#verzenden---geschiedenis","content":" functies:  knoppen in het midden Lijst met afgelopen/ontvangen verzonden pakketjes. Elke zending brengt je naar het &quot;Verzenden - detail&quot; scherm    ","version":"Next","tagName":"h3"},{"title":"Meer​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#meer","content":" functies:  knoppen in het midden Knop naar profiel pagina    ","version":"Next","tagName":"h3"},{"title":"Meer - Profiel​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/react-native-course/labs/lab6#meer---profiel","content":" formulier met account data   ","version":"Next","tagName":"h3"},{"title":"Labo 3","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs/lab3","content":"","keywords":"","version":"Next"},{"title":"Opdracht: Twitter​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#opdracht-twitter","content":" Maak een nieuwe react native app.  Zorg dat bij het opstarten van de app twee API calls gebeuren:  Ophalen van de tweets: https://my-json-server.typicode.com/similonap/twitter-json-server/tweetsOphalen van de profielen: https://my-json-server.typicode.com/similonap/twitter-json-server/profiles  Je kan dit in een DataProvider component doen en werken met een context.  Vervolgens zorg je dat de tweets in een lijst getoond worden. De lijst moet er als volgt uitzien:    Zorg er ook voor dat je een filter input veld hebt waarmee je de tweets kan filteren op basis van de naam van de auteur. De filter moet case insensitive zijn.  Voorzie een swipe down to refresh functionaliteit.  ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#oplossingsvideo","content":"   ","version":"Next","tagName":"h3"},{"title":"Opdracht: Dark/Light Toggle​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#opdracht-darklight-toggle","content":" Maak een nieuwe react native app. Plaats twee invoervelden in de app en een switch. ALs je op de switch duwt, veranderd de achtergrond kleur van de app initieel van wit naar zwart en omgekeerd. De invoervelden dienen om de kleur waartussen je kan switchen in te geven. De applicatie moet er als volgt uitzien:    ","version":"Next","tagName":"h2"},{"title":"Opdracht: Rainbows met state​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#opdracht-rainbows-met-state","content":" ","version":"Next","tagName":"h2"},{"title":"Stap 1: Loops​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#stap-1-loops","content":" Zorg dat je colors array 10 waarden bevat. Pas dan jouw Rainbow component aan zodat die over de eerste 6 waarden van de kleuren array loopt. (tip: je vervangt 6 lijnen code door 1 lijn)  Doe dit ook voor de Footer component: maak een variabele text aan die het woord Rainbow bevat en loop over de letters van het woord (tip: je vervangt 7 lijnen code door 1 lijn).  Zorg dat het woord dat in Footer getoond wordt nooit langer kan zijn dan 10 letters (bv: als je de variabele text de waarde &quot;Hallo ik ben een student van AP&quot; geeft, zie je in de footer alleen &quot;Hallo ik b&quot;)  ","version":"Next","tagName":"h3"},{"title":"Stap 2: State​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#stap-2-state","content":" Voeg een knop toe waarmee je de kleuren van de regenboog kan veranderen van pastel kleuren naar niet pastelkleuren (en omgekeerd)Voeg een input veld toe waar je een tekst kan ingeven. Als je op submit drukt, wordt de tekst in de footer veranderd naar de tekst die je ingegeven hebt. (tip: gebruik de onSubmitEditing event handler van een TextInput component)Je hebt hier twee state variabelen nodig.  Je kan je baseren op de volgende screen recording:    ","version":"Next","tagName":"h3"},{"title":"Stap 3: Randomize rainbow​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#stap-3-randomize-rainbow","content":" Voeg nog een extra knop toe waarmee je de kleuren van de regenboog kan randomizen. (tip: gebruik de Math.random() functie)De tekst in de footer mag niet mee gerandomized worden.De pastel knop moet ook nog steeds werken.    ","version":"Next","tagName":"h3"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/react-native-course/labs/lab3#oplossingsvideo-1","content":"  ","version":"Next","tagName":"h3"},{"title":"Labo 5","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs/lab5","content":"","keywords":"","version":"Next"},{"title":"Opdracht: Rainbow AsyncStorage​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/react-native-course/labs/lab5#opdracht-rainbow-asyncstorage","content":" Ga verder met de code van labo 5. Breidt de applicatie uit met de volgende functionaliteit:  Als de gebruiker de tekst veranderd in het tekstveld, wordt deze opgeslagen in AsyncStorage.Als de gebruiker veranderd tussen pastel en niet pastel kleuren, wordt dit opgeslagen in AsyncStorage.Als de gebruiker de applicatie opnieuw opstart, zal de laatst gekozen tekst getoond worden en de laatst gekozen kleuren.  ","version":"Next","tagName":"h2"},{"title":"Opdracht: Todo App​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/react-native-course/labs/lab5#opdracht-todo-app","content":" Maak een eenvoudige Todo App. De gebruiker moet een todo kunnen toevoegen aan een lijst aan de hand van een text input en een button onderaan het scherm. Als de gebruiker op de todo klikt wordt deze gemarkeerd als &quot;done&quot; en wordt de todo doorgestreept. Er wordt onder de todo bijgehouden op welke dag en uur de todo werd voltooid. Als de gebruiker een todo lang ingedrukt houdt, wordt deze verwijderd uit de lijst.  De todo's worden opgeslagen in AsyncStorage. Als de gebruiker de applicatie opnieuw opstart, worden de todo's opnieuw getoond.  De werking kan je hieronder zien:   ","version":"Next","tagName":"h2"},{"title":"Project Webframeworks","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/labs/project-opdracht","content":"","keywords":"","version":"Next"},{"title":"🥅 Overzicht en Leerdoelen​","type":1,"pageTitle":"Project Webframeworks","url":"/webframeworks-cursus/react-native-course/labs/project-opdracht#-overzicht-en-leerdoelen","content":" Met deze opdracht werk je aan de volgende leerdoelen:  De student maakt een mobiele app vertrekkend van een functionele analyseDe student maakt applicaties in react jsDe student maakt componenten met properties, hooks en statesDe student maakt gebruik van een routing library voor een applicatie met meerdere pagina’sDe student maakt componenten die met elkaar communiceren aan de hand van een gedeelde stateDe student maakt web applicaties die gebruik maken van externe web servicesDe student bouwt een user interface met gebruik van een UI component library  ","version":"Next","tagName":"h2"},{"title":"🔍 Project Webframeworks​","type":1,"pageTitle":"Project Webframeworks","url":"/webframeworks-cursus/react-native-course/labs/project-opdracht#-project-webframeworks","content":" In deze opdracht maak je gebruik van React Native om een mobiele applicatie te maken. Je maakt deze opdracht individueel.  Je kiest een onderwerp op basis van de beschikbare APIs, met uitzondering van de API die we gebruiken als voorbeeld in de les. Je kan de lijst met beschikbare APIs (en hun endpoints) terugvinden op https://sampleapis.assimilate.be/.  ","version":"Next","tagName":"h2"},{"title":"🛠️ Opdrachten​","type":1,"pageTitle":"Project Webframeworks","url":"/webframeworks-cursus/react-native-course/labs/project-opdracht#️-opdrachten","content":" ","version":"Next","tagName":"h2"},{"title":"opdracht 1: functionele analyse​","type":1,"pageTitle":"Project Webframeworks","url":"/webframeworks-cursus/react-native-course/labs/project-opdracht#opdracht-1-functionele-analyse","content":" Het functioneel design beschrijft de functionaliteiten van je mobiele applicatie zonder technische details, het toont wat er gaat komen. Teken een grey-boxed ontwerp/wireframe van elk scherm in je applicatie. Beschrijf op elk scherm de verschillende functies van de elementen op het scherm.    ","version":"Next","tagName":"h3"},{"title":"opdracht 2: implementatie​","type":1,"pageTitle":"Project Webframeworks","url":"/webframeworks-cursus/react-native-course/labs/project-opdracht#opdracht-2-implementatie","content":" Werk je mobiele applicatie verder uit met behulp van React Native. Je applicatie moet: minstens 3 screens bevatten, die je via routing kan bereiken. een flatlist of scrollview gebruiken. een API aanspreken met een GET request om data op te halen. Je kan kiezen uit deze lijst van beschikbare APIs. dezelfde API aanspreken met een POST/PUT request om data toe te voegen of aan te passen. gebruik maken van AsyncStorage. 2 of meer Expo components gebruiken. (filesystem, camera, map, notification, imagepicker, location, calendar,...) styling toepassen waarbij je de nadruk legt op UX. Tijdens het ontwikkelen let je op de volgende zaken: Je hanteert een clean code style opdelen in verschillende componentengebruik maken van verschillende filesvolgen van coding guidelines bv.: MDN JS coding guidelinesGoogle TS coding guidelines... ","version":"Next","tagName":"h3"},{"title":"Labo's","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs","content":"Labo's","keywords":"","version":"Next"},{"title":"Inleiding","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course","content":"Inleiding Web Frameworks In principe kan je met HTML, CSS en JavaScript elke website die je maar kan bedenken laten werken. Dat geldt zowel voor de frontend als de backend. In de praktijk is dit voor complexe applicaties niet haalbaar. Een fontend met heel veel onderling afhankelijke elementen scripten met alleen JavaScript is onnoemelijk complex. Een backend zelf HTTP requests volledig laten ontleden is dat ook. Frameworks maken het wel praktisch haalbaar complexe applicaties te schrijven. Het zijn geen op zichzelf staande programma's. Het zijn softwarepakketten waar je eigen code aan toevoegt om tot een resultaat te komen. Meestal zijn ze geschreven in dezelfde programmeertaal waarin jij je eigen code schrijft, maar doen ze veel zwaarder werk. De broncode voor React.js is bijvoorbeeld véél complexer dan om het even welke code die wij hier zullen schrijven, maar React.js op zich is geen applicatie. Pas wanneer je zelf code toevoegt, verkrijg je een applicatie. Web frameworks dienen om het schrijven van websites eenvoudiger te maken. Er bestaan zowel frontend web frameworks (React.js, Angular.js, Vue.js,...) als backend web frameworks (Express.js, Backbone.js,...). Single Page Applications In deze cursus gaan we voornamelijk kijken naar het meest gebruikte Single Page Applications framework namelijk React.js (ontwikkeld door Meta). Er zijn nog vele andere SPA-frameworks zoals Angular (door Google) en Vue.js. Deze frameworks laten het toe om eenvoudig uitgebreidere applicaties te maken dan met gewone JavaScript en algemene frameworks zoals jQuery. In het verleden werden pagina's nog volledig opgebouwd op de server zelf. Zo had je bijvoorbeeld PHP of node.js in combinatie met Express. In deze traditionele aanpak bezocht de gebruiker een URL om een pagina in te laden en werd het opbouwen van de pagina voornamelijk op de server zelf gedaan. Voor elke pagina die de gebruiker wou bezoeken, was dus ook een nieuwe GET request nodig. JavaScript werd toen voornamelijk gebruikt voor simpele animaties en interacties of geavanceerde styling die niet met CSS alleen te doen was. Hiervoor was de JavaScript library jQuery uiterst geschikt. Bij single page applicaties verloopt de interactie tussen client en server heel anders. De focus wordt verlegd naar de client. De gebruiker bezoekt maar 1 URL en krijgt maar 1 HTML-bestand terug met bijbehorende JavaScript files. Nadat deze allemaal ingeladen zijn wordt de eerste &quot;applicatiepagina&quot; getoond aan de gebruiker. Deze toont hetzelfde soort info dat in de traditionele aanpak op één HTML-pagina zou staan, maar ze stemt niet meer overeen met een HTML-bestand. De naam single page application wijst er dus op dat er maar één HTML-bestand is. Hij betekent niet dat je website niet opgedeeld kan zijn in applicatiepagina's die je via links bereikt. Merk op dat wij hier een onderscheid maken tussen &quot;HTML-pagina's&quot; en &quot;applicatiepagina's&quot;. Dat wordt niet overal gedaan, maar normaal is duidelijk uit de context wat bedoeld wordt. Veranderlijke data wordt niet meteen gedownload. Deze worden volledig via asynchrone API calls (ook &quot;AJAX calls&quot; genoemd) vanuit de client opgevraagd. Als je bijvoorbeeld een lijst van producten zou willen tonen vanuit je SPA, zal de paginastructuur meteen verschijnen, maar zullen de producten zelf iets later inladen. Dit komt omdat de client een API call moet doen om te vragen welke producten er precies zijn.","keywords":"","version":"Next"},{"title":"Flexbox","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/flexbox","content":"","keywords":"","version":"Next"},{"title":"Flexbox in React Native​","type":1,"pageTitle":"Flexbox","url":"/webframeworks-cursus/react-native-course/flexbox#flexbox-in-react-native","content":" React Native ondersteunt flexbox. Flexbox is een manier om de layout van je app te bepalen. Je kan flexbox gebruiken om de positie van elementen te bepalen, maar ook om de grootte van elementen te bepalen. Het is ontworpen om een consistente layout aan te bieden voor verschillende scherm groottes.  In React Native zijn alle elementen by default flexbox elementen. Het is dus belangrijk om te weten hoe flexbox werkt. Het is zeer gelijkaardig met flexbox voor css op web. Met wat uitzonderingen.  ","version":"Next","tagName":"h2"},{"title":"Flex Properties​","type":1,"pageTitle":"Flexbox","url":"/webframeworks-cursus/react-native-course/flexbox#flex-properties","content":" ","version":"Next","tagName":"h2"},{"title":"Flex Direction​","type":1,"pageTitle":"Flexbox","url":"/webframeworks-cursus/react-native-course/flexbox#flex-direction","content":" Met flexDirection kan je de primaire as van de layout bepalen.  Er zijn twee assen in flexbox: de main axis en de cross axis:  De main axis is de richting waarin flex items worden geplaatst.De cross axis is de richting die loodrecht staat op de main axis.    Als je flexDirection op row zet, dan zal de main axis horizontaal zijn. Dit wil zeggen dat alle items naast elkaar zullen staan.  Als je flexDirection op column zet, dan zal de main axis vertikaal zijn. Dit wil zeggen dat alle items onder elkaar zullen staan.  By default is de flexDirection column, maar bij web is dat row. Mobile apps zijn meer verticaal gericht.  import {View} from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={{flexDirection: &quot;row&quot;, flex: 1}}&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;red&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;green&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;blue&quot;}}/&gt; &lt;/View&gt; ) } export default App;   Andere mogelijkheden zijn: column-reverse en row-reverse. Deze werken hetzelfde als column en row, maar de items worden dan in omgekeerde volgorde geplaatst.    ","version":"Next","tagName":"h3"},{"title":"Flex​","type":1,"pageTitle":"Flexbox","url":"/webframeworks-cursus/react-native-course/flexbox#flex","content":" Flex geeft aan hoe de items van de container zich moeten verhouden tot de andere items in de container. De items gaan &quot;vechten&quot; om de ruimte in de container. Hoe meer flex een item heeft, hoe meer ruimte het zal krijgen.  Meestal zetten we de hoofdcontainer op flex: 1. Dit zorgt ervoor dat de container de volledige ruimte inneemt.  Hier is een voorbeeld van een container met 3 items. De eerste heeft flex: 1, de tweede heeft flex: 2 en de derde heeft flex: 3. De derde item zal dus 3 keer zo groot zijn als de eerste.  import {View} from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1}}&gt; &lt;View style={{flex: 1, backgroundColor: &quot;red&quot;}}/&gt; &lt;View style={{flex: 2, backgroundColor: &quot;green&quot;}}/&gt; &lt;View style={{flex: 3, backgroundColor: &quot;blue&quot;}}/&gt; &lt;/View&gt; ) } export default App;   ","version":"Next","tagName":"h3"},{"title":"justifyContent​","type":1,"pageTitle":"Flexbox","url":"/webframeworks-cursus/react-native-course/flexbox#justifycontent","content":" justifyContent bepaalt de verspreiding van de children over de main axis.  De mogelijkheden zijn:  flex-start: de items worden aan de start van de main axis geplaatst.flex-end: de items worden aan het einde van de main axis geplaatst.center: de items worden in het midden van de main axis geplaatst.space-between: de items worden verspreid over de main axis. De eerste en laatste item staan aan de start en het einde van de main axis.space-around: de items worden verspreid over de main axis. Er is evenveel ruimte tussen de items en de start en het einde van de main axis.  Default: flex-start  import {View} from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1, justifyContent: &quot;center&quot;}}&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;red&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;green&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;blue&quot;}}/&gt; &lt;/View&gt; ) } export default App;     alignItems  alignItems bepaalt hoe de items worden uitgelijnd over de cross axis.  De mogelijkheden zijn:  flex-start: de items worden aan de start van de cross axis geplaatst.flex-end: de items worden aan het einde van de cross axis geplaatst.center: de items worden in het midden van de cross axis geplaatst.stretch: de items worden uitgerekt om de volledige hoogte van de container te vullen. Dit werkt enkel als de relevante grootte van de items niet expliciet is gezet.  Default: stretch  import {View} from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1, justifyContent: &quot;flex-start&quot;, alignItems: &quot;center&quot;}}&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;red&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;green&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;blue&quot;}}/&gt; &lt;/View&gt; ) } export default App;     alignSelf  Als je een item wilt uitlijnen op een andere manier dan de rest van de items, dan kan je align self gebruiken.  import {View} from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1, justifyContent: &quot;flex-start&quot;, alignItems: &quot;center&quot;}}&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;red&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;green&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;blue&quot;, alignSelf: &quot;flex-start&quot;}}/&gt; &lt;/View&gt; ) } export default App;     flexWrap  Flex wrap bepaalt of de items op meerdere regels moeten worden weergegeven als ze niet op de main axis passen.  De mogelijkheden zijn:  nowrap: de items worden niet op meerdere regels weergegeven.wrap: de items worden op meerdere regels weergegeven.  Default: nowrap  import {View} from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={{flexDirection: &quot;row&quot;, flex: 1, justifyContent: &quot;flex-start&quot;, alignItems: &quot;flex-start&quot;, flexWrap:&quot;wrap&quot;, alignContent: &quot;flex-start&quot;}}&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;red&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;green&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;blue&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;pink&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;black&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;yellow&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;brown&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;turquoise&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;indigo&quot;}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;purple&quot;}}/&gt; &lt;/View&gt; ) } export default App;   alignContent bepaalt hoe de regels worden uitgelijnd als er meerdere regels zijn. Dit werkt enkel als flexWrap op wrap staat.  ","version":"Next","tagName":"h3"},{"title":"Absolute positioning​","type":1,"pageTitle":"Flexbox","url":"/webframeworks-cursus/react-native-course/flexbox#absolute-positioning","content":" Absolute positioning is een manier om de positie van een element te bepalen. Je moet hier zelf rekening houden met bepaalde schermgroottes.  Je gebruikt hier de properties top, bottom, left en right om de positie van het element te bepalen.  import {View} from &quot;react-native&quot;; const App = () =&gt; { return ( &lt;View style={{flexDirection: &quot;column&quot;, flex: 1, justifyContent: &quot;flex-start&quot;, alignItems: &quot;center&quot;}}&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;red&quot;, position: &quot;absolute&quot;, top: 0, left: 0}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;green&quot;, position: &quot;absolute&quot;, top: 50, right: 50}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;blue&quot;, position: &quot;absolute&quot;, bottom: 10, left: 10}}/&gt; &lt;View style={{width: 40, height: 40, backgroundColor: &quot;pink&quot;, position: &quot;absolute&quot;, bottom: 50, right: 30}}/&gt; &lt;/View&gt; ) } export default App;  ","version":"Next","tagName":"h2"},{"title":"Next.js","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/nextjs","content":"Next.js","keywords":"","version":"Next"},{"title":"Labo 1","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/nextjs/lab1","content":"","keywords":"","version":"Next"},{"title":"1. Bitcoin Price​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/nextjs/lab1#1-bitcoin-price","content":" Maak een nieuwe Next.js applicatie aan en noem deze bitcoin-next. Je mag zelf kiezen of je tailwind css wil gebruiken of niet.  Gebruik de https://sampleapis.assimilate.be/bitcoin/current API om de huidige prijs van Bitcoin op te halen en te tonen in je applicatie. Je laat 3 blokken zien met de prijs informatie per currency (USD, EUR, GBP).    Zorg ervoor dat je gebruik maakt van de volgende componenten:  CurrencyCard: toont de informatie van een enkele currency.CurrencyList: toont een lijst van CurrencyCard componenten. Deze component haalt de data op van de API en geeft deze door aan de CurrencyCard componenten.  Denk zelf eens na of er hier nood is aan client components.  Om duidelijk te maken wat er mogelijk is met server components en wat niet moet je de volgende mogelijke uitdagingen proberen te implementeren. Doe dit enkel alleen maar op het moment dat je het vorig deel hebt gemaakt.  Zorg ervoor als je op de currency klikt dat deze een andere background color krijgt. Denk opnieuw goe na over welke componenten client en welke server componenten zijn.Zorg ervoor dat de prijs van de bitcoin elke 10 seconden wordt uitgelezen. Kan je dan nog altijd server components gebruiken?Probeer een server component te gebruiken voor het initieel inlezen van de bitcoin data. De data moet blijven updaten elke minuut. ","version":"Next","tagName":"h2"},{"title":"React Basics","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics","content":"React Basics","keywords":"","version":"Next"},{"title":"Extra Oefeningen","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/extra","content":"","keywords":"","version":"Next"},{"title":"Tussentijdse toets 2023-2024​","type":1,"pageTitle":"Extra Oefeningen","url":"/webframeworks-cursus/wf-course/labs/react-basics/extra#tussentijdse-toets-2023-2024","content":" Routing en Context ( /5) Maak 3 componenten aan: HomeOefening1Oefening2Oefening3 Plaats elke component in z'n eigen .tsx bestand Gebruik client-side routing met het react-router package. In App.tsx gebruik je routing om elke component als een aparte pagina te gebruiken. Home is de startpagina (root route)Oefening1, Oefening2, Oefening3 krijgen elk een aparte route Voorzie een Root component die de gemeenschappelijke delen voor elke pagina bevat. Elke pagina heeft een header, met daarin een menu De menu bevat een link naar elke paginaGebruik het navLink element uit react-router-dom voor de links naar de verschillende pagina's. De Root component maakt gebruik van een context om te wisselen tussen een light-theme en een dark-theme. De header bevat een knop om te wisselen tussen de verschillende themes. De inhoud van de verschillende pagina's wordt getoond in een main element. De Home component toont de woorden &quot;Home page&quot; op het scherm. De kleuren zijn afhankelijk van het theme uit de theme-context. root ├── header │ ├── nav │ │ ├── link to oefening1 │ │ ├── link to oefening2 │ │ └── link to oefening3 │ │ │ └── button to switch between light and dark theme │ └── main └── specific page content     Oefening 1: State, Arrays en Hooks ( /5) Werk verder in oefening1.tsx (dat je aanmaakte in de eerste opdracht) In deze opdracht ga je een lijst van bieren inladen uit een online json bestand. Wanneer die lijst is ingeladen, toon je alle bieren met behulp van de bijhorende afbeelding. Wanneer je dan klikt op een bier, wordt dat bier bovenaan getoond als het geselecteerde bier. Het geselecteerde bier wordt bovenaan getoond met meer details. Gebruik de fetch api om de lijst met bieren op te halen uit de volgende url: https://raw.githubusercontent.com/slimmii/mock_api/main/beers/beers.json Toon alle bieren op basis van hun afbeelding in een raster van 5 kolommen. Wanneer je klikt op een bier-afbeelding, wordt dat bier geselecteerd: De bier-afbeelding krijgt een rode randLinks verschijnt een detail-weergave over het geselecteerde bier.    Oefening 2: State, Hooks en Callbacks ( /5) Werk verder in oefening2.tsx (dat je aanmaakte in de eerste opdracht) In deze oefening ga je een div element tonen, dat elke seconde 10% donkerder wordt. In het div element bevindt zich een number input. Het getal in de number input bepaalt hoe vaak per seconde de kleur donkerder wordt. Maak een div element. Laat hiermee elke seconde de achtergrond 10% donkerder worden (tip: gebruik een hsl waarde). Voorzie het div element van een number input. De slider bevat een minimum waarde van 1, en een maximum waarde van 10. Gebruik de waarde van de slider, zodat de slider bepaalt hoeveel keer per seconde de achtergrondkleur verandert. bv.: '1' zorgt ervoor dat de achtergrond kleur 1 keer per seconde verandert bv.: '2' zorgt ervoor dat de achtergrond kleur 2 keer per seconde verandert (dus elke 0.5s) bv.: '5' zorgt ervoor dat de achtergrond kleur 5 keer per seconde verandert (dus elke 0.2s)    Oefening 3: Component, state en Properties ( /5) Werk verder in oefening3.tsx (dat je aanmaakte in de eerste opdracht) In deze opdracht ga je de gebruiker een simpel rekenmachine tonen. De gebruiker krijgt 3 select elementen te zien (2 om een getal te selecteren, 1 om een bewerking te kiezen). Wanneer alle onderdelen zijn geselecteerd, wordt het resultaat van de bewerking getoond. Maak 3 nieuwe componenten: NumberSelector: Deze toont een multi-select (&lt;select multiple&gt;) element met daarin een lijst van alle gehele getallen tussen een minimum en een maximum waarde die je als property mee geeft.OperatorSelector: Deze toont 4 button elementen, één voor elk van de 4 basis operaties (+, -, *, /).Result: Deze toont het resultaat van een bewerking. De bewerking bestaat uit een lijst van getallen en een operator. bv.: [1, 2, 3, 4] en + wordt getoond als 1 + 2 + 3 + 4 = 10 De component Oefening1 (dat je aanmaakte in de eerste opdracht) zal bestaan uit 4 tsx elementen: NumberSelector: Hiermee selecteert de gebruiker alle getallen van de bewerking (hou CTRL ingedrukt om meerdere items in een multi-select te selecteren).OperatorSelector: Hiermee selecteert de gebruiker de operatie van de bewerking.Result: hiermee wordt het resultaat van de bewerking getoond. Maak gebruik van properties om alle eigenschappen op de correcte wijze aan elkaar door te geven. ","version":"Next","tagName":"h2"},{"title":"Labo 2","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2","content":"","keywords":"","version":"Next"},{"title":"1. Simpele componenten​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2#1-simpele-componenten","content":" 📂 Naam project: lab-components-basics 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-components-basics.  Maak de volgende componenten aan:  Header met als props title en subtitleList met als props items (array van strings). Elke string wordt getoond in een apart component ListItem met als props text.Gebruik hiervoor de map functie.Gebruik een ongeordende lijst (&lt;ul&gt;) om de items te tonen. Footer met als props copy en year  Gebruik deze componenten in de App component om de volgende pagina te maken:  Labo 2 Basic components item 1item 2item 3 © Andie Similon (2021)  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"2. Facebook cards​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2#2-facebook-cards","content":" 📂 Naam project: lab-components-facebook-card 🔗 Basis project: n/a  Maak een nieuw project aan en noem deze lab-components-facebook-card.  Neem de volgende code over.    Teken eerst op papier hoe je deze facebook card zou opdelen in componenten. Splits deze componenten op in aparte componenten. Zorg dat alle content aanpasbaar is via props.  Let er op dat componenten ook kunnen bestaan uit andere componenten.  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"3. Penguins​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2#3-penguins","content":" 📂 Naam project: lab-components-penguin-gallery 🔗 Basis project: n/a  Maak een nieuw project aan en noem deze lab-components-penguin-galleryPenguins.json in je src folder.  importeer dit bestand in je project aan de hand van import penguins from './penguins.json';Maak een component PenguinCard dat een penguin toont. Dit component aanvaard een property penguin met het type van een penguin uit het json bestand.Filter de pinguïns zodat je enkel de vrouwelijke pinguïns toont (property gender is &quot;Female&quot;).Toon alle vrouwelijke pinguïns in een grid met 3 kolommen. Gebruik hiervoor css modules.  Female Penguins Pip Species ID: 1 Description: A playful young penguin fond of swimming. Island: Macquarie Island Waddle Species ID: 1 Description: Leader of the rookery, very energetic. Island: Macquarie Island Pebble Species ID: 4 Description: Collects colorful pebbles, gentle disposition. Island: Antipodes Island Splash Species ID: 1 Description: Loves water sports, always active. Island: Macquarie Island Chilly Species ID: 2 Description: Enjoys sliding on ice with friends. Island: South Georgia  ","version":"Next","tagName":"h2"},{"title":"4. Slotmachine​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2#4-slotmachine","content":" 📂 Naam project: lab-components-slot-machine 🔗 Basis project: lab-basics-slot-machine  Kopieer de slotmachine code van labo 1 en noem deze nieuwe applicatie lab-components-slot-machine en zorg voor de volgende dingen:  SlotMachine: aanvaard een property slots die het aantal slots aangeeft. Deze component bevat de logica om de slots te genereren en te tonen. Je kan deze component ook gebruiken om de logica te schrijven om te bepalen of de speler gewonnen heeft of verloren heeft. &lt;SlotMachine slots={5} /&gt; Slot: deze component bevat de logica om een slot te tonen. De waarde van de slot wordt doorgegeven via een property value. &lt;Slot value={1} /&gt; Zorg ervoor dat je meerdere slotmachines kan tonen op een pagina. Toon bijvoorbeeld een SlotMachine met 5 slots, een SlotMachine met 4 slots en een SlotMachine met 3 slots. Gebruik css modules om de stijl van de slotmachine te bepalen. Je bent vrij om de stijl te kiezen.  De applicatie moet ongeveer er als volgt uitzien:  Labo 2: Slots Je hebt verloren Je hebt verloren Je hebt verloren Refresh  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"5. Maaltafels component​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2#5-maaltafels-component","content":" 📂 Naam project: lab-components-maaltafels 🔗 Basis project: lab-basics-multiplication-tables  Kopieer de maaltafels code van labo 1 naar een nieuw project en noem deze lab-components-maaltafels en zorg voor de volgende componenten:  MultiplicationTable: deze component bevat de logica om de tabel te tonen. Deze component bevat een property max die het maximum getal aangeeft dat getoond moet worden. &lt;MultiplicationTable max={5} /&gt; MultiplicationRow: deze component bevat de logica om 1 rij van de tabel te tonen. Deze component bevat een property factor die het getal aangeeft waarvan de tafel getoond moet worden. Deze component bevat ook een property max die het maximum getal aangeeft dat getoond moet worden. &lt;MultiplicationRow factor={2} max={5} /&gt; Header: deze component bevat de logica om de header van de tabel te tonen. Deze component bevat een property max die het maximum getal aangeeft dat getoond moet worden. &lt;Header max={5} /&gt;   De applicatie moet ongeveer er als volgt uitzien:  \t1\t2\t3\t4\t5 1\t1\t2\t3\t4\t5 2\t2\t4\t6\t8\t10 3\t3\t6\t9\t12\t15 4\t4\t8\t12\t16\t20 5\t5\t10\t15\t20\t25\t1\t2\t3\t4\t5\t6\t7 1\t1\t2\t3\t4\t5\t6\t7 2\t2\t4\t6\t8\t10\t12\t14 3\t3\t6\t9\t12\t15\t18\t21 4\t4\t8\t12\t16\t20\t24\t28 5\t5\t10\t15\t20\t25\t30\t35 6\t6\t12\t18\t24\t30\t36\t42 7\t7\t14\t21\t28\t35\t42\t49\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10 1\t1\t2\t3\t4\t5\t6\t7\t8\t9\t10 2\t2\t4\t6\t8\t10\t12\t14\t16\t18\t20 3\t3\t6\t9\t12\t15\t18\t21\t24\t27\t30 4\t4\t8\t12\t16\t20\t24\t28\t32\t36\t40 5\t5\t10\t15\t20\t25\t30\t35\t40\t45\t50 6\t6\t12\t18\t24\t30\t36\t42\t48\t54\t60 7\t7\t14\t21\t28\t35\t42\t49\t56\t63\t70 8\t8\t16\t24\t32\t40\t48\t56\t64\t72\t80 9\t9\t18\t27\t36\t45\t54\t63\t72\t81\t90 10\t10\t20\t30\t40\t50\t60\t70\t80\t90\t100  ","version":"Next","tagName":"h2"},{"title":"6. Who's that pokemon?​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2#6-whos-that-pokemon","content":" 📂 Naam project: n/a 🔗 Basis project: lab-basics-whos-that-pokemon  Kopieer het lab-basics-whos-that-pokemon project van labo 1 naar een nieuw project.  Maak een nieuw component PokemonImage dat de afbeelding van een pokemon toont. Deze component aanvaardt de volgende properties:  id: het id van de pokemon (1 = Bulbasaur, 2 = Ivysaur, ...)visible: boolean die aangeeft of de pokemon zichtbaar is of niet. Indien deze false is, moet de afbeelding zwart gemaakt worden (gebruik hiervoor de CSS filter brightness(0))size: de grootte van de afbeelding in pixels (standaard 200)  Toon in de App component twee keer de PokemonImage component. Eén keer met visible op false en één keer met visible op true.    ","version":"Next","tagName":"h2"},{"title":"7. Rainbow Props​","type":1,"pageTitle":"Labo 2","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab2#7-rainbow-props","content":" 📂 Naam project: lab-components-rainbow-props 🔗 Basis project: lab-basics-rainbow  Maak een kopie van de lab-basics-rainbow applicatie van labo 1 naar een nieuw project en noem deze lab-components-rainbow-props. En zorg voor de volgende componenten:  Rainbow: Heeft een property amount die het aantal kleuren aangeeft. Heeft ook een property direction die de richting van de kleuren aangeeft. Deze kan ofwel &quot;horizontal&quot; ofwel &quot;vertical&quot; zijn. Je kan de richting van de regenboog bepalen door de flexDirection van de container aan te passen.RainbowLine: Heeft een property color die de kleur van de lijn aangeeft. Heeft ook een property direction die de richting van de lijn aangeeft. Deze kan ofwel &quot;horizontal&quot; ofwel &quot;vertical&quot; zijn. De hoogte van de lijn is 4px indien de richting &quot;horizontal&quot; is, anders is de hoogte 100px.  Je kan dus bijvoorbeeld de volgende code gebruiken om een horizontale en een verticale regenboog te tonen:  &lt;Rainbow amount={10} direction=&quot;horizontal&quot;/&gt; &lt;Rainbow amount={20} direction=&quot;vertical&quot;/&gt;   Dit zal de volgende output geven:   ","version":"Next","tagName":"h2"},{"title":"Labo 3","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab3","content":"","keywords":"","version":"Next"},{"title":"Color Clicker​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab3#color-clicker","content":" 📂 Naam project: lab-events-color-clicker 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-events-color-clicker.  Maak een component ColorSquare aan met de volgende properties:  color: string, de kleur van de vierkantsize: number, de grootte van het vierkant  Gebruik een div element om het vierkant te tonen. Geef het vierkant de juiste kleur en grootte.  Zorg voor een event handler die een alert toont met de kleur van het vierkant als je erop klikt. Gebruik een handleClick functie (met het juiste type) die de kleur van het vierkant toont in een alert.  Maak 10 vierkanten met willekeurige kleuren en toon deze in een rij op het scherm.    ","version":"Next","tagName":"h2"},{"title":"TextInput​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab3#textinput","content":" 📂 Naam project: lab-events-text-input 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-events-text-input.  Maak een component TextInput aan met de volgende properties:  size: number, het aantal textboxes dat getoond moet worden  Maak een rij van textboxes met de grootte die je meekrijgt als property. Als je een textbox aanpast, toon je een alert met de positie van de textbox en de nieuwe waarde.    ","version":"Next","tagName":"h2"},{"title":"Checkbox Grid​","type":1,"pageTitle":"Labo 3","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab3#checkbox-grid","content":" 📂 Naam project: lab-events-checkbox-grid 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-events-checkbox-grid.  Maak een nieuw component CheckBox aan met de volgende properties:  size: number, de grootte van de grid  Maak een grid van checkboxes met de grootte die je meekrijgt als property. Als je op een checkbox klikt, toon je een alert met de positie van de checkbox en of deze aangevinkt is of niet. Het grid kan je maken met een array van arrays van booleans (type boolean[][]).  ","version":"Next","tagName":"h2"},{"title":"Lijsten","type":0,"sectionRef":"#","url":"/webframeworks-cursus/react-native-course/lists-and-keys","content":"","keywords":"","version":"Next"},{"title":"Lijsten met for lus​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/react-native-course/lists-and-keys#lijsten-met-for-lus","content":" We kunnen een lijst maken door een for lus te gebruiken. We kunnen dan een array maken en deze opvullen met een for lus. We kunnen dan deze array mappen naar een component.  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text,StyleSheet} from &quot;react-native&quot;; const App = () =&gt; { const names = [&quot;Andie&quot;,&quot;Lotte&quot;,&quot;Liene&quot;,&quot;Hanna&quot;]; let nameTexts : JSX.Element[] = []; for (let name of names) { nameTexts.push(&lt;Text key={name}&gt;{name}&lt;/Text&gt;); } return ( &lt;View style={styles.container}&gt; {nameTexts} &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;   notitie Dit is niet hoe we lijsten maken in React Native. We gebruiken hiervoor de map functie. Zie volgende stuk  ","version":"Next","tagName":"h2"},{"title":"Lijsten met map​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/react-native-course/lists-and-keys#lijsten-met-map","content":" De map functie is zeer handig om een lijst te maken. We kunnen een lijst maken door een array te maken en elk element te mappen naar een component. We moeten wel een key meegeven aan elk element in de lijst. Deze key moet uniek zijn voor elk element in de lijst. Dit gebeurt op dezelfde manier als in React.js.  Hieronder een voorbeeld dat een lijst van kleuren naar gekleurde views mapt. We gebruiken de kleurnamen hier als key maar let goed op dat dit niet altijd de beste keuze is. In dit geval is het wel ok omdat de kleuren uniek zijn.  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text,StyleSheet} from &quot;react-native&quot;; const colors = [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, &quot;violet&quot;]; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; {colors.map(color =&gt; ( &lt;View key={color} style={{flex:1 , backgroundColor: color}}/&gt; ))} &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, alignItems: &quot;stretch&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;   Je moet uiteraard niet altijd mappen naar views. Je kan ook mappen naar andere componenten. Hieronder een voorbeeld dat een lijst van kleuren naar Text componenten mapt.  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text,StyleSheet} from &quot;react-native&quot;; const colors = [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, &quot;violet&quot;]; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; {colors.map(color =&gt; ( &lt;Text key={color} style={{flex:1 , backgroundColor: color, textAlign:&quot;center&quot;}}&gt;{color}&lt;/Text&gt; ))} &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, alignItems: &quot;stretch&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;   Een extra voorbeeld: We kunnen een woord opsplitsen naar een array van letters en deze dan apart tonen. We gebruiken hier de split functie om een string te splitsen naar een array van letters. We gebruiken de index van het element om de fontSize te bepalen. We gebruiken een combinatie van de letter en de index als key.  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text,StyleSheet} from &quot;react-native&quot;; const App = () =&gt; { const word = &quot;Hello&quot;; return ( &lt;View style={styles.container}&gt; {word.split(&quot;&quot;).map((letter, index) =&gt; ( &lt;Text key={letter + index} style={{flex:1 , fontSize: 20 + index * 10, textAlign:&quot;center&quot;}}&gt;{letter}&lt;/Text&gt; ))} &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flex: 1, flexDirection: &quot;row&quot;, paddingTop: Constants.statusBarHeight} }); export default App;   ","version":"Next","tagName":"h2"},{"title":"ScrollView​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/react-native-course/lists-and-keys#scrollview","content":" Tot nu toe konden we alleen maar lijsten tonen die in de lengte van het scherm passen. Als we een lijst hebben die langer is dan het scherm, dan kunnen we deze niet tonen. We kunnen dit oplossen door een ScrollView te gebruiken. Een ScrollView is een component die een lijst kan tonen die langer is dan het scherm.  Als we bijvoorbeeld de elementen iets groter maken dan zie je direct het probleem:  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text,StyleSheet} from &quot;react-native&quot;; const colors = [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, &quot;violet&quot;]; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; {colors.map(color =&gt; ( &lt;View key={color} style={{height: 200, backgroundColor: color}}/&gt; ))} &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flex: 1, alignItems: &quot;stretch&quot;, paddingTop: Constants.statusBarHeight} }); export default App;   We kunnen hier eenvoudig een ScrollView rondzetten om dit probleem op te lossen:  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text, ScrollView,StyleSheet} from &quot;react-native&quot;; const colors = [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, &quot;violet&quot;]; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;ScrollView&gt; &lt;View style={{flex: 1, alignItems: &quot;stretch&quot;}}&gt; {colors.map(color =&gt; ( &lt;View key={color} style={{height: 200, backgroundColor: color}}/&gt; ))} &lt;/View&gt; &lt;/ScrollView&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {paddingTop: Constants.statusBarHeight} }); export default App;   ","version":"Next","tagName":"h2"},{"title":"FlatList​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/react-native-course/lists-and-keys#flatlist","content":" Een andere manier om een lijst te maken is door gebruik te maken van de FlatList component. Deze component heeft een aantal voordelen ten opzichte van de map functie. De FlatList component is een native component en zal dus sneller zijn dan een lijst die gemaakt wordt met de map functie. Daarnaast zal de FlatList component alleen de elementen renderen die op het scherm zichtbaar zijn. Dit is handig als je een lijst hebt met veel elementen.  FlatList is automatisch scrollable dus hoeft niet in een ScrollView gezet te worden.  De FlatList component heeft een aantal props die we moeten meegeven. De data prop is de lijst die we willen tonen. De renderItem prop is een functie die een item uit de lijst zal renderen. De keyExtractor prop is een functie die een key zal teruggeven voor een item uit de lijst.  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text, FlatList,StyleSheet} from &quot;react-native&quot;; interface Person { id: number; name: string; age: number; } const persons : Person[] = [ {id: 1, name: &quot;Andie&quot;, age: 25}, {id: 2, name: &quot;Sven&quot;, age: 24}, {id: 3, name: &quot;Dirk&quot;, age: 27}, {id: 4, name: &quot;Lotte&quot;, age: 22}, ] const PersonComponent = ({item} : {item: Person}) =&gt; { return ( &lt;View style={{flexDirection: &quot;row&quot;, alignItems: &quot;center&quot;}}&gt; &lt;Text style={{flex: 1}}&gt;{item.name}&lt;/Text&gt; &lt;Text style={{flex: 1}}&gt;{item.age}&lt;/Text&gt; &lt;/View&gt; ) } const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;FlatList data={persons} renderItem={({item}) =&gt; &lt;PersonComponent item={item}/&gt;} keyExtractor={item =&gt; item.id.toString()} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flex: 1, flexDirection: &quot;column&quot;, paddingTop: Constants.statusBarHeight} }); export default App;   We herdoen ook nog het voorbeeld van de kleuren maar dan met het FlatList component.  import React from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text, FlatList,StyleSheet} from &quot;react-native&quot;; const colors = [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, &quot;violet&quot;]; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;FlatList data={colors} renderItem={({item}) =&gt; ( &lt;View style={{height: 200, backgroundColor: item}}/&gt; )} keyExtractor={item =&gt; item} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, alignItems: &quot;stretch&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;   ","version":"Next","tagName":"h2"},{"title":"ListFooterComponent​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/react-native-course/lists-and-keys#listfootercomponent","content":" De FlatList component heeft ook een ListFooterComponent prop. Deze prop kan je gebruiken om een component te tonen onderaan de lijst. Dit kan bijvoorbeeld handig zijn om een knop te tonen om meer items te laden. Of om een loading indicator te tonen.  import React, {useState} from &quot;react&quot;; import Constants from &quot;expo-constants&quot;; import {View, Text, FlatList,StyleSheet, ActivityIndicator} from &quot;react-native&quot;; const colors = [&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, &quot;violet&quot;]; const App = () =&gt; { return ( &lt;View style={styles.container}&gt; &lt;FlatList data={colors} renderItem={({item}) =&gt; ( &lt;View style={{height: 200, backgroundColor: item}}/&gt; )} keyExtractor={item =&gt; item} ListFooterComponent={&lt;ActivityIndicator animating={true} style={{margin: 10}}/&gt;} /&gt; &lt;/View&gt; ) } const styles = StyleSheet.create({ container: {flexDirection: &quot;column&quot;, alignItems: &quot;stretch&quot;, flex: 1, paddingTop: Constants.statusBarHeight} }); export default App;  ","version":"Next","tagName":"h3"},{"title":"Labo 6","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab6","content":"","keywords":"","version":"Next"},{"title":"1. Interval​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab6#1-interval","content":" 📂 Naam project: lab-hooks-interval 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-hooks-interval.  Maak de volgende componenten aan:  Het Timer component. Dit component toont de tijd in seconden die verstreken is sinds de component is getoond.Het CurrentTime component. Dit component toont de huidige tijd in het formaat hh:mm:ss.Het RandomValue component. Dit component toont een willekeurig getal tussen min en max.Alle componenten gebruiken setInterval om de tijd te updaten. Gebruik de useEffect hook om dit te doen.  0 Current time: 8:12:20 PM Random value between 1 and 100: 0 Random value between 100 and 200: 0  ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab6#oplossingsvideo","content":"   ","version":"Next","tagName":"h3"},{"title":"2. Pokemon​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab6#2-pokemon","content":" 📂 Naam project: lab-hooks-pokemon-pokedex 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-hooks-pokemon-pokedex.  Maak een component Pokedex aan met als property limit die het aantal pokemon aangeeft dat getoond moet worden. Initieel mag je die property op 151 zetten.Maak gebruik van de https://pokeapi.co/ om deze pokemon op te halen op het moment dat de component gemounted wordt. Gebruik de useEffect hook om dit te doen.Zorg voor een loading indicator die getoond wordt tot de data geladen is.Plaats een invoer veld bovenaan de lijst van pokemon. Deze filtert de lijst van pokemon op naam. De filtering gebeurd op het moment dat de gebruiker een letter intypt.Plaats een invoerveld onderaan de lijst die aangeeft hoeveel pokemon er getoond mogen worden. Je dient deze filtering aan de hand van de limit query parameter te doen van de API. Pas vanaf de gebruiker op de button klikt, wordt de lijst van pokemon opnieuw opgehaald.  Set Limit  ","version":"Next","tagName":"h2"},{"title":"3. LocalStorage​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab6#3-localstorage","content":" 📂 Naam project: lab-hooks-local-storage 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-hooks-local-storage.  Maak een nieuw component DadJoke aan.Maak een functie loadJoke die een &quot;awkward dad joke&quot; ophaalt van de API https://icanhazdadjoke.com/. Gebruik de fetch API om de data op te halen. Plaats het resultaat in een state van het component.Zorg ervoor dat de functie wordt opgeroepen wanneer het component gemounted wordt. Gebruik de useEffect hook om dit te doen.Eenmaal de data geladen is, toon je de joke in een &lt;div&gt; element. Zorg voor een kaartje waarin de joke getoond wordt.Plaats een button New Joke onderaan de joke. Wanneer de gebruiker op deze button klikt, wordt er een nieuwe joke opgehaald.Plaats een button Set as favorite onderaan de joke. Wanneer de gebruiker op deze button klikt, wordt de huidige joke (als string) opgeslagen in de localStorage van de browser.Bij het opstarten van de applicatie, wordt de laatst opgeslagen joke getoond. Gebruik hiervoor de useEffect hook.    ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab6#oplossingsvideo-1","content":"   ","version":"Next","tagName":"h3"},{"title":"4. Game of Life (2)​","type":1,"pageTitle":"Labo 6","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab6#4-game-of-life-2","content":"","version":"Next","tagName":"h2"},{"title":"Labo 4","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4","content":"","keywords":"","version":"Next"},{"title":"1. State herkennen​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#1-state-herkennen","content":" 📂 Naam project: n/a 🔗 Basis project: n/a  Identificeer de state in de volgende componenten. Geef aan waar de state zich bevindt en wat de initiële waarde is.  Product name: Price: In stock? iPhone 12€ 699iPhone 12 Pro€ 999iPhone 12 Pro Max€ 1099Samsung Galaxy S20€ 799Samsung Galaxy S10€ 699Samsung Galaxy S20 Ultra€ 999Huawei P30€ 499Huawei P40€ 599Nokia 3310€ 399  ","version":"Next","tagName":"h2"},{"title":"2. Input veld​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#2-input-veld","content":" 📂 Naam project: lab-state-shared-inputs 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-shared-inputs.  Maak een component InputFields aan met de volgende functionaliteit:  Het component heeft 1 state inputValue die een string bevat. Deze begint bij een lege string.Zorg ervoor dat je 5 input velden op je scherm staat die allemaal de waarde van inputValue bevatten.Zorg ervoor dat als je iets typt in 1 van de input velden, de waarde van inputValue verandert en alle input velden de nieuwe waarde bevatten.  Gebruik deze component in de App component om de volgende pagina te maken:    ","version":"Next","tagName":"h2"},{"title":"3. Checkbox​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#3-checkbox","content":" 📂 Naam project: lab-state-visibility-toggle 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-visibility-toggle.  Maak een component Checkbox aan met de volgende functionaliteit:  Plaats een checkbox in je component met als label Show/HideAls de gebruiker de checkbox aanvinkt moet er een div getoond worden met een image als background.Als de gebruiker de checkbox uitzet moet de div verdwijnen.   Show/Hide  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"4. Maaltafels State​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#4-maaltafels-state","content":" 📂 Naam project: lab-state-maaltafels 🔗 Basis project: lab-components-maaltafels  Maak een kopie van de maaltafels code van labo 2 naar een nieuw project en noem deze lab-state-maaltafels. Zorg ervoor dat je de volgende functionaliteiten toevoegt:  Zorg voor een input veld waarin je het getal kan ingeven waarvan je de maaltafel wil zien.Als het veld aangepast wordt, moet de maaltafel van dat getal getoond worden.Je moet een state gebruiken om het getal max bij te houden. Dit getal bepaalt tot waar de maaltafel getoond moet worden.Je kan een maximum van 10 kiezen in het input veld en een minimum van 2.  \t1\t2\t3\t4\t5 1\t1\t2\t3\t4\t5 2\t2\t4\t6\t8\t10 3\t3\t6\t9\t12\t15 4\t4\t8\t12\t16\t20 5\t5\t10\t15\t20\t25  ","version":"Next","tagName":"h2"},{"title":"5. Penguins met state​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#5-penguins-met-state","content":" 📂 Naam project: lab-state-penguin-gallery 🔗 Basis project: lab-components-penguin-gallery  Maak een kopie van de penguins oefening van labo 2 en zorg ervoor dat je de volgende functionaliteiten toevoegt:  Maak een kopie van de lab-components-penguin-gallery applicatie van labo 2 naar een nieuw project en noem deze lab-state-penguin-gallery. En zorg voor de volgende functionaliteiten:  Als je op een penguin klikt, wordt deze geselecteerd. De achtergrondkleur van de penguin verandert.Als je nog eens op dezelfde penguin klikt, wordt deze terug gedeselecteerd.Je kan meerdere penguins selecteren.  Tip: Je hebt een state nodig in de PenguinCard component om bij te houden of de penguin geselecteerd is of niet.  Female Penguins Pip Species ID: 1 Description: A playful young penguin fond of swimming. Island: Macquarie Island Waddle Species ID: 1 Description: Leader of the rookery, very energetic. Island: Macquarie Island Pebble Species ID: 4 Description: Collects colorful pebbles, gentle disposition. Island: Antipodes Island Splash Species ID: 1 Description: Loves water sports, always active. Island: Macquarie Island Chilly Species ID: 2 Description: Enjoys sliding on ice with friends. Island: South Georgia  ","version":"Next","tagName":"h2"},{"title":"6. Omhoog/Omlaag​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#6-omhoogomlaag","content":" 📂 Naam project: lab-state-counter 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-counter.  Maak een component Counter aan met de volgende functionaliteit:  De component bevat een state met de naam count die een getal bevat. Begint bij 0.De component bevat een button met de tekst Omhoog. Als je op deze knop klikt, wordt de waarde van count met 1 verhoogd.De component bevat een button met de tekst Omlaag. Als je op deze knop klikt, wordt de waarde van count met 1 verlaagd.De component bevat de tekst Count: {count}. Hier wordt de waarde van count getoond.Zorg ervoor dat de tekst rood wordt als count kleiner is dan 0 en groen wordt als count groter is dan 0. Als het gelijk is aan 0, wordt de tekst zwart.  Gebruik deze component in de App component om de volgende pagina te maken:  Omhoog Count: 0 Omlaag Omhoog Count: 0 Omlaag Omhoog Count: 0 Omlaag  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"7. Loading indicator​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#7-loading-indicator","content":" 📂 Naam project: lab-state-loading-indicator 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-loading-indicator.  installeer de volgende npm packages:  npm install react-loader-spinner   Zorg er nu voor dat de applicatie de volgende functionaliteiten heeft:  De applicatie bevat een state met als naam loading die een boolean bevat. Deze begint bij false.De applicatie bevat een button met de tekst Start loading. Als je op deze knop klikt, wordt de waarde van loading op true gezet.Na 3 seconden wordt de waarde van loading op false gezet.Als de waarde van loading true is, wordt er een loading indicator getoond. De button verdwijnt.Als de waarde van loading false is, wordt de loading indicator niet getoond. De button verschijnt terug.  Start loading  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"8. Kleurkiezer​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#8-kleurkiezer","content":" 📂 Naam project: lab-state-color-picker 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-color-picker.  Maak een component ColorPicker aan met de volgende functionaliteit:  Het component bevat een state met als naam color die een kleur bevat. Begint bij #000000.Het component bevat een input met type color. Als je een andere kleur kiest, wordt de waarde van color aangepast.Het component bevat een div met een achtergrondkleur die gelijk is aan de waarde van color.Het component bevat ook een select met de volgende opties: #000000#FF0000#00FF00#0000FF Als je een optie kiest dan wordt ook de kleur aangepast.  Gebruik deze component in de App component om de volgende pagina te maken:  #000000#FF0000#00FF00#0000FF  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"9. Contactformulier​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#9-contactformulier","content":" 📂 Naam project: lab-state-contact-form 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-contact-form.  Maak een component ContactForm aan met de volgende functionaliteit:  Het component bevat 3 input elementen met de volgende labels: First nameLast nameEmail Het component bevat een textarea met de label Message.Het component bevat een button met de tekst Send.Als je op de knop klikt, wordt de volgende tekst getoond: Thanks {firstName} {lastName}! We will contact you at {email}.De velden worden leeggemaakt na het versturen van het formulier.Zorg dat de button disabled is als de velden niet allemaal ingevuld zijn.Je hebt hier 5 states nodig: firstName (bevat de waarde van het input element firstName)lastName (bevat de waarde van het input element lastName)email (bevat de waarde van het input element email)message (bevat de waarde van het textarea element)confirmationText (bevat de text die getoond wordt na het versturen van het formulier)  Gebruik deze component in de App component om de volgende pagina te maken:  First name:Last name:Email:Message:Send  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"10. Random Cat​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#10-random-cat","content":" 📂 Naam project: lab-state-random-cat 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-random-cat.  Maak een component RandomCat aan met de volgende functionaliteit:  Het component bevat een button met de tekst Random Cat.Als je op de knop klikt, wordt er een willekeurige locatie op je scherm bepaald.Op die locatie wordt een afbeelding van Nicolas Cage getoond.Als je terug op de knop klikt, wordt de afbeelding op een andere locatie getoond.Je mag de volgende afbeelding tonen: https://cataas.com/cat?width=200&amp;height=200  Random Cat  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"11. Joske het vierkant​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#11-joske-het-vierkant","content":" 📂 Naam project: lab-state-joske 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-joske.  Je begint met Joske... Het statische vierkant:    Joske is een rood vierkant. Maar zou ook soms graag blauw zijn! Of zelfs groen! Pas Joske aan zodat als je op hem klikt, hij van kleur verandert. De eerste keer wordt hij blauw, de tweede keer groen, de derde keer rood, de vierde keer blauw, enzovoort.Joske zou graag van naam veranderen en Josje worden. Maak een input veld waarin je de naam van Joske kan aanpassen. Tijdens het aanpassen van de naam wordt de naam van Joske aangepast.Soms wil Josje toch terug Joske zijn. Zorg ervoor dat zijn naam kan gereset worden naar Joske via een knop.Josje is heel de tijd triestig. Zorg voor een dropdown waarin je kan kiezen uit verschillende emoties. Als je een emotie kiest, dan verandert de emotie van Josje. De emoties worden uitgedrukt in smileys.Soms wil Josje helemaal geen vierkant meer zijn. Hij zou graag ook een cirkel zijn. Zorg voor een checkbox om te togglen tussen vierkant en cirkel  Josje is nu een blij cirkeltje!  joske :) Reset NameSet :):(:| Square  ","version":"Next","tagName":"h2"},{"title":"12. Simple Quiz​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#12-simple-quiz","content":" 📂 Naam project: lab-state-simple-quiz 🔗 Basis project: n/a  Maak een nieuwe React-applicatie aan en noem deze lab-state-simple-quiz.  ","version":"Next","tagName":"h2"},{"title":"Opdracht​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#opdracht","content":" Maak een component Question met props: question: stringoptions: string[]correctAnswer: stringfinished?: boolean In Question: Hou lokaal de gekozen optie bij met useState.Toon de opties als radio buttons (zelfde name, unieke id + label).Als finished = true: disable de radio’smarkeer de juiste optie met een CSS-klasse .correct. Maak een component SimpleQuiz: State finished (false bij start).Toon minstens 4 vragen via Question.Voorzie een Finish-knop die finished op true zet.  ","version":"Next","tagName":"h3"},{"title":"Data​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#data","content":" Gebruik o.a. deze vragen:  What is the answer to life, the universe and everything? (42)Which planet is known as the Red Planet? (Mars)Which programming language is known for &quot;write once, run anywhere&quot;? (Java)Which animal is the largest mammal on Earth? (Blue Whale)  ","version":"Next","tagName":"h3"},{"title":"CSS​","type":1,"pageTitle":"Labo 4","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab4#css","content":" Maak een SimpleQuiz.module.css.Voorzie een klasse .correct die het juiste antwoord markeert.  Simple Quiz What is the answer to life, the universe and everything? 42 The answer God What is the answer to life, the universe and everything? Mars Venus Jupiter What is the answer to life, the universe and everything? Java Python C++ What is the answer to life, the universe and everything? Blue Whale Elephant Giraffe Finish ","version":"Next","tagName":"h3"},{"title":"Labo 8","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8","content":"","keywords":"","version":"Next"},{"title":"1. Wake up Neo​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#1-wake-up-neo","content":" 📂 Naam project: lab-context-wake-up-neo 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-context-wake-up-neo.  Begin van de volgende code:  import { useState } from 'react' interface LineProps { text: string } const FourthLine = ({text}: LineProps) =&gt; &lt;&gt;&lt;p&gt;{text}&lt;/p&gt;&lt;/&gt;; const ThirdLine = ({text}: LineProps) =&gt; &lt;&gt;&lt;p&gt;Follow the white rabbit.&lt;/p&gt;&lt;FourthLine text={text}/&gt;&lt;/&gt;; const SecondLine = ({text}: LineProps) =&gt; &lt;&gt;&lt;p&gt;The matrix has you...&lt;/p&gt;&lt;ThirdLine text={text}/&gt;&lt;/&gt;; const FirstLine = ({text}: LineProps) =&gt; &lt;&gt;&lt;p&gt;Wake Up, Neo...&lt;/p&gt;&lt;SecondLine text={text}/&gt;&lt;/&gt; const App = () =&gt; { const [text, setText] = useState(&quot;Knock, Knock, Neo&quot;); return ( &lt;&gt; &lt;input type=&quot;text&quot; value={text} onChange={(e) =&gt; setText(e.target.value)}/&gt; &lt;div style={{backgroundColor: &quot;black&quot;, color: &quot;#4AF626&quot;, display: &quot;flex&quot;, flexDirection: &quot;column&quot;, padding: 20}}&gt; &lt;FirstLine text={text}/&gt; &lt;/div&gt; &lt;/&gt; ) } export default App   Pas deze helemaal aan zodat je gebruik maakt van Context.  ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#oplossingsvideo","content":"   ","version":"Next","tagName":"h3"},{"title":"2. Basic context​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#2-basic-context","content":" 📂 Naam project: lab-context-settings 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-context-settings.  Creëer een context genaamd SettingsContext. De context moet twee waarden bijhouden: color en setColor. color is een string die een kleur waarde heeft en setColor is een functie die color kan aanpassen. De startwaarde van color moet 'red' zijn. Maak een component genaamd Square. Dit component moet de color waarde uit de SettingsContext uitlezen en deze waarde gebruiken om de achtergrondkleur van een vierkant blok te bepalen. Het blok moet een breedte en hoogte hebben van 100 pixels met 10 pixels marge. Creëer een component SquareRow. Dit component moet drie Square componenten naast elkaar tonen. Maak een component genaamd SelectionBox. Dit component moet een selectie box bevatten met de opties 'red', 'blue' en 'green'. De huidige geselecteerde waarde moet de color zijn uit de SettingsContext. Als de gebruiker een andere kleur selecteert, moet de setColor functie van de SettingsContext gebruikt worden om de kleur aan te passen. Ook moet je het App component aanmaken. In dit component, maakt het gebruik van de useState hook om de huidige kleur en de setColor functie te bepalen. Dit moet vervolgens in de SettingsContext meegegeven worden. Het App component moet daarna het SelectionBox en SquareRow component weergeven, beide omringd door de SettingsContext.Provider. Zorg er nu voor dat je ook op de Square component kan drukken om de kleur te veranderen.  redbluegreen   ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#oplossingsvideo-1","content":"   ","version":"Next","tagName":"h3"},{"title":"3. Todo App​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#3-todo-app","content":" 📂 Naam project: lab-context-todo-app 🔗 Basis project: lab-communication-todo-app  Maak een kopie van de Todo app van het vorige labo (lab-communication-todo-app) naar een nieuw project en noem deze lab-context-todo-app. En zorg voor de volgende uitbreidingen.  Uitbreidingen:  Zorg ervoor dat je de todo's uit een API kan ophalen. Je kan hiervoor gebruik maken van de JSONPlaceholder API. Deze bevat een endpoint /todos die je kan gebruiken om todo's op te halen.Plaats de Todo's en de code om ze in te lezen in een TodoContext zodat je deze kan gebruiken in de verschillende componenten.  ","version":"Next","tagName":"h2"},{"title":"4. Quiz App​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#4-quiz-app","content":" 📂 Naam project: lab-context-quiz-app 🔗 Basis project: lab-communication-quiz-app  Maak een kopie van de Quiz app van het vorige labo (lab-communication-quiz-app) naar een nieuw project. Noem deze lab-context-quiz-app. We gaan hier nog wat uitbreidingen op maken.  Uitbreidingen:  Herwerk de Quiz applicatie zodat deze gebruik maakt van een QuizContext. De functionaliteit van de applicatie blijft voor de rest volledig hetzelfde.Voorzie een button bovenaan de pagina om te togglen tussen dark en light mode. Zorg ervoor dat alle componenten in de applicatie aanpassen aan de gekozen mode.  ","version":"Next","tagName":"h2"},{"title":"5. Pokemon app​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#5-pokemon-app","content":" 📂 Naam project: n/a 🔗 Basis project: n/a  HomePokemon Hello there! Welcome to the world of POKEMON! My name is OAK! People call me the POKEMON PROF! This world is inhabited by creatures called POKEMON! For some people, POKEMON are pets. Others use them for fights. Myself...I study POKEMON as a profession.  ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#oplossingsvideo-2","content":"     ","version":"Next","tagName":"h3"},{"title":"6. Portfolio app​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#6-portfolio-app","content":" 📂 Naam project: lab-router-portfolio 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-router-portfolio.  Kies 3 verschillende oefeningen die je hebt gemaakt tijdens de voorgaande labos. Zorg ervoor dat deze oefeningen beschikbaar zijn onder de volgende routes: /oefening1, /oefening2 en /oefening3. Zorg voor een navigatiebalk die je toelaat om tussen de verschillende oefeningen te navigeren.  ","version":"Next","tagName":"h2"},{"title":"7. Quiz app met React Router​","type":1,"pageTitle":"Labo 8","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab8#7-quiz-app-met-react-router","content":" 📂 Naam project: n/a 🔗 Basis project: lab-context-quiz-app  We gaan verder met de Quiz app uit de vorige oefening. Maak hier een kopie van zodat je de originele code nog hebt. Want we gaan hier nog wat uitbreidingen op maken.  Uitbreidingen:  Maak gebruik van React Router om de moeilijkheidsniveau te kiezen: / toont de moeilijkheidsniveau's (easy, medium, hard)/quiz/:difficulty toont de quiz met de gekozen moeilijkheidsniveau Zorg voor een simpele navigatiebalk waar je kan kiezen tussen de verschillende moeilijkheidsniveau's.Als je voor een nieuw moeilijkheidsniveau kiest, moet de quiz opnieuw beginnen.   ","version":"Next","tagName":"h2"},{"title":"Labo 7","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab7","content":"","keywords":"","version":"Next"},{"title":"1. Counter List​","type":1,"pageTitle":"Labo 7","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab7#1-counter-list","content":" 📂 Naam project: lab-communication-counter-list 🔗 Basis project: n/a  We beginnen in deze oefening van de volgende code. Kopieer deze in een nieuw project en noem deze lab-communication-counter-list.  const CounterList = () =&gt; { const [counters, setCounters] = useState&lt;number[]&gt;([]); const addCounter = () =&gt; { setCounters([...counters, 0]); } const increaseCounter = (index: number) =&gt; { setCounters(counterCpy =&gt; counterCpy.map((counter, i) =&gt; (i === index) ? counter + 1 : counter)); } const decreaseCounter = (index: number) =&gt; { setCounters(counterCpy =&gt; counterCpy.map((counter, i) =&gt; (i === index) ? counter - 1 : counter)); } return ( &lt;&gt; {counters.map((counter, index) =&gt; { let color = &quot;black&quot;; if (counter &gt; 0) { color = &quot;green&quot;; } else if (counter &lt; 0) { color = &quot;red&quot;; } return ( &lt;div style={{ display: &quot;flex&quot;, flexDirection: &quot;row&quot;, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; }}&gt; &lt;button onClick={() =&gt; decreaseCounter(index)}&gt;Omlaag&lt;/button&gt; &lt;div style={{ flex: 1, display: &quot;flex&quot;, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, color: color }}&gt;Count: {counter}&lt;/div&gt; &lt;button onClick={() =&gt; increaseCounter(index)}&gt;Omhoog&lt;/button&gt; &lt;/div&gt; ) })} &lt;p&gt;Som van de tellers: {counters.reduce((prev, curr) =&gt; prev + curr, 0)}&lt;/p&gt; &lt;button onClick={addCounter}&gt;Voeg teller toe&lt;/button&gt; &lt;/&gt; ) }   Dit is een implementatie van de CounterList component dat je in een voorgaande oefening hebt gemaakt. Hier was het nog niet de bedoeling om een aparte component te maken voor de Counter component. We gaan dit nu wel doen.  Maak een nieuwe component Counter aan. Deze component bevat een teller die je kan verhogen en verlagen. De Counter component bevat de volgende properties:  value: de waarde van de telleronIncrease: een callback functie die opgeroepen wordt als de teller verhoogd wordtonDecrease: een callback functie die opgeroepen wordt als de teller verlaagd wordtindex: de index van de teller in de lijst van tellers  Zorg er nu voor dat de CounterList component de Counter component gebruikt. De CounterList component bevat nog steeds de state van de tellers. De Counter component bevat geen state. De Counter component gebruikt de properties om de teller te tonen en de callbacks op te roepen.  Som van de tellers: 0 Voeg teller toe  ","version":"Next","tagName":"h2"},{"title":"2. Todo App​","type":1,"pageTitle":"Labo 7","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab7#2-todo-app","content":" 📂 Naam project: lab-communication-todo-app 🔗 Basis project: n/a  We beginnen van een voorgemaakte Todo app. Deze app bevat een lijst van taken die je kan toevoegen en verwijderen. De app bevat ook een input veld waar je een nieuwe taak kan toevoegen. Kopieer deze code in een nieuw project en noem deze lab-communication-todo-app.  import React, {useState} from &quot;react&quot;; interface TodoItem { name: string; completed: boolean; } const App = () =&gt; { const [todos, setTodos] = useState&lt;TodoItem[]&gt;([]); const [todo, setTodo] = useState(&quot;&quot;); const addTodo = (todo: string) =&gt; { setTodos([...todos, { name: todo, completed: false }]); setTodo(&quot;&quot;); }; const markCompleted = (index: number, completed: boolean) =&gt; { setTodos(todos.map((todo, i) =&gt; i === index ? {...todo, completed: completed} : todo)); }; return ( &lt;div&gt; &lt;div&gt; &lt;input id=&quot;todo&quot; type=&quot;text&quot; value={todo} onChange={(event) =&gt; setTodo(event.target.value)}/&gt; &lt;button onClick={() =&gt; addTodo(todo)}&gt;Add&lt;/button&gt; &lt;/div&gt; &lt;div&gt; {todos.map((todo, index) =&gt; ( &lt;div key={index}&gt; &lt;input type=&quot;checkbox&quot; checked={todo.completed} onChange={(event) =&gt; markCompleted(index, event.target.checked)}/&gt; &lt;span style={{textDecoration: todo.completed ? &quot;line-through&quot; : &quot;none&quot;}}&gt;{todo.name}&lt;/span&gt; &lt;/div&gt; ))} &lt;/div&gt; &lt;/div&gt; ); } export default App;   Herstructureer deze applicatie als volgt:  Maak drie nieuwe componenten aan in een aparte map components: TodoList bevat de lijst van takenTodoItem bevat een enkele taakTodoInput bevat het input veld en de knop om een taak toe te voegen Verplaats de logica van de App component naar de nieuwe componentenDe state die de Todo's bevat moet in de App component blijven.Je zal dus moeten gebruik maken van props om de state door te geven aan de nieuwe componenten. Je zal ook gebruik moeten maken van child-to-parent communicatie om de state te kunnen updaten.Zorg dat elk component in een aparte file staat.  Add  ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 7","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab7#oplossingsvideo","content":"   ","version":"Next","tagName":"h3"},{"title":"3. Quizapp​","type":1,"pageTitle":"Labo 7","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab7#3-quizapp","content":" 📂 Naam project: lab-communication-quiz-app 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-communication-quiz-app.  Maak een nieuw component QuizApp aan.Maak gebruik van de https://opentdb.com/api.php?amount=10 om de quizvragen op te halen. Gebruik de fetch API om de data op te halen. Gebruik een useEffect om deze data op te halen en daarna in een state te plaatsen.Er zijn twee soorten vragen: multiple choice en true/false. Maak een component MultipleChoiceQuestion en een component TrueFalseQuestion aan. Deze componenten worden gebruikt om de vragen te tonen. Maak een component Question aan die de juiste vraag component toont op basis van het type vraag.Als de gebruiker op een antwoord klikt wordt er aan de hand van een kleur aangegeven of het antwoord juist of fout is. Daarna wordt het antwoord getoond en kan de gebruiker niet meer van antwoord veranderen.Onderaan staat een button met de tekst 'Load More' die de volgende 10 vragen laadt. De vragen worden opnieuw opgehaald van de API. De vragen die al getoond of beantwoord zijn blijven in de lijst staan.Voorzie een loading indicator die getoond wordt tot de data geladen is (ook bij het laden van de volgende 10 vragen).Alle state moet in de QuizApp component zitten. De Question componenten mogen geen state hebben. De Question componenten moeten de state van de QuizApp componenten gebruiken via props en callbacks.Maak gebruik van de html-entities package om de html entities te decoderen. Deze worden meegeleverd in de API. Anders krijg je bijvoorbeeld &amp;quot; te zien in plaats van &quot;.  Load More  ","version":"Next","tagName":"h2"},{"title":"Oplossingsvideo​","type":1,"pageTitle":"Labo 7","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab7#oplossingsvideo-1","content":"   ","version":"Next","tagName":"h3"},{"title":"4. Happy Workers​","type":1,"pageTitle":"Labo 7","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab7#4-happy-workers","content":" 📂 Naam project: lab-communication-happy-workers 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-communication-happy-workers.  Plaats in de App component een progressbar (van 0 tot 100) en maak een component genaamd Square. Het Square component aanvaard initieel gewoon een color en een size prop. Later gaan hier nog props bij komen. Zorg ervoor dat je een aantal Square componenten toevoegd aan de App component met verschillende kleuren.  Maak een state work aan in de App component die initieel op 0 staat en de waarde voorstelt die de progressbar moet tonen.  Zorg ervoor dat als je op een Square klikt, de work state met 1 verhoogd wordt. Dit zorgt ervoor dat de progressbar met 1% verhoogd wordt.  Als de work state kleiner is dan 100 dan moet de Square component een 😐 tonen. Als de work state 100 is dan moet de Square component een 😃 tonen. Let er op: het tonen van de smileys vereist geen nieuwe state. Je kan dit afleiden van de work state.  0% 😐 😐 😐  Uitbreiding:  Maak een state genaamd productivity aan in de Square component die initieel op 1 staat. De productivity state stelt voor hoeveel procent de work state verhoogd wordt als je op de Square klikt.Dus als de productivity 1 is wordt bij elke klik de work state met 1 verhoogd. Als de productivity 2 is wordt bij elke klik de work state met 2 verhoogd.Maak een state genaamd clicked aan in de Square component die initieel op 0 staat.Als de clicked state groter of gelijk is aan 10 dan moet de productivity state op 0 gezet worden. Dit zorgt ervoor dat de Square component een 😵 toont. Het is dan tijdelijk niet meer mogelijk de work state te verhogen met die Square.Na 5 seconden moet de productivity state terug op 1 gezet worden. Dit zorgt ervoor dat de Square component terug een 😐 toont. Ook de clicked state wordt terug op 0 gezet.  0% 😐 😐 😐 ","version":"Next","tagName":"h2"},{"title":"Next.js","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/nextjs","content":"","keywords":"","version":"Next"},{"title":"Waarom een framework?​","type":1,"pageTitle":"Next.js","url":"/webframeworks-cursus/wf-course/nextjs#waarom-een-framework","content":" Tot nu toe hebben we gebruik gemaakt van vite of een andere tool om een React applicatie te maken. Deze tools maken een zo minimaal mogelijke applicatie aan die gebruik maakt van React.js. Dit is ideaal voor kleine projecten, maar als je een groter project wil maken, dan heb je meer nodig. Je hebt bijvoorbeeld een router nodig, een manier om data op te halen van een server, een manier om je applicatie te deployen, ...  Deze dingen kan je uiteraard allemaal zelf gaan doen in react.js. Je kan bijvoorbeeld zelf een routing systeem in elkaar steken of gebruik maken van een van de vele verschillende libraries die aanwezig zijn op npm. Maar dit is niet altijd even eenvoudig. Je moet zelf gaan uitzoeken welke libraries goed samenwerken, je moet zelf gaan uitzoeken hoe je deze libraries moet gebruiken, je moet zelf gaan uitzoeken hoe je deze libraries moet configureren, ... . Daarom bestaan er React frameworks. Deze frameworks zijn een verzameling van libraries die goed samenwerken en die je kan gebruiken om een volledige applicatie te maken. De meeste frameworks bieden ook een manier om delen van je applicatie op de server te renderen. Dit zorgt ervoor dat je applicatie sneller zal laden en dat je applicatie beter zal scoren op SEO vlak. Meer hier over later in de cursus.  De officiele React documentatie verwijst naar 3 frameworks: Next.js, Gatsby.js en Remix. In deze cursus gaan we gebruik maken van Next.js. Dit is een framework dat heel populair is en dat heel veel functionaliteit aanbiedt.  ","version":"Next","tagName":"h2"},{"title":"Nieuw project aanmaken​","type":1,"pageTitle":"Next.js","url":"/webframeworks-cursus/wf-course/nextjs#nieuw-project-aanmaken","content":" Om een project aan te maken met Next.js moeten we het volgende commando uitvoeren:  npx create-next-app@latest   Je zal hier dan een aantal vragen krijgen over de configuratie van je project.  ✔ What is your project named? › my-app ✔ Would you like to use TypeScript? … Yes ✔ Which linter would you like to use? › ESLint ✔ Would you like to use Tailwind CSS? … Yes ✔ Would you like your code inside a `src/` directory? … Yes ✔ Would you like to use App Router? (recommended) … Yes ✔ Would you like to use Turbopack? (recommended) … Yes ✔ Would you like to customize the import alias (`@/*` by default)? … No   Let goed op dat je gebruik maakt van TypeScript en dat je de App Router router gebruikt. Next.js heeft twee verschillende routing systemen en als je de laatste nieuwe features van React 19 zoals server components wil gebruiken dan moet je deze router gebruiken.  Je kan vervolgens het project voor de eerste keer opstarten met het volgende commando:  npm run dev   Dit start de development server op en opent de applicatie in je browser. Je kan nu beginnen met het aanpassen van de applicatie. Pas bijvoorbeeld de tekst aan in src/app/page.tsx en bekijk het resultaat in je browser. Je kan eventueel een van de voorgaande oefeningen opnieuw maken in Next.js. Je gaat zien dat dit heel gelijkaardig is aan het maken van een React applicatie met vite.  Opgelet je moet wel aangeven dat een component een client component is door bovenaan het bestand use client te zetten. Dit is nodig omdat Next.js standaard server components gebruikt en anders kan bijvoorbeeld geen state of effects gebruiken in je componenten.  &quot;use client&quot; import styles from &quot;./page.module.css&quot;; import { useState } from &quot;react&quot;; export default function Home() { const [counter, setCounter] = useState(0); return ( &lt;div&gt; &lt;button onClick={() =&gt; setCounter(counter =&gt; counter + 1)}&gt;{counter}&lt;/button&gt; &lt;/div&gt; ); }   ","version":"Next","tagName":"h2"},{"title":"Tailwind CSS​","type":1,"pageTitle":"Next.js","url":"/webframeworks-cursus/wf-course/nextjs#tailwind-css","content":" Tailwind CSS is een utility-first CSS framework dat het makkelijk maakt om snel mooie en responsieve user interfaces te maken. Tailwind CSS is gebaseerd op het idee van utility classes. Dit zijn kleine CSS classes die een specifieke stijl toepassen op een element. In plaats van zelf CSS te schrijven, kan je deze utility classes gebruiken om je elementen te stylen. By default is Tailwind CSS al geconfigureerd in je Next.js project als je deze optie hebt aangevinkt bij het aanmaken van het project. Je bent vrij dit te gebruiken of niet.  Je kan bijvoorbeeld een button maken met de volgende code:  &lt;button className=&quot;bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded&quot;&gt; Click me &lt;/button&gt;   Deze code maakt een button met een blauwe achtergrond, witte tekst, een bold font, padding en afgeronde hoeken. Als je met de muis over de button gaat, dan verandert de achtergrondkleur naar een donkerdere blauwe kleur. ","version":"Next","tagName":"h2"},{"title":"Labo 5","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5","content":"","keywords":"","version":"Next"},{"title":"1. Shopping List​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#1-shopping-list","content":" 📂 Naam project: lab-state-shopping-list 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-shopping-list.  Maak een component ShoppingList aan met de volgende functionaliteit:  Het component heeft een state property shoppingList die een array bevat. Deze begint bij een lege array.Zorg ervoor dat je een lijst van items kan toevoegen aan de shopping list.Als een element toegevoeg wordt, moet de gebruiker een bevestiging zien dat het item toegevoegd is. Als de gebruiker foutieve hoeveelheid of geen naam ingeeft, moet er een foutmelding getoond worden.Zorg ervoor dat je een lijst van items kan verwijderen van de shopping list.Als een item verwijderd wordt, moet de gebruiker een bevestiging krijgen dat het item verwijderd wordt.  Gebruik dit component in de App component om de volgende pagina te maken:  Name:Quantity: Name\tQuantity\t  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"2. Kleuren Selectie​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#2-kleuren-selectie","content":" 📂 Naam project: lab-state-color-select 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-color-select.  Maak een component ColorSelect aan met de volgende functionaliteit:  Het component bevat een select met de volgende kleuren: red, green, blue, yellow, orange, purple, black, white. Er kunnen meerdere kleuren geselecteerd worden.Het component bevat een state property selectedColors die een array bevat met de geselecteerde kleuren.Het component bevat een button met de tekst &quot;Show colors&quot;. Als de gebruiker op deze button klikt moet de gebruiker een lijst zien met de geselecteerde kleuren.Als je op een kleur klikt in de lijst, krijgt de gebruiker een prompt met de vraag om een nieuwe kleur te kiezen. Als de gebruiker op &quot;OK&quot; klikt, moet de kleur in de lijst vervangen worden door de nieuwe kleur.  tip Je moet hier twee states gebruiken: selectedColors en colors. De eerste state bevat de geselecteerde kleuren, de tweede state bevat de kleuren die moeten getoond worden. De tweede state wordt aangepast als de gebruiker op de button klikt. Het is een kopie van de eerste state op de moment dat de gebruiker op de button klikt.  Gebruik dit component in de App component om de volgende pagina te maken:  RedBlackGreenBlueYellowOrangeShow Colors  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"3. Filtering en sorting​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#3-filtering-en-sorting","content":" 📂 Naam project: lab-state-filtering 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-filtering.  Maak een component Filtering aan met de volgende functionaliteit:  Maak een lijst van studenten met de volgende properties: name, age, year.Zorg voor een search input waar de gebruiker kan zoeken op naam.Als de gebruiker in de search input typt, moet de lijst gefilterd worden op de naam van de student.Als je op de header van de tabel klikt, moet de lijst gesorteerd worden op de property waarop je geklikt hebt.Je hebt hier twee states nodig: sortField en searchText. De eerste state bevat de property waarop gesorteerd moet worden, de tweede state bevat de tekst die gebruikt wordt om te filteren.  Search: Name\tAge\tYearJacob\t21\t2 Jan\t20\t1 Joris\t22\t3 Joris\t22\t3 Korneel\t23\t4 Mathias\t22\t3 Muhammad\t20\t1 Perneel\t22\t3 Piet\t21\t2  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"4. Slots​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#4-slots","content":" 📂 Naam project: lab-state-slot-machine 🔗 Basis project: lab-components-slot-machine  Je breidt nu de slots machine uit die je gemaakt hebt in labo 2 uit met een aantal nieuwe functionaliteiten.  Zorg voor een state slots die de array met slots bevat. Zorg ervoor dat deze initieel met random waarden gevuld is.Zorg voor een state money dat het geld van de speler bijhoudt. Zorg ervoor dat deze initieel op 100 staat.Zorg voor een button Pull lever die een functie aanroept die de slots state verandert naar een nieuwe array met random waarden. Als de speler gewonnen heeft (3 dezelfde symbolen), dan wordt de money state verhoogd met 20. Als de speler verloren heeft (3 verschillende symbolen), dan wordt de money state verlaagd met 1.Toon bovenaan het saldo van de speler.Als het saldo van de speler 0 is, dan wordt de button Pull lever disabled en wordt er een tekst getoond die zegt dat de speler geen geld meer heeft.  Het spel ziet er nu als volgt uit:  Saldo: €100 Pull Lever  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"5. Counter list​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#5-counter-list","content":" 📂 Naam project: lab-state-counter-list 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-counter-list.  Maak een component ButtonList aan met de volgende functionaliteit:  Het component bevat 1 state genaamd counters. Deze state bevat een array van getallen. Deze array begint bij een lege array.Het component bevat een button met de tekst &quot;Add counter&quot;. Als de gebruiker op deze button klikt, moet er een nieuw getal aan de array toegevoegd worden. Het getal moet 0 zijn.Bij elke counter moet er een button getoond worden met de tekst &quot;Increment&quot; of &quot;Decrement&quot;. Als de gebruiker op deze button klikt, moet het getal van de overeenkomstige counter verhoogd of verlaagd worden.Onderaan staat de som van alle waarden van de counters.  Som van de tellers: 0 Voeg teller toe  notitie Je hoeft nog niet elke counter in een apart component te zetten. Je gaat dit later nog doen.  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"6. Tic Tac Toe​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#6-tic-tac-toe","content":" 📂 Naam project: lab-state-tic-tac-toe 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-tic-tac-toe.  Maak een component TicTacToe aan met de volgende functionaliteit:  Het component bevat een state met de naam board die een array bevat met 9 elementen. Elk element is een string met de waarde ''.Het component bevat een state met de naam player die de waarde X of O bevat. Dit is de speler die aan de beurt is. De speler begint bij X.Gebruik de map functie om een array van 9 div elementen te maken. Elk div element heeft een onClick event handler die een functie aanroept die de board state verandert. De functie krijgt als parameter de index van het div element dat geklikt is.Als je op een div element klikt, wordt de waarde van het div element veranderd naar het symbool van de speler die aan de beurt is.  Het spel ziet er nu als volgt uit:    ","version":"Next","tagName":"h2"},{"title":"7. Alien Alphabet​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#7-alien-alphabet","content":" 📂 Naam project: lab-state-alien-alphabet 🔗 Basis project: n/a  Maak een nieuwe React applicatie aan en noem deze lab-state-alien-alphabet.  Maak een array aan die de inhoud van de volgende json bevat. Je mag deze gewoon copy pasten: https://raw.githubusercontent.com/slimmii/alien-alphabet/master/alien.json . Zorg wel dat je de interface juist hebt.Zorg ervoor dat alle images van de letters getoond worden. Je kan dit in een button zetten.Als je op een alien letter klikt moet deze toegevoegt worden aan een array. Je moet het volledige object toevoegen, niet enkel de letter.Toon de letters die je gekozen hebt in een lijst.Voeg een backspace button toe die het laatste element van de array verwijdert.Voeg een clear button toe die de array leeg maakt.  ⌫🗑  ","version":"Next","tagName":"h2"},{"title":"8. Game of Life (1)​","type":1,"pageTitle":"Labo 5","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab5#8-game-of-life-1","content":" 📂 Naam project: lab-state-game-of-life 🔗 Basis project: n/a  In deze opdracht wordt van je verwacht om een React-component te implementeren voor een eenvoudig spelbord van het Game of Life spel. We gaan dit spelbord later gebruiken om een volledige implementatie van het spel te maken.  Maak een React-component genaamd LifeGameBoard.Implementeer een functie initializeGrid(rows, columns) die een tweedimensionale array genereert met rows rijen en columns kolommen, waarbij elke cel een willekeurige waarde heeft van 0 of 1 om de levende en dode cellen te vertegenwoordigen.Voeg twee invoervelden toe voor het aantal rijen en kolommen, en een knop om het bord te vernieuwen.Implementeer een methode setBoard die wordt aangeroepen wanneer de knop wordt ingedrukt om het bord te vernieuwen. Deze methode moet het spelbord opnieuw initialiseren met het opgegeven aantal rijen en kolommen.Implementeer een methode flipElement(x, y) die wordt aangeroepen wanneer een cel op het bord wordt geklikt. Deze methode moet de staat van de cel omkeren (van 0 naar 1 of van 1 naar 0) en de nieuwe staat van het bord weergeven.Zorg ervoor dat het bord wordt weergegeven als een grid, waarbij elke cel wordt weergegeven als een div-element met een achtergrondkleur die overeenkomt met de staat van de cel (0 voor dode cellen, 1 voor levende cellen).Laat de gebruiker de gewenste grootte van het bord opgeven door de waarden in de invoervelden te wijzigen.Zorg ervoor dat de staat van het bord correct wordt bijgewerkt wanneer cellen worden omgedraaid of wanneer het bord wordt vernieuwd.    Refresh board  ","version":"Next","tagName":"h2"},{"title":"Fonts en Image Optimization","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/nextjs/font-image-optimization","content":"","keywords":"","version":"Next"},{"title":"Fonts​","type":1,"pageTitle":"Fonts en Image Optimization","url":"/webframeworks-cursus/wf-course/nextjs/font-image-optimization#fonts","content":" Een veelvoorkomend probleem bij font loading is dat de browser eerst de pagina toont met een fallback-font en daarna pas het custom font laadt. Dit veroorzaakt Cumulative Layout Shift (CLS): tekst springt van vorm en grootte, waardoor de layout verschuift.  Next.js lost dit op met next/font, dat fonts tijdens de build optimaliseert en lokaal host. Zo laden ze sneller en voorkom je layout shifts.  Je kan bijvoorbeeld een Google Font gebruiken door deze te importeren in je layout.tsx bestand:  import { Roboto } from &quot;next/font/google&quot;; export const roboto = Roboto({ weight: [&quot;400&quot;, &quot;700&quot;], subsets: [&quot;latin&quot;], variable: &quot;--font-roboto&quot;, });   Je kan vervolgens deze font toevoegen aan je body element in het layout.tsx bestand:  &lt;body className={`${roboto.variable} font-sans`}&gt;   Dit moet uiteraard niet altijd op de body toegepast worden. Je kan dit ook op specifieke componenten toepassen door de class toe te voegen aan het element waar je de font wil gebruiken.  ","version":"Next","tagName":"h2"},{"title":"Image​","type":1,"pageTitle":"Fonts en Image Optimization","url":"/webframeworks-cursus/wf-course/nextjs/font-image-optimization#image","content":" Next.js kan statische assets, zoals afbeeldingen, serveren vanuit de top-level /public map. Bestanden in /public kunnen in je applicatie worden gebruikt. In gewone HTML zou je een afbeelding als volgt toevoegen:  &lt;img src=&quot;/hero.png&quot; alt=&quot;Screenshots of the dashboard project showing desktop version&quot; /&gt;   Maar dit betekent dat je handmatig moet:  Zorgen dat je afbeelding responsief is op verschillende schermformaten.Afbeeldingsformaten specificeren voor verschillende apparaten.Layout shifts voorkomen terwijl de afbeeldingen laden.Afbeeldingen lazy loaden die buiten het zicht van de gebruiker zijn.  Dit is allemaal heel veel werk en vrij complex, maar gelukkig heeft Next.js hier een oplossing voor met het next/image component dat automatisch je afbeeldingen optimaliseert.  Hiervoor moet je eerst het Image component importeren uit next/image:  import Image from &quot;next/image&quot;; export default function Home() { return ( &lt;div&gt; &lt;Image src=&quot;/hero.png&quot; alt=&quot;Screenshots of the dashboard project showing desktop version&quot; width={700} height={400} priority /&gt; &lt;/div&gt; ); }   Je moet hier wel de width en height specificeren van de afbeelding. Dit is nodig om layout shifts te voorkomen. Je moet hier wel de juiste verhouding van de afbeelding gebruiken. Het next/image component zorgt er dan voor dat de afbeelding op de juiste manier geschaald wordt.  Je kan ook kiezen voor de afbeelding te importeren en dan de width en height automatisch te laten bepalen:  import Image from &quot;next/image&quot;; import heroImage from &quot;./hero.png&quot;; export default function Home() { return ( &lt;div&gt; &lt;Image src={heroImage} alt=&quot;Screenshots of the dashboard project showing desktop version&quot; priority /&gt; &lt;/div&gt; ); }   Als je een afbeelding wil gebruiken die van een externe bron kom dan moet je altijd de width en height specificeren.   &lt;Image src=&quot;https://picsum.photos/300/200&quot; width={300} height={200} className=&quot;block&quot; alt=&quot;Screenshot of the dashboard project showing mobile version&quot; /&gt;   Geeft een fout omdat Next.js niet weet of deze externe bron betrouwbaar is. Je moet deze domeinen expliciet toevoegen aan de next.config.js bestand:  import type { NextConfig } from 'next'; const nextConfig: NextConfig = { images: { remotePatterns: [ { protocol: 'https', hostname: 'picsum.photos', port: '', pathname: '/**', search: '', }, ], }, }; export default nextConfig;  ","version":"Next","tagName":"h2"},{"title":"Labo 1","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1","content":"","keywords":"","version":"Next"},{"title":"1. Expressies​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#1-expressies","content":" 📂 Naam project: lab-basics-expressies 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan met de naam lab-basics-expressies en maak het volgende App.tsx component aan:  const App = () =&gt; { return ( &lt;div&gt; &lt;h1&gt;Labo 1&lt;/h1&gt; &lt;/div&gt; ); } export default App;   Opdracht​  Maak een variabele met de naam random en geef deze de waarde van Math.random(). Toon deze waarde in de browser.Maak een variabele met de naam getal1 en geef deze een willekeurige waarde tussen 0 en 9 (gebruik bijvoorbeeld Math.floor(Math.random() * 10)). Toon deze waarde in de browser.Maak een variabele met de naam getal2 en geef ook deze een willekeurige waarde tussen 0 en 9. Toon deze waarde in de browser.Maak twee functies: add(a, b) die twee getallen optelt en het resultaat teruggeeft.multiply(a, b) die twee getallen vermenigvuldigt en het resultaat teruggeeft. Gebruik een fragment (&lt;&gt;...&lt;/&gt;) in plaats van &lt;div&gt; om je elementen te groeperen.Gebruik conditionele rendering om het resultaat te tonen: Als random kleiner is dan 0.5, toon je de som van de twee getallen met behulp van add().Als random groter is dan of gelijk aan 0.5, toon je de vermenigvuldiging van de twee getallen met behulp van multiply().Gebruik hier de twee getallen getal1 en getal2 voor.  Voorbeeldoplossing​  Labo 1: Expressies Random: 0.018612075542841833 Getal 1: 4 Getal 2: 4 4 + 4: 8  Video​    ","version":"Next","tagName":"h2"},{"title":"2. Slotmachine​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#2-slotmachine","content":" 📂 Naam project: lab-basics-slot-machine 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan lab-basics-slot-machine.  Opdracht​  Toon alle mogelijke afbeeldingen van de slotmachine in de browser. Je kan de afbeeldingen hier onderaan gewoon downloaden vanuit het voorbeeld.Maak 3 variabelen met de namen slot1, slot2 en slot3 aan. Zorg ervoor dat deze variabele een willekeurige waarde krijgt tussen 0 en 4 (met 4 inbregrepen)Toon de tekst &quot;Je hebt gewonnen&quot; als slot1,slot2 en slot3 dezelfde waarde heeft. Toon de tekst &quot;Je hebt verloren&quot; als slot1,slot2 en slot3 een andere waarde hebben.Zorg ervoor dat er 3 afbeeldingen worden getoond afhankelijk van de waarde van slot1, slot2 en slot3. Als de slot 0 is toon je een kersAls de slot 1 is toon je een citroen... Probeer de afbeeldingen te tonen met behulp van import en een url uit de public folder.Er hoeft geen refresh knop te zijn. Elke keer dat je de pagina refresh zie je een nieuwe combinatie.  Voorbeeldoplossing​  Labo 1: Slots Je hebt verloren  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"3. Lijsten​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#3-lijsten","content":" 📂 Naam project: lab-basics-lists 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan lab-basics-lists.  Opdracht​  Maak een array met een aantal getallen in. Zorg ervoor dat een bepaald getal meerdere keren voorkomt in de array.Gebruik een unordered list (ul) om de getallen in de browser te tonen. Kies een goede key voor de list items.Maak een array met 5 student objecten aan. Elke student heeft een id, een naam en een leeftijd.Gebruik een ordered list (ol) om de namen van de studenten te tonen in de browser.Gebruik een ordered list (ol) om de namen van de stundenten waarvan de naam met de letter J begint te tonen in de browser. Gebruik een combinatie van filter/map.Gebruik een select met options element om de namen van de personen te tonen in de browser.Gebruik een table om de namen en leeftijden van de personen te tonen in de browser.  Voorbeeldoplossing​  Labo 1: Lijsten Getallenlijst 1234543 Studentenlijst JefJanJorisAndieSenne Studentenlijst met J JefJanJoris Select JefJanJorisAndieSenne Table Naam\tLeeftijdJef\t20 Jan\t21 Joris\t22 Andie\t23 Senne\t24  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"4. Slot machine met map​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#4-slot-machine-met-map","content":" 📂 Naam project: lab-basics-slot-machine-map 🔗 Basis project: lab-basics-slot-machine  Maak een nieuwe react applicatie aan lab-basics-slot-machine-map. Kopieer je code van de vorige opdracht naar deze nieuwe applicatie.  Opdracht​  Zorg ervoor dat je niet meer werkt met aparte variabelen per slot, maar dat je een array maakt met een variabel aantal slots (bepaald in een variabele).Pas je code nu aan dat je gebruik maakt van een map functie om de slots te tonen in de browser.Ook de tekst &quot;Je hebt gewonnen&quot; of &quot;Je hebt verloren&quot; moet je nu bepalen met een array functie.  Voorbeeldoplossing​  Labo 1: Slots met map Je hebt verloren Refresh  Oplossingsvideo​    ","version":"Next","tagName":"h2"},{"title":"5. Alien Alphabet​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#5-alien-alphabet","content":" 📂 Naam project: lab-basics-alien-alphabet 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan lab-basics-alien-alphabet.  Opdracht​  We willen in deze opdracht een aanzet geven tot een vertaalprogramma voor een buitenaards alfabet. We hebben een afbeelding voor elke letter van het alfabet. We willen deze afbeeldingen tonen in de browser.  Maak een array aan met alle letters van het alfabet. Je mag de letters zelf typen, of je kan gebruik maken van de Array.from functie. Zoek eens op hoe je aan de hand van de ASCII code een letter kan omzetten naar een string.Maak een array aan met alle afbeeldingen van het alfabet. De afbeelding van de letters kan je vinden op https://raw.githubusercontent.com/slimmii/alien-alphabet/master/ gevolgd door de letter in hoofdletters en de extensie .png. Je kan deze afbeeldingen gebruiken door de src property van de img tag te zetten op de url van de afbeelding. Bv.: https://raw.githubusercontent.com/slimmii/alien-alphabet/master/A.png https://raw.githubusercontent.com/slimmii/alien-alphabet/master/B.png https://raw.githubusercontent.com/slimmii/alien-alphabet/master/C.png ... Gebruik de map-functie om de afbeeldingen weer te geven in de browser. Elk element in de alphabetImages-array moet worden weergegeven als een &lt;img&gt; tag binnen een &lt;button&gt;-element.  Voorbeeldoplossing​    ","version":"Next","tagName":"h2"},{"title":"6. Maaltafels​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#6-maaltafels","content":" 📂 Naam project: lab-basics-multiplication-tables 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan lab-basics-multiplication-tables.  Opdracht​  Maak een React-component met de naam MultiplicationTable die een tabel genereert met de vermenigvuldigingstabel van getallen van 1 tot 10. Elk cel in de tabel moet het resultaat van de vermenigvuldiging van het rijnummer en het kolomnummer bevatten.  Voorbeeldoplossing​  1\t2\t3\t4\t5\t6\t7\t8\t9\t10 2\t4\t6\t8\t10\t12\t14\t16\t18\t20 3\t6\t9\t12\t15\t18\t21\t24\t27\t30 4\t8\t12\t16\t20\t24\t28\t32\t36\t40 5\t10\t15\t20\t25\t30\t35\t40\t45\t50 6\t12\t18\t24\t30\t36\t42\t48\t54\t60 7\t14\t21\t28\t35\t42\t49\t56\t63\t70 8\t16\t24\t32\t40\t48\t56\t64\t72\t80 9\t18\t27\t36\t45\t54\t63\t72\t81\t90 10\t20\t30\t40\t50\t60\t70\t80\t90\t100  ","version":"Next","tagName":"h2"},{"title":"7. Regenboog​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#7-regenboog","content":" 📂 Naam project: lab-basics-rainbow 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan lab-basics-rainbow.  Opdracht​  Definieer een array met de naam colors om een reeks kleuren te genereren. De array moet 100 verschillende kleuren bevatten, waarbij elke kleur wordt gedefinieerd in het HSL (Hue, Saturation, Lightness) kleurenmodel. Elke kleur in de reeks moet een unieke tint hebben, variërend van 0 graden (rood) tot 360 graden (rood).  Je kan deze array gebruiken om de kleuren te genereren:  const colors = Array.from({length: 100}, (_, i) =&gt; `hsl(${i * 360 / 100}, 100%, 50%)`);   Gebruik de map-functie om de kleuren in de array weer te geven als verticale div's op de webpagina. Elke balk moet een unieke kleur hebben, en de breedte van de balk moet 100% zijn, terwijl de hoogte 4 pixels moet zijn.  Je hebt op dit moment nog niet geleerd hoe je css gebruikt. Je kan dit doen aan de hand van inline css:  &lt;div style={{width: &quot;100%&quot;, height: &quot;4px&quot;, backgroundColor: &quot;red&quot;}}&gt;&lt;/div&gt;   Dit wordt later nog uitgelegd! Begrijp je hoe dit werkt, kan je ook eens proberen de regenboog in de andere richting te laten gaan! Tip: Twee woorden: flex-direction en flex!    ","version":"Next","tagName":"h2"},{"title":"8. Chat messages​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#8-chat-messages","content":" 📂 Naam project: lab-basics-chat-messages 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan lab-basics-chat-messages.  Opdracht​  We willen een chat applicatie maken. We hebben een array met chat berichten. Elk bericht heeft een id, een naam, een bericht en een timestamp. We willen deze berichten tonen in de browser aan de hand van een eenvoudige tabel (zonder styling).  De data kan je gewoon in een variabele zetten. Je kan deze data gebruiken:  const messages = [ { from: 'Wolverine', content: 'Hey Mags, heard you tried to bend a spoon with your mind again. You need a hand with that?', date: '2023-09-20 10:15 AM' }, { from: 'Magneto', content: 'Very funny, Logan. At least I don\\'t need metal claws to pick my teeth.', date: '2023-09-20 10:17 AM' }, { from: 'Wolverine', content: 'Touché, old man. But I bet you still can\\'t beat me at a game of chess.', date: '2023-09-20 10:20 AM' }, { from: 'Magneto', content: 'Chess? How pedestrian. I prefer a game of &quot;Move All the Metal Objects Away From Wolverine.&quot;', date: '2023-09-20 10:22 AM' }, { from: 'Wolverine', content: 'Haha, nice try, metalhead. But I\\'ve got my adamantium skeleton to keep me company.', date: '2023-09-20 10:25 AM' }, { from: 'Magneto', content: 'True, but it doesn\\'t help you with fashion choices. Those sideburns, really, Logan?', date: '2023-09-20 10:27 AM' }, { from: 'Wolverine', content: 'What can I say? They help me channel my inner bad boy.', date: '2023-09-20 10:30 AM' }, { from: 'Magneto', content: 'Speaking of bad boys, have you seen what Deadpool\\'s up to lately?', date: '2023-09-20 10:32 AM' }, { from: 'Wolverine', content: 'Oh, don\\'t get me started on that guy. He makes me look like a choirboy.', date: '2023-09-20 10:35 AM' }, { from: 'Magneto', content: 'Agreed, Logan. Let\\'s team up and take him down. It\\'s the only way to save our reputation.', date: '2023-09-20 10:37 AM' } ];   Voorbeeldoplossing​  From\tMessage\tTimestampWolverine\tHey Mags, heard you tried to bend a spoon with your mind again. You need a hand with that?\t2023-09-20 10:15 AM Magneto\tVery funny, Logan. At least I don't need metal claws to pick my teeth.\t2023-09-20 10:17 AM Wolverine\tTouché, old man. But I bet you still can't beat me at a game of chess.\t2023-09-20 10:20 AM Magneto\tChess? How pedestrian. I prefer a game of &quot;Move All the Metal Objects Away From Wolverine.&quot;\t2023-09-20 10:22 AM Wolverine\tHaha, nice try, metalhead. But I've got my adamantium skeleton to keep me company.\t2023-09-20 10:25 AM Magneto\tTrue, but it doesn't help you with fashion choices. Those sideburns, really, Logan?\t2023-09-20 10:27 AM Wolverine\tWhat can I say? They help me channel my inner bad boy.\t2023-09-20 10:30 AM Magneto\tSpeaking of bad boys, have you seen what Deadpool's up to lately?\t2023-09-20 10:32 AM Wolverine\tOh, don't get me started on that guy. He makes me look like a choirboy.\t2023-09-20 10:35 AM Magneto\tAgreed, Logan. Let's team up and take him down. It's the only way to save our reputation.\t2023-09-20 10:37 AM  ","version":"Next","tagName":"h2"},{"title":"9. Who's that Pokémon?​","type":1,"pageTitle":"Labo 1","url":"/webframeworks-cursus/wf-course/labs/react-basics/lab1#9-whos-that-pokémon","content":" 📂 Naam project: lab-basics-whos-that-pokemon 🔗 Basis project: n/a  Maak een nieuwe react applicatie aan lab-basics-whos-that-pokemon. Maak een array met 150 Pokémon aan. Elke Pokémon heeft een id en een naam. We willen een afbeelding van een willekeurige Pokémon tonen. Onder de afbeelding tonen we 4 knoppen met de namen van 4 willekeurige Pokémon.  De afbeelding kan gehaald worden op de volgende url: https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/{id}.png.  Je kan de identiteit van de pokémon verbergen door filter: &quot;brightness(0) te gebruiken op de afbeelding. De knoppen moeten nog niets doen.  Je kan beginnen met de volgende data:  interface Pokemon { id: number; name: string; } const pokemons: Pokemon[] = [ {id: 1, name: &quot;bulbasaur&quot;}, {id: 2, name: &quot;ivysaur&quot;}, {id: 3, name: &quot;venusaur&quot;}, {id: 4, name: &quot;charmander&quot;}, {id: 5, name: &quot;charmeleon&quot;}, {id: 6, name: &quot;charizard&quot;}, {id: 7, name: &quot;squirtle&quot;}, {id: 8, name: &quot;wartortle&quot;}, {id: 9, name: &quot;blastoise&quot;}, {id: 10, name: &quot;caterpie&quot;}, {id: 11, name: &quot;metapod&quot;}, {id: 12, name: &quot;butterfree&quot;}, {id: 13, name: &quot;weedle&quot;}, {id: 14, name: &quot;kakuna&quot;}, {id: 15, name: &quot;beedrill&quot;}, {id: 16, name: &quot;pidgey&quot;}, {id: 17, name: &quot;pidgeotto&quot;}, {id: 18, name: &quot;pidgeot&quot;}, {id: 19, name: &quot;rattata&quot;}, {id: 20, name: &quot;raticate&quot;}, {id: 21, name: &quot;spearow&quot;}, {id: 22, name: &quot;fearow&quot;}, {id: 23, name: &quot;ekans&quot;}, {id: 24, name: &quot;arbok&quot;}, {id: 25, name: &quot;pikachu&quot;}, {id: 26, name: &quot;raichu&quot;}, {id: 27, name: &quot;sandshrew&quot;}, {id: 28, name: &quot;sandslash&quot;}, {id: 29, name: &quot;nidoran-f&quot;}, {id: 30, name: &quot;nidorina&quot;}, {id: 31, name: &quot;nidoqueen&quot;}, {id: 32, name: &quot;nidoran-m&quot;}, {id: 33, name: &quot;nidorino&quot;}, {id: 34, name: &quot;nidoking&quot;}, {id: 35, name: &quot;clefairy&quot;}, {id: 36, name: &quot;clefable&quot;}, {id: 37, name: &quot;vulpix&quot;}, {id: 38, name: &quot;ninetales&quot;}, {id: 39, name: &quot;jigglypuff&quot;}, {id: 40, name: &quot;wigglytuff&quot;}, {id: 41, name: &quot;zubat&quot;}, {id: 42, name: &quot;golbat&quot;}, {id: 43, name: &quot;oddish&quot;}, {id: 44, name: &quot;gloom&quot;}, {id: 45, name: &quot;vileplume&quot;}, {id: 46, name: &quot;paras&quot;}, {id: 47, name: &quot;parasect&quot;}, {id: 48, name: &quot;venonat&quot;}, {id: 49, name: &quot;venomoth&quot;}, {id: 50, name: &quot;diglett&quot;}, {id: 51, name: &quot;dugtrio&quot;}, {id: 52, name: &quot;meowth&quot;}, {id: 53, name: &quot;persian&quot;}, {id: 54, name: &quot;psyduck&quot;}, {id: 55, name: &quot;golduck&quot;}, {id: 56, name: &quot;mankey&quot;}, {id: 57, name: &quot;primeape&quot;}, {id: 58, name: &quot;growlithe&quot;}, {id: 59, name: &quot;arcanine&quot;}, {id: 60, name: &quot;poliwag&quot;}, {id: 61, name: &quot;poliwhirl&quot;}, {id: 62, name: &quot;poliwrath&quot;}, {id: 63, name: &quot;abra&quot;}, {id: 64, name: &quot;kadabra&quot;}, {id: 65, name: &quot;alakazam&quot;}, {id: 66, name: &quot;machop&quot;}, {id: 67, name: &quot;machoke&quot;}, {id: 68, name: &quot;machamp&quot;}, {id: 69, name: &quot;bellsprout&quot;}, {id: 70, name: &quot;weepinbell&quot;}, {id: 71, name: &quot;victreebel&quot;}, {id: 72, name: &quot;tentacool&quot;}, {id: 73, name: &quot;tentacruel&quot;}, {id: 74, name: &quot;geodude&quot;}, {id: 75, name: &quot;graveler&quot;}, {id: 76, name: &quot;golem&quot;}, {id: 77, name: &quot;ponyta&quot;}, {id: 78, name: &quot;rapidash&quot;}, {id: 79, name: &quot;slowpoke&quot;}, {id: 80, name: &quot;slowbro&quot;}, {id: 81, name: &quot;magnemite&quot;}, {id: 82, name: &quot;magneton&quot;}, {id: 83, name: &quot;farfetch'd&quot;}, {id: 84, name: &quot;doduo&quot;}, {id: 85, name: &quot;dodrio&quot;}, {id: 86, name: &quot;seel&quot;}, {id: 87, name: &quot;dewgong&quot;}, {id: 88, name: &quot;grimer&quot;}, {id: 89, name: &quot;muk&quot;}, {id: 90, name: &quot;shellder&quot;}, {id: 91, name: &quot;cloyster&quot;}, {id: 92, name: &quot;gastly&quot;}, {id: 93, name: &quot;haunter&quot;}, {id: 94, name: &quot;gengar&quot;}, {id: 95, name: &quot;onix&quot;}, {id: 96, name: &quot;drowzee&quot;}, {id: 97, name: &quot;hypno&quot;}, {id: 98, name: &quot;krabby&quot;}, {id: 99, name: &quot;kingler&quot;}, {id: 100, name: &quot;voltorb&quot;}, {id: 101, name: &quot;electrode&quot;}, {id: 102, name: &quot;exeggcute&quot;}, {id: 103, name: &quot;exeggutor&quot;}, {id: 104, name: &quot;cubone&quot;}, {id: 105, name: &quot;marowak&quot;}, {id: 106, name: &quot;hitmonlee&quot;}, {id: 107, name: &quot;hitmonchan&quot;}, {id: 108, name: &quot;lickitung&quot;}, {id: 109, name: &quot;koffing&quot;}, {id: 110, name: &quot;weezing&quot;}, {id: 111, name: &quot;rhyhorn&quot;}, {id: 112, name: &quot;rhydon&quot;}, {id: 113, name: &quot;chansey&quot;}, {id: 114, name: &quot;tangela&quot;}, {id: 115, name: &quot;kangaskhan&quot;}, {id: 116, name: &quot;horsea&quot;}, {id: 117, name: &quot;seadra&quot;}, {id: 118, name: &quot;goldeen&quot;}, {id: 119, name: &quot;seaking&quot;}, {id: 120, name: &quot;staryu&quot;}, {id: 121, name: &quot;starmie&quot;}, {id: 122, name: &quot;mr. mime&quot;}, {id: 123, name: &quot;scyther&quot;}, {id: 124, name: &quot;jynx&quot;}, {id: 125, name: &quot;electabuzz&quot;}, {id: 126, name: &quot;magmar&quot;}, {id: 127, name: &quot;pinsir&quot;}, {id: 128, name: &quot;tauros&quot;}, {id: 129, name: &quot;magikarp&quot;}, {id: 130, name: &quot;gyarados&quot;}, {id: 131, name: &quot;lapras&quot;}, {id: 132, name: &quot;ditto&quot;}, {id: 133, name: &quot;eevee&quot;}, {id: 134, name: &quot;vaporeon&quot;}, {id: 135, name: &quot;jolteon&quot;}, {id: 136, name: &quot;flareon&quot;}, {id: 137, name: &quot;porygon&quot;}, {id: 138, name: &quot;omanyte&quot;}, {id: 139, name: &quot;omastar&quot;}, {id: 140, name: &quot;kabuto&quot;}, {id: 141, name: &quot;kabutops&quot;}, {id: 142, name: &quot;aerodactyl&quot;}, {id: 143, name: &quot;snorlax&quot;}, {id: 144, name: &quot;articuno&quot;}, {id: 145, name: &quot;zapdos&quot;}, {id: 146, name: &quot;moltres&quot;}, {id: 147, name: &quot;dratini&quot;}, {id: 148, name: &quot;dragonair&quot;}, {id: 149, name: &quot;dragonite&quot;}, {id: 150, name: &quot;mewtwo&quot;}, {id: 151, name: &quot;mew&quot;} ];   Voorbeeldoplossing​  Loading ","version":"Next","tagName":"h2"},{"title":"Form Handling","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/nextjs/forms","content":"","keywords":"","version":"Next"},{"title":"Server Actions​","type":1,"pageTitle":"Form Handling","url":"/webframeworks-cursus/wf-course/nextjs/forms#server-actions","content":" React Server Actions maken het mogelijk om asynchrone code rechtstreeks op de server uit te voeren. Dat betekent dat je geen aparte API-endpoints meer hoeft te schrijven om data te wijzigen. In plaats daarvan schrijf je asynchrone functies die op de server draaien, maar die je kunt aanroepen vanuit zowel Client Components als Server Components. Zo kan je bijvoorbeeld een formulier rechtstreeks koppelen aan een serverfunctie: wanneer de gebruiker het formulier indient, wordt die functie op de server uitgevoerd met directe toegang tot de database en andere back-endlogica. Er is geen extra fetch-request nodig, geen CORS-configuratie en ook geen aparte router of JSON-parsing — alles zit in één plek.  Vroeger moest dit heel anders. Je had een aparte backend nodig, bijvoorbeeld een Express-server of een .NET Core API. Daarin moest je routes definiëren zoals een POST-endpoint voor het verwerken van formulieren en een GET-endpoint voor het ophalen van data. Op de clientkant moest je in React met fetch of axios een request sturen naar dat endpoint, wachten op een JSON-response en daarna zelf de UI bijwerken. Je moest zorgen voor correcte headers, validatie, beveiliging tegen CSRF en CORS-problemen, en vaak ook dubbele type-definities maken voor zowel frontend als backend. Dat werkte prima, maar voor een eenvoudige use-case zoals het versturen van een contactformulier was er behoorlijk wat boilerplate nodig.  Met Server Actions valt al die extra code weg: je definieert één enkele functie in je Next.js-project, markeert die met &quot;use server&quot; en koppelt ze direct aan je formulier. De data gaat automatisch naar de server, de actie wordt uitgevoerd en je kunt na afloop meteen de UI opnieuw valideren of een redirect doen. Dit maakt de code veel overzichtelijker, veiliger en makkelijker te onderhouden. Een aparte API is alleen nog nodig als je data wil delen met externe clients, zoals mobiele apps of andere systemen.  ","version":"Next","tagName":"h2"},{"title":"Formulier (Server Component)​","type":1,"pageTitle":"Form Handling","url":"/webframeworks-cursus/wf-course/nextjs/forms#formulier-server-component","content":" We gaan een eenvoudig formulier maken dat een bericht opslaagt in een mongodb database. Hiervoor hebben we al een voor gedefinieerde database.ts file die de connectie met de database maakt en een Message model die we kunnen gebruiken om berichten op te slaan in de database.  import { Collection, MongoClient } from &quot;mongodb&quot;; import { Message } from &quot;@/types&quot;; console.log(process.env.MONGODB_URI); const client = new MongoClient(process.env.MONGODB_URI!); export const messageCollection: Collection&lt;Message&gt; = client.db(&quot;messages&quot;).collection&lt;Message&gt;(&quot;message&quot;); export const saveMessage = async (message: Message) =&gt; { const result = await messageCollection.insertOne(message); return result; } export const getMessages = async() =&gt; { const messages = await messageCollection.find().toArray(); return messages; }   en  export interface Message { _id?: string; firstName: string; lastName: string; email: string; message: string; createdAt?: Date; }   We gaan nu een formulier maken in een server component. Dit formulier zal de data doorsturen naar een server action die we later gaan maken.  import React from &quot;react&quot;; import &quot;./page.css&quot;; export default function ContactPage() { return ( &lt;div className=&quot;form-container&quot;&gt; &lt;div className=&quot;form-card&quot;&gt; &lt;div className=&quot;form-header&quot;&gt; &lt;h1&gt;Send a Message&lt;/h1&gt; &lt;p&gt;Fill in the form below. Fields marked with * are required.&lt;/p&gt; &lt;/div&gt; &lt;form className=&quot;form-body&quot;&gt; &lt;div className=&quot;form-grid&quot;&gt; &lt;div className=&quot;form-group&quot;&gt; &lt;label htmlFor=&quot;firstName&quot;&gt;First name *&lt;/label&gt; &lt;input id=&quot;firstName&quot; name=&quot;firstName&quot; type=&quot;text&quot; required placeholder=&quot;Ada&quot; /&gt; &lt;/div&gt; &lt;div className=&quot;form-group&quot;&gt; &lt;label htmlFor=&quot;lastName&quot;&gt;Last name *&lt;/label&gt; &lt;input id=&quot;lastName&quot; name=&quot;lastName&quot; type=&quot;text&quot; required placeholder=&quot;Lovelace&quot; /&gt; &lt;/div&gt; &lt;div className=&quot;form-group form-full&quot;&gt; &lt;label htmlFor=&quot;email&quot;&gt;Email *&lt;/label&gt; &lt;input id=&quot;email&quot; name=&quot;email&quot; type=&quot;email&quot; required placeholder=&quot;ada@example.com&quot; /&gt; &lt;/div&gt; &lt;div className=&quot;form-group form-full&quot;&gt; &lt;label htmlFor=&quot;message&quot;&gt;Message *&lt;/label&gt; &lt;textarea id=&quot;message&quot; name=&quot;message&quot; rows={6} required placeholder=&quot;Write your message here...&quot; /&gt; &lt;p className=&quot;form-hint&quot;&gt;Keep it clear and concise.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;form-actions&quot;&gt; &lt;button type=&quot;reset&quot; className=&quot;btn-secondary&quot;&gt; Reset &lt;/button&gt; &lt;button type=&quot;submit&quot; className=&quot;btn-primary&quot;&gt; Send &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; ); }   Nu hebben we een formulier, maar het doet nog niets als we op de knop &quot;Send&quot; klikken. We gaan nu een server action maken die de data van het formulier zal verwerken. Meestal maken we een aparte file aan voor server actions, bijvoorbeeld actions.ts. Op dit moment willen we gewoon een console.log doen met de data die we ontvangen van het formulier.  &quot;use server&quot;; const createMessage = async (formData: FormData) =&gt; { const firstName = formData.get(&quot;firstName&quot;)?.toString(); const lastName = formData.get(&quot;lastName&quot;)?.toString(); const email = formData.get(&quot;email&quot;)?.toString(); const message = formData.get(&quot;message&quot;)?.toString(); console.log({ firstName, lastName, email, message }); };   FormData bevat de data van het formulier. We kunnen deze data ophalen met de get methode. De naam die we meegeven aan de get methode moet overeenkomen met de naam die we hebben meegegeven aan het name attribuut van het input veld in het formulier. Nu moeten we deze server action koppelen aan het formulier. Dit doen we door de action attribute van het form element te gebruiken.  Vergeet hier niet om bovenaan de file use server toe te voegen anders gaan de server actions niet werken.  &lt;form className=&quot;form-body&quot; action={createMessage}&gt;   Let op dat we hier geen methode zoals POST of GET moeten meegeven. Als je nu op de knop &quot;Send&quot; klikt, dan zal de server action worden aangeroepen en zal de data van het formulier worden gelogd in de console van de server. Vervolgens kunnen we de data opslaan in de database. Hiervoor moeten we de saveMessage functie importeren uit de database.ts file die we eerder hebben gemaakt.  &quot;use server&quot; import { redirect } from &quot;next/navigation&quot;; import { saveMessage } from &quot;./database&quot;; export const createMessage = async (formData: FormData) =&gt; { const firstName = formData.get(&quot;firstName&quot;)?.toString(); const lastName = formData.get(&quot;lastName&quot;)?.toString(); const email = formData.get(&quot;email&quot;)?.toString(); const message = formData.get(&quot;message&quot;)?.toString(); if (!firstName || !lastName || !email || !message) { throw new Error(&quot;All fields are required&quot;); } await saveMessage({ firstName, lastName, email, message, createdAt: new Date() }); redirect(&quot;/contact/thank-you&quot;); }   Hier doen we een aantal dingen:  We controleren of alle velden zijn ingevuld. Als dit niet het geval is, dan gooien we een error. In een echte applicatie zou je hier een betere foutafhandeling moeten implementeren. Hoe we deze fout kunnen afhandelen komt later aan bod.We slaan het bericht op in de database met de saveMessage functie. Deze functie is asynchroon, dus we moeten hier await voor gebruiken.We redirecten de gebruiker naar een &quot;Thank you&quot; pagina nadat het bericht is opgeslagen.  Je moet uiteraard nog wel een nieuwe pagina aanmaken voor de &quot;Thank you&quot; pagina, bijvoorbeeld app/contact/thank-you/page.tsx.  import React from &quot;react&quot;; import &quot;../page.css&quot;; const MessageForm = () =&gt; { return ( &lt;div className=&quot;form-container&quot;&gt; &lt;div className=&quot;form-card&quot;&gt; &lt;div className=&quot;form-header&quot;&gt; &lt;h1&gt;Thank you&lt;/h1&gt; &lt;p&gt;Your message has been sent successfully. We will get back to you shortly.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } export default MessageForm;   Als we de error message nu willen afhandelen op een heel eenvoudige manier kunnen we gebruik maken van een error.tsx file. Deze file wordt automatisch gebruikt door Next.js als er een error wordt gegooid in een server component. We kunnen deze file aanmaken in de app/contact folder.  &quot;use client&quot;; const ErrorPage = ({ error, reset }: { error: Error; reset: () =&gt; void }) =&gt; { return ( &lt;div className=&quot;form-container&quot;&gt; &lt;div className=&quot;form-card&quot;&gt; &lt;div className=&quot;form-header&quot;&gt; &lt;h1&gt;Something went wrong&lt;/h1&gt; &lt;p&gt;{error.message}&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; ); } export default ErrorPage;   Wil je er voor zorgen dat de button even gedisabled wordt nadat je de knop hebt ingedrukt, dan kan je gebruik maken van een kleine Client Component die we kunnen inladen in het formulier. Deze component zorgt er voor dat de button even disabled wordt nadat je op de knop hebt geklikt. We maken hiervoor een nieuwe component aan SubmitButton.tsx.  &quot;use client&quot; import { useFormStatus } from &quot;react-dom&quot;; const SubmitButton = () =&gt; { const status = useFormStatus(); return ( &lt;button type=&quot;submit&quot; className={`btn-primary`} disabled={status.pending}&gt; Send &lt;/button&gt; ) } export default SubmitButton;   Hier gebruiken we dus de useFormStatus hook die ons vertelt of het formulier aan het verzenden is. We gebruiken deze status om de button te disablen als het formulier aan het verzenden is. We kunnen deze component nu gebruiken in het formulier.  ","version":"Next","tagName":"h2"},{"title":"Formulier (Client Component)​","type":1,"pageTitle":"Form Handling","url":"/webframeworks-cursus/wf-course/nextjs/forms#formulier-client-component","content":" Soms is het nodig om meer controle te hebben over het formulier, bijvoorbeeld om validatie te doen of om de UI bij te werken zonder de pagina te herladen. In dat geval kunnen we een Client Component maken die het formulier bevat. Hiervoor hebben we de useActionState hook nodig die we kunnen importeren uit react-dom. Deze hook geeft ons de status van de server action en maakt het mogelijk om de UI bij te werken op basis van deze status.  const [state, createMessageAction, pending] = useActionState(createMessage, {success: false, error: null});   Deze hook geeft ons drie dingen:  state: de huidige status van de actie. Dit is een object dat we kunnen gebruiken om de status bij te houden. In dit geval houden we bij of de actie succesvol is geweest of dat er een error is opgetreden.createMessageAction: een functie die we kunnen aanroepen om de server action uit te voeren.pending: een boolean die aangeeft of de actie aan het uitvoeren is (een soort van loading state).  We hoeven hier dus zelf geen verschillende states bij te houden zoals loading, success of error. Dit wordt allemaal voor ons gedaan door de useActionState hook.  We moeten hier ook onze createMessage server action een klein beetje aanpassen zodat hij als parameter de vorige state meekrijgt en deze kan updaten. We moeten hier ook de return value aanpassen zodat we de nieuwe state teruggeven.  export interface CreateMessageState { error: string | null; success: boolean; } export const createMessage = async (state: CreateMessageState, formData: FormData) =&gt; { const firstName = formData.get(&quot;firstName&quot;)?.toString(); const lastName = formData.get(&quot;lastName&quot;)?.toString(); const email = formData.get(&quot;email&quot;)?.toString(); const message = formData.get(&quot;message&quot;)?.toString(); let error : string | null = null; if (!firstName || !lastName || !email || !message) { error = &quot;All fields are required&quot;; } else { await saveMessage({ firstName, lastName, email, message, createdAt: new Date() }); } return { success: true, error: error } }   Vervolgens kunnen we nu de createMessageAction meegeven aan het formulier. ","version":"Next","tagName":"h3"},{"title":"Routing","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/nextjs/routing","content":"","keywords":"","version":"Next"},{"title":"File-system based router​","type":1,"pageTitle":"Routing","url":"/webframeworks-cursus/wf-course/nextjs/routing#file-system-based-router","content":" Next.js maakt gebruik van een zogenaamde &quot;file-system based&quot; router. Dit betekend dat we geen extra code moeten schrijven om de router te configureren. We moeten enkel een aantal bestanden en directories aanmaken en de router zal automatisch de juiste pagina tonen op basis van het pad.  Als je een nieuw Next.js project aanmaakt met npx create-next-app@latest dan zal er automatisch een app directory aangemaakt worden. In deze directory kan je nieuwe bestanden en directories aanmaken om nieuwe routes te maken. Er wordt ook al een page.tsx bestand aangemaakt in de app directory.  ","version":"Next","tagName":"h2"},{"title":"Nieuwe routes maken​","type":1,"pageTitle":"Routing","url":"/webframeworks-cursus/wf-course/nextjs/routing#nieuwe-routes-maken","content":" Als je bijvoorbeeld een pagina wilt aanbieden op het pad /about, dan kan je een nieuwe directory about aanmaken in de app directory en daar een nieuw bestand page.tsx aanmaken. Je kan hier zo diep gaan als je zelf wil. Wil je bijvoorbeeld een pagina aanbieden op het pad /dashboard/invoices, dan kan je een directory dashboard aanmaken in de app directory en daar een nieuwe directory invoices aanmaken. In deze directory kan je dan een nieuw bestand page.tsx aanmaken.    ","version":"Next","tagName":"h3"},{"title":"Link component​","type":1,"pageTitle":"Routing","url":"/webframeworks-cursus/wf-course/nextjs/routing#link-component","content":" Om te navigeren tussen de verschillende pagina's kan je gebruik maken van het Link component dat meegeleverd wordt met Next.js. Dit component zorgt ervoor dat de navigatie gebeurt zonder dat de pagina volledig herladen wordt. Dit zorgt voor een betere gebruikerservaring. Als je gewoon een &lt;a&gt; element gebruikt, dan zal de pagina volledig herladen worden.  Als we bijvoorbeeld een navigatiebalk willen maken die op de root pagina getoond wordt, dan kunnen we een nieuwe component NavBar maken en deze toevoegen aan de layout.tsx bestand in de app directory.  import Link from &quot;next/link&quot;; const NavBar = () =&gt; { return ( &lt;nav&gt; &lt;Link href=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;Link href=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;Link href=&quot;/dashboard/invoices&quot;&gt;Invoices&lt;/Link&gt; &lt;/nav&gt; ); };   Je kan in principe zelf kiezen waar je de NavBar component aanmaakt in de directory structuur van je project. Je kan deze bijvoorbeeld in de src/components directory plaatsen. Er wordt ook vaak gekozen om de componenten bij de pagina's te plaatsen waar ze gebruikt worden. In dit geval zou je de NavBar component in de app directory kunnen plaatsen.  Active links​  Om aan te geven welke link actief is, kan je gebruik maken van de usePathname hook die meegeleverd wordt met Next.js. Deze hook geeft de huidige pathname terug. Je kan deze gebruiken om te bepalen welke link actief is en deze een andere stijl te geven. Deze werkt enkel in client componenten dus meestal zijn navigatiebalken client componenten.  &quot;use client&quot;; import Link from &quot;next/link&quot;; import { usePathname } from &quot;next/navigation&quot;; interface NavLinkProps { href: string; label: string; } const NavLink = ({href, label} : NavLinkProps) =&gt; { const pathname = usePathname(); return ( &lt;Link href={href} className={`px-3 py-2 rounded-md text-sm font-medium ${pathname === href ? &quot;bg-blue-600 text-white&quot; : &quot;text-gray-700 hover:bg-gray-200 hover:text-black&quot;}`}&gt; {label} &lt;/Link&gt; ) } const NavBar = () =&gt; { return ( &lt;nav&gt; &lt;NavLink href=&quot;/&quot; label=&quot;Home&quot; /&gt; &lt;NavLink href=&quot;/about&quot; label=&quot;About&quot; /&gt; &lt;NavLink href=&quot;/dashboard/invoices&quot; label=&quot;Invoices&quot; /&gt; &lt;/nav&gt; ); }; export default NavBar;   ","version":"Next","tagName":"h3"},{"title":"Layouts maken​","type":1,"pageTitle":"Routing","url":"/webframeworks-cursus/wf-course/nextjs/routing#layouts-maken","content":" Je kan ook gebruik maken van layouts om gedeelde componenten te maken die op meerdere pagina's gebruikt worden. Dit is handig als je bijvoorbeeld een navigatiebalk of een footer wil maken die op alle pagina's getoond wordt. Je kan dit doen door een nieuw bestand layout.tsx aan te maken in de directory waar je de layout wil gebruiken. Dus als je een layout wil maken die op alle pagina's gebruikt wordt, dan kan je een nieuw bestand layout.tsx aanmaken in de app directory.  app/layout.tsx → layout voor alle pagina's   Elke nieuwe next applicatie die je aanmaakt met npx create-next-app@latest heeft al een layout.tsx bestand in de app directory. Vereenvoudigd ziet dit bestand er als volgt uit:  const RootLayout = ({ children }: { children: React.ReactNode }) =&gt; { return ( &lt;html lang=&quot;en&quot;&gt; &lt;body&gt;{children}&lt;/body&gt; &lt;/html&gt; ); }; export default RootLayout;   Je ziet hier dat de layout een component is die een children prop verwacht. Deze prop bevat de inhoud van de pagina die getoond moet worden. In dit geval wordt de inhoud van de pagina in de body van het HTML document geplaatst.  Wil je bijvoorbeeld op elke pagina een navigatiebalk tonen, dan kan je dit doen door de navigatiebalk component toe te voegen aan de layout:  import NavBar from &quot;@/components/NavBar&quot;; const RootLayout = ({ children }: { children: React.ReactNode }) =&gt; { return ( &lt;html lang=&quot;en&quot;&gt; &lt;body&gt; &lt;NavBar /&gt; {children} &lt;/body&gt; &lt;/html&gt; ); }; export default RootLayout;     Je kan ook geneste layouts maken. Dit is handig als je bijvoorbeeld een layout wil maken die alleen op bepaalde pagina's gebruikt wordt. Wil je bijvoorbeeld een layout maken die alleen op de dashboard pagina's gebruikt wordt, dan kan je een nieuw bestand layout.tsx aanmaken in de app/dashboard directory.  app/dashboard/layout.tsx → layout voor alle dashboard pagina's   Stel je voor dat we een speciale layout willen maken voor alle dashboard pagina's. Deze layout kan er als volgt uitzien:  import SideBar from &quot;@/components/SideBar&quot;; const DashboardLayout = ({ children }: { children: React.ReactNode }) =&gt; { return ( &lt;div style={{ display: &quot;flex&quot; }}&gt; &lt;SideBar /&gt; &lt;div&gt; {children} &lt;/div&gt; &lt;/div&gt; ); }; export default DashboardLayout;   Merk hierbij op dat eerst de Layout in de app directory wordt toegepast en daarna de layout in de app/dashboard directory. Dit betekend dat de NavBar component altijd getoond wordt, ook op de dashboard pagina's.  Als je naar /dashboard/invoices navigeert, dan zal de volgende structuur getoond worden:    ","version":"Next","tagName":"h3"},{"title":"Dynamische routes​","type":1,"pageTitle":"Routing","url":"/webframeworks-cursus/wf-course/nextjs/routing#dynamische-routes","content":" Je kan ook dynamische routes maken. Dit is handig als je bijvoorbeeld een pagina wil maken die de details van een bepaald item toont. Stel je voor dat we een pagina hebben die een lijst van producten toont. Als je op een product klikt, wil je naar een pagina navigeren die de details van dat product toont.  Stel dat we een lijst van producten hebben zoals hieronder:  interface Product { id: number; name: string; } const products : Product[] = [ { id: 1, name: &quot;Product 1&quot; }, { id: 2, name: &quot;Product 2&quot; }, { id: 3, name: &quot;Product 3&quot; }, ]; export default products;   We kunnen dan een nieuwe pagina maken die de lijst van producten toont. Dit kan in het bestand src/app/products/page.tsx:  import Link from &quot;next/link&quot;; import products from &quot;@/data/products&quot;; const ProductsPage = () =&gt; { return ( &lt;div&gt; &lt;h1&gt;Products&lt;/h1&gt; &lt;ul&gt; {products.map((product) =&gt; ( &lt;li key={product.id}&gt; &lt;Link href={`/products/${product.id}`}&gt;{product.name}&lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; ); }; export default Products;   We gaan hier uiteraard geen drie aparte pagina's maken voor elk product. In plaats daarvan gaan we een dynamische route maken. Dit kan door een nieuwe directory aan te maken in de app/products directory met de naam [id]. De naam tussen de vierkante haken geeft aan dat dit een dynamische parameter is. In deze directory kunnen we dan een nieuw bestand page.tsx aanmaken.  const ProductsDetail = async(props: PageProps&lt;&quot;/products/[id]&quot;&gt;) =&gt; { const { id } = await props.params; return ( &lt;div className=&quot;p-4&quot;&gt; &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Product Detail for ID: {id}&lt;/h1&gt; &lt;p className=&quot;text-lg&quot;&gt;This is the detail page for product with ID {id}.&lt;/p&gt; &lt;/div&gt; ); } export default ProductsDetail;   Merk op dat we hier een speciaal type PageProps gebruiken om de props van de pagina te typeren. Dit type wordt meegeleverd door Next.js en zorgt ervoor dat we toegang hebben tot de dynamische parameters in de URL. In dit geval is er één parameter id die we kunnen gebruiken om de details van het product op te halen. Omdat het ophalen van parameters in Next.js asynchroon is, maken we de component async en gebruiken we await om de parameters op te halen.  Als je deze wil uitlezen in een client component, dan kan je gebruik maken van de useParams hook die meegeleverd wordt met Next.js. Deze hook geeft een object terug met de dynamische parameters.  &quot;use client&quot;; import { useParams } from &quot;next/navigation&quot;; const ProductDetailClient = () =&gt; { const params = useParams(); const { id } = params; return ( &lt;div&gt; &lt;h1&gt;Product Detail for ID: {id}&lt;/h1&gt; &lt;p&gt;This is the detail page for product with ID {id}.&lt;/p&gt; &lt;/div&gt; ); }; export default ProductDetailClient;   ","version":"Next","tagName":"h3"},{"title":"Search parameters​","type":1,"pageTitle":"Routing","url":"/webframeworks-cursus/wf-course/nextjs/routing#search-parameters","content":" Server component​  In een server component (zoals een pagina of layout) kan je ook gebruik maken van search parameters (of query parameters). Dit zijn de parameters die in de URL staan na het vraagteken (?). Stel dat we een pagina hebben die een lijst van producten toont en we willen deze lijst filteren op basis van een zoekterm. We kunnen dan de zoekterm als een search parameter in de URL meegeven, bijvoorbeeld /products?q=shirt.  const ProductsPage = async(props: PageProps&lt;&quot;/products&quot;&gt;) =&gt; { const searchParams = await props.searchParams; const q = typeof searchParams.q === &quot;string&quot; ? searchParams.q : &quot;&quot;; const filteredProducts = products.filter(product =&gt; product.name.startsWith(q)); return ( &lt;div&gt; &lt;h1&gt;Products&lt;/h1&gt; &lt;ul&gt; {filteredProducts.map((product) =&gt; ( &lt;li key={product.id}&gt; &lt;Link href={`/products/${product.id}`}&gt;{product.name}&lt;/Link&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; ); } export default ProductsPage;   Opgelet deze dingen zijn enkel mogelijk in server componenten.  Search parameters in client componenten​  Om de search parameters te gebruiken in een client component, kan je gebruik maken van de useSearchParams hook die meegeleverd wordt met Next.js. Deze hook geeft een URLSearchParams object terug dat je kan gebruiken om de search parameters op te halen.  &quot;use client&quot;; import { useSearchParams, useRouter } from &quot;next/navigation&quot;; const SearchBox = () =&gt; { const searchParams = useSearchParams(); const { replace } = useRouter(); const q = searchParams.get(&quot;q&quot;) || &quot;&quot;; const onChange : React.ChangeEventHandler&lt;HTMLInputElement&gt; = (e) =&gt; { const newQ = e.target.value; const params = new URLSearchParams(searchParams.toString()); if (newQ) { params.set(&quot;q&quot;, newQ); } else { params.delete(&quot;q&quot;); } replace(`?${params.toString()}`); }; return ( &lt;input type=&quot;text&quot; value={q} onChange={onChange} defaultValue={searchParams.get('query')?.toString()} placeholder=&quot;Search...&quot; /&gt; ); }; export default SearchBox;  ","version":"Next","tagName":"h3"},{"title":"React","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react","content":"React","keywords":"","version":"Next"},{"title":"Server Components","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr","content":"","keywords":"","version":"Next"},{"title":"Client Components​","type":1,"pageTitle":"Server Components","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr#client-components","content":" Voor we in detail treden over server components, is het belangrijk om eerst te begrijpen wat client components zijn. Client components zijn componenten die in de browser gerenderd worden. Dit is de standaard manier om React componenten te maken. In een client component kan je state en effects gebruiken om interactiviteit toe te voegen aan je applicatie. Dit zijn dus de componenten die we tot nu toe altijd gebruikt hebben in onze React applicaties.  Ook belangrijk is dat Next.js standaard alle componenten als server components behandelt. Dit betekend dat als je een nieuw component aanmaakt, dit standaard een server component is. Wil je een client component maken, dan moet je bovenaan het bestand use client zetten. Dit is nodig omdat client components state en effects kunnen gebruiken en server components niet.  import { useState } from &quot;react&quot;; const Home = () =&gt; { const [counter, setCounter] = useState(0); return ( &lt;div&gt; &lt;button onClick={() =&gt; setCounter(counter =&gt; counter + 1)}&gt;{counter}&lt;/button&gt; &lt;/div&gt; ); } export default Home;   Dit zal een fout geven omdat we state gebruiken in een server component. Om dit op te lossen moeten we bovenaan het bestand use client zetten  &quot;use client&quot; import { useState } from &quot;react&quot;; const Home = () =&gt; { const [counter, setCounter] = useState(0); return ( &lt;div&gt; &lt;button onClick={() =&gt; setCounter(counter =&gt; counter + 1)}&gt;{counter}&lt;/button&gt; &lt;/div&gt; ); } export default Home;   Dit wil zeggen dat alles van het onderdeel React.js dat we tot nu toe geleerd hebben, nog steeds geldig is. We kunnen nog steeds state en effects gebruiken in onze componenten. We moeten alleen bovenaan het bestand use client zetten om aan te geven dat het een client component is.  Over het algemeen is de regel dat je een component een client component maakt als je een van de volgende dingen wil doen:  State gebruiken met useStateSide effects gebruiken met useEffectEvent handlers gebruiken zoals onClick, onChange, ...Browser-only APIs gebruiken zoals localStorage, document, window, ...Externe libraries gebruiken die niet op de server werken, zoals react-router, leaflet, ...  ","version":"Next","tagName":"h2"},{"title":"Server Components​","type":1,"pageTitle":"Server Components","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr#server-components-1","content":" Zoals al eerder vermeld, zijn server components componenten die op de server gerenderd worden. Dit is nuttig voor componenten als je:  Data wil ophalen van een server of databaseComponenten wil maken die geen state of effects nodig hebbenDe hoeveelheid JavaScript die naar de browser gestuurd wordt wil verminderenDe First Contentful Paint (FCP) wil verbeteren. Dit is de tijd die het duurt voordat de gebruiker iets op het scherm ziet.  By default zijn Next.js applicaties gebaseerd op React Server Components. Het ophalen van data met Server Components is een relatief nieuwe aanpak en er zijn een paar voordelen aan het gebruik ervan:  Server Components ondersteunen JavaScript Promises, wat een oplossing biedt voor asynchrone taken zoals het ophalen van data. Je kan de async/await syntax gebruiken zonder dat je useEffect, useState of andere data fetching libraries nodig hebt.Server Components draaien op de server, dus je kan zware data fetches en logica op de server houden en alleen het resultaat naar de client sturen.Omdat Server Components op de server draaien, kan je rechtstreeks de database bevragen zonder een extra API laag. Dit bespaart je het schrijven en onderhouden van extra code.  ","version":"Next","tagName":"h2"},{"title":"Data Fetching in Server Components​","type":1,"pageTitle":"Server Components","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr#data-fetching-in-server-components","content":" Stel je hebt het volgende client component dat data ophaalt van een API:  &quot;use client&quot; import { useState, useEffect } from &quot;react&quot;; import { User } from &quot;@/types&quot;; const Home = () =&gt; { const [users, setUsers] = useState&lt;User[]&gt;([]); const fetchUsers = async() =&gt; { const response = await fetch(&quot;https://jsonplaceholder.typicode.com/users&quot;); const data : User[] = await response.json(); setUsers(data); } useEffect(() =&gt; { fetchUsers(); },[]); return ( &lt;div&gt; &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;User List&lt;/h1&gt; { users.map(user =&gt; ( &lt;div key={user.id} className=&quot;mb-4 p-4 border border-gray-200 rounded&quot;&gt;{user.name}&lt;/div&gt;)) } &lt;/div&gt; ) } export default Home;   Hier maken we gebruik van useState en useEffect om data op te halen van een API. Dit is de standaard manier om data op te halen in een React applicatie. Het nadeel hiervan is dat de gebruiker eerst een lege lijst ziet voor een paar milliseconden terwijl de data opgehaald wordt. We zouden dit kunnen oplossen door een loading indicator te tonen, maar dit is niet ideaal voor de gebruikerservaring.  Het alternatief in Next.js is om een server component te maken dat de data ophaalt. Dit kan je doen door het use client statement weg te laten. In een server component kan je namelijk gewoon async functies gebruiken om data op te halen. Dit zorgt ervoor dat de data al opgehaald is voordat de HTML naar de browser gestuurd wordt. De gebruiker ziet dus meteen de volledige lijst zonder dat hij moet wachten.  import { User } from &quot;@/types&quot;; const fetchUsers = async() =&gt; { const response = await fetch(&quot;https://jsonplaceholder.typicode.com/users&quot;, { cache: &quot;no-store&quot; }); const data : User[] = await response.json(); return data; } const Home = async() =&gt; { const users = await fetchUsers(); return ( &lt;div&gt; &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;User List&lt;/h1&gt; { users.map(user =&gt; ( &lt;div key={user.id} className=&quot;mb-4 p-4 border border-gray-200 rounded&quot;&gt;{user.name}&lt;/div&gt;)) } &lt;/div&gt; ) } export default Home;   Je ziet hier dat het component Home nu een async functie is. Dit is mogelijk omdat het een server component is. We kunnen dus gewoon await gebruiken om de data op te halen. Dit zorgt ervoor dat de data al opgehaald is voordat de HTML naar de browser gestuurd wordt. De gebruiker ziet dus meteen de volledige lijst zonder dat hij moet wachten.  Opgelet: dit is alleen mogelijk in server components. In client components kan je geen async functies gebruiken voor het component zelf.  Merk op dat we bij de fetch call de optie { cache: &quot;no-store&quot; } meegeven. Dit zorgt ervoor dat de data telkens opnieuw opgehaald wordt bij elke request. Standaard zal Next.js namelijk caching toepassen bij fetch calls in server components. Dit betekent dat als je meerdere keren dezelfde request doet, de data uit de cache gehaald wordt in plaats van opnieuw opgehaald. Dit maakt je app sneller, maar kan er ook voor zorgen dat je verouderde data toont.  ","version":"Next","tagName":"h3"},{"title":"loading.tsx​","type":1,"pageTitle":"Server Components","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr#loadingtsx","content":" Een handige feature van Next.js is dat je een loading.tsx bestand kan maken in een directory om een loading indicator te tonen terwijl een server component aan het laden is. Je plaatst deze file in dezelfde directory als waar je loading pagina wil.  const Loading = () =&gt; { return ( &lt;div className=&quot;p-4&quot;&gt; &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Loading...&lt;/h1&gt; &lt;/div&gt; ) } export default Loading;   ","version":"Next","tagName":"h3"},{"title":"Suspense​","type":1,"pageTitle":"Server Components","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr#suspense","content":" Als je meer controle wilt over wat er moet gebeuren als een component nog data aan het fetchen is, dan kan je gebruik maken van React's Suspense component. Hiermee kan je een fallback component tonen terwijl de data aan het laden is. Stel dat we een Todo component hebben dat data ophaalt van een API aan de hand van een prop id  const fetchTodo = async (id: string) =&gt; { const response = await fetch(`https://jsonplaceholder.typicode.com/todos/${id}`, {cache: 'no-store'}); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); // Simulate network delay if (!response.ok) { throw new Error('Failed to fetch todo'); } const data = await response.json(); return data; } const Todo = async ({ id }: { id: string }) =&gt; { const todo = await fetchTodo(id); return ( &lt;div className=&quot;p-4 border border-gray-200 rounded shadow-sm&quot;&gt; &lt;h2 className=&quot;text-xl font-semibold mb-2&quot;&gt;Todo Item&lt;/h2&gt; &lt;p&gt;&lt;strong&gt;ID:&lt;/strong&gt; {todo.id}&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Title:&lt;/strong&gt; {todo.title}&lt;/p&gt; &lt;p&gt;&lt;strong&gt;Completed:&lt;/strong&gt; {todo.completed ? &quot;Yes&quot; : &quot;No&quot;}&lt;/p&gt; &lt;/div&gt; ); } export default Todo;   Let op dat we een vertraging van 2 seconden simuleren om het laden duidelijk te maken. We kunnen dit component nu gebruiken in een andere server component en Suspense gebruiken om een fallback te tonen terwijl de data aan het laden is. Als we deze eerst zonder Suspense zouden gebruiken, dan zou de hele pagina wachten tot de data geladen is voordat er iets getoond wordt.  import Todo from &quot;@/components/Todo&quot;; const TodosPage = () =&gt; { return ( &lt;div&gt; &lt;Todo id=&quot;1&quot; /&gt; &lt;Todo id=&quot;2&quot; /&gt; &lt;Todo id=&quot;3&quot; /&gt; &lt;/div&gt; ); } export default TodosPage;   Om dit op te lossen kunnen we Suspense gebruiken:  import { Suspense } from &quot;react&quot;; import Todo from &quot;@/components/Todo&quot;; const TodosPage = () =&gt; { return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;Loading todo 1...&lt;/div&gt;}&gt; &lt;Todo id=&quot;1&quot; /&gt; &lt;/Suspense&gt; &lt;Suspense fallback={&lt;div&gt;Loading todo 2...&lt;/div&gt;}&gt; &lt;Todo id=&quot;2&quot; /&gt; &lt;/Suspense&gt; &lt;Suspense fallback={&lt;div&gt;Loading todo 3...&lt;/div&gt;}&gt; &lt;Todo id=&quot;3&quot; /&gt; &lt;/Suspense&gt; &lt;/div&gt; ); } export default TodosPage;   Nu zal elke Todo component zijn eigen loading indicator tonen terwijl de data aan het laden is. Dit zorgt voor een betere gebruikerservaring omdat de gebruiker meteen ziet dat er iets aan het gebeuren is. Vaak wordt er een skeleton loader gebruikt in plaats van een simpele tekst. Een skeleton is een grijze placeholder die de vorm van de content nabootst. Dit geeft de gebruiker een beter idee van wat er gaat komen. Je kan deze mee in de component zelf zetten en exporteren:  export const TodoSkeleton = () =&gt; { return ( &lt;div className=&quot;p-4 border border-gray-200 rounded shadow-sm animate-pulse&quot;&gt; &lt;h2 className=&quot;text-xl font-semibold mb-2 bg-gray-300 h-6 w-1/3 rounded&quot;&gt;&lt;/h2&gt; &lt;p className=&quot;bg-gray-300 h-4 w-1/4 rounded mb-2&quot;&gt;&lt;/p&gt; &lt;p className=&quot;bg-gray-300 h-4 w-3/4 rounded mb-2&quot;&gt;&lt;/p&gt; &lt;p className=&quot;bg-gray-300 h-4 w-1/2 rounded&quot;&gt;&lt;/p&gt; &lt;/div&gt; ) }   Dan kan je deze gebruiken als fallback in Suspense:  import { Suspense } from &quot;react&quot;; import Todo, { TodoSkeleton } from &quot;@/components/Todo&quot;; const TodosPage = () =&gt; { return ( &lt;div&gt; &lt;Suspense fallback={&lt;TodoSkeleton /&gt;}&gt; &lt;Todo id=&quot;1&quot; /&gt; &lt;/Suspense&gt; &lt;Suspense fallback={&lt;TodoSkeleton /&gt;}&gt; &lt;Todo id=&quot;2&quot; /&gt; &lt;/Suspense&gt; &lt;Suspense fallback={&lt;TodoSkeleton /&gt;}&gt; &lt;Todo id=&quot;3&quot; /&gt; &lt;/Suspense&gt; &lt;/div&gt; ); } export default TodosPage;   ","version":"Next","tagName":"h3"},{"title":"Combineren van Server en Client Components​","type":1,"pageTitle":"Server Components","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr#combineren-van-server-en-client-components","content":" Het is perfect mogelijk om server en client components te combineren in een Next.js applicatie. Een goede vuistregel is om zoveel mogelijk server components te gebruiken en alleen client components te maken als het echt nodig is. Dit zorgt ervoor dat je applicatie snel laadt en dat de hoeveelheid JavaScript die naar de browser gestuurd wordt minimaal is.  Zo kan je bijvoorbeeld een server component maken dat data ophaalt en deze data doorgeven aan een client component dat de data toont.  import { User } from &quot;@/types&quot;; import UserCard from &quot;@/components/UserCard&quot;; const fetchUsers = async() =&gt; { const response = await fetch(&quot;https://jsonplaceholder.typicode.com/users&quot;, { cache: &quot;no-store&quot; });); const data : User[] = await response.json(); return data; } const Home = async() =&gt; { const users = await fetchUsers(); return ( &lt;div&gt; &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;User List&lt;/h1&gt; { users.map(user =&gt; ( &lt;UserCard key={user.id} user={user} /&gt;)) } &lt;/div&gt; ) } export default Home;   en  &quot;use client&quot; import { User } from &quot;@/types&quot;; interface UserCardProps { user: User; } const UserCard = ({ user }: UserCardProps) =&gt; { return ( &lt;div className=&quot;mb-4 p-4 border border-gray-200 rounded&quot;&gt; {user.name} &lt;/div&gt; ) } export default UserCard;   Op dit moment is het uiteraard niet nodig om deze component als client component te maken, maar stel dat je toch interactiviteit wil toevoegen, dan is dit perfect mogelijk. Zonder interactie mag je de &quot;use client&quot; regel weglaten en wordt het een server component.  Bijvoorbeeld als we de user card klikbaar willen maken met een onClick event handler en willen aanduiden dat deze geselecteerd is:  &quot;use client&quot; import { User } from &quot;@/types&quot;; import { useState } from &quot;react&quot;; interface UserCardProps { user: User } const UserCard = ({user} : UserCardProps) =&gt; { const [selected, setSelected] = useState(false); return ( &lt;div key={user.id} className={`mb-4 p-4 border ${selected ? &quot;border-blue-500 bg-blue-50&quot; : &quot;border-gray-200&quot;} rounded cursor-pointer`} onClick={() =&gt; setSelected(selected =&gt; !selected)}&gt;{ user.name }&lt;/div&gt; ) } export default UserCard;   De Home component blijft een server component die de data ophaalt en de UserCard component is een client component die de interactiviteit afhandelt.  ","version":"Next","tagName":"h3"},{"title":"Use case: MongoDB​","type":1,"pageTitle":"Server Components","url":"/webframeworks-cursus/wf-course/nextjs/csr-ssr#use-case-mongodb","content":" Een veel voorkomende use case voor server components is het ophalen van data uit een database. We hebben in vorige cursus gezien dat als we data uit een database willen ophalen, dat we daar een backend server voor nodig hebben zoals Express.js. In Next.js is dit niet nodig omdat we server components kunnen gebruiken om direct data uit een database op te halen. Dit kan bijvoorbeeld met MongoDB.  Stel dat je de volgende database.ts file hebt die de connectie met MongoDB afhandelt:  import { Collection, MongoClient } from &quot;mongodb&quot;; import { Joke } from &quot;./types&quot;; const client = new MongoClient(process.env.MONGODB_URI!); export const jokesCollection: Collection&lt;Joke&gt; = client.db(&quot;jokes&quot;).collection&lt;Joke&gt;(&quot;joke&quot;); export const getJokes = async() =&gt; { await jokesCollection.deleteMany({}); if (await jokesCollection.countDocuments() === 0) { const response = await fetch(&quot;https://sampleapis.assimilate.be/jokes/goodJokes&quot;); const json : Joke[] = await response.json(); await jokesCollection.insertMany(json); } const jokes = await jokesCollection.find().toArray(); return jokes; }   We kunnen deze functie getJokes nu gebruiken in een server component om de data op te halen en te tonen:  import { getJokes } from &quot;@/database&quot;; const JokesPage = async() =&gt; { const jokes = await getJokes(); return ( &lt;div className=&quot;p-4&quot;&gt; &lt;h1 className=&quot;text-2xl font-bold mb-4&quot;&gt;Jokes Page&lt;/h1&gt; &lt;ul className=&quot;space-y-4&quot;&gt; {jokes.map((joke) =&gt; ( &lt;li key={joke.id} className=&quot;border p-4 rounded shadow&quot;&gt; &lt;h2 className=&quot;text-xl font-semibold&quot;&gt;{joke.setup}&lt;/h2&gt; &lt;p className=&quot;mt-2 text-gray-700&quot;&gt;{joke.punchline}&lt;/p&gt; &lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; ) } export default JokesPage;  ","version":"Next","tagName":"h2"},{"title":"Communicatie tussen componenten","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/child-parent","content":"Communicatie tussen componenten","keywords":"","version":"Next"},{"title":"Projecten","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/opdrachten","content":"Projecten","keywords":"","version":"Next"},{"title":"Componenten","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/componenten","content":"Componenten Tot nu toe had je altijd maar 1 functie: de App functie. Het is mogelijk alle code onder te brengen in deze functie, maar dan is het niet meer mogelijk (bijvoorbeeld in een later project) een onderdeeltje van de applicatie te herbruiken. Het is beter de applicatie op te splitsen in kleine herbruikbare blokjes. Deze herbruikbare blokjes heten componenten. We illustreren dit met onderstaande applicatie, die een lijst van games toont: const App = () =&gt; { return ( &lt;div&gt; &lt;h1&gt;Welcome to the H2O Game shop&lt;/h1&gt; &lt;div&gt;{games.map((game: Game) =&gt; { return &lt;React.Fragment key={game.id}&gt; &lt;h2&gt;{game.name} ({game.releaseYear})&lt;/h2&gt; &lt;p&gt;Aantal keer verkocht: {game.sales}&lt;/p&gt; &lt;/React.Fragment&gt; })} &lt;/div&gt; &lt;/div&gt; ); } notitie Deze applicatie is niet erg interactief, dus je zou ze als statische HTML-pagina kunnen schrijven. Uitgebreidere code zou de lijst met games uit een database kunnen inladen of zou het mogelijk maken games toe te voegen,... De lijst met games is een deel van de website dat als één geheel beschouwd kan worden. Daarom is het zinvol deze af te zonderen in een component. We noemen deze List: const List = () =&gt; { return ( &lt;div&gt; {games.map((game: Game) =&gt; { return &lt;React.Fragment key={game.id}&gt; &lt;h2&gt;{game.name} ({game.releaseYear})&lt;/h2&gt; &lt;p&gt;Aantal keer verkocht: {game.sales}&lt;/p&gt; &lt;/React.Fragment&gt; })} &lt;/div&gt; ); } const App = () =&gt; { return ( &lt;div&gt; &lt;h1&gt;Welcome to the H2O Game shop&lt;/h1&gt; &lt;List/&gt; &lt;/div&gt; ); } Een component is hier geschreven als functie die TSX teruggeeft als returnwaarde. We hebben deze TSX verplaatst van de App component naar de List component. De component gebruiken in App kan door hem te behandelen als een HTML-tag. Daarom staat er &lt;List /&gt;.","keywords":"","version":"Next"},{"title":"Folder structuur","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/componenten/opsplitsen","content":"","keywords":"","version":"Next"},{"title":"Aparte bestanden per component​","type":1,"pageTitle":"Folder structuur","url":"/webframeworks-cursus/wf-course/react/componenten/opsplitsen#aparte-bestanden-per-component","content":" Een eerste verbetering bestaat erin elke component in een eigen bestand te plaatsen. Componenten kunnen dan op dezelfde manier geïmporteerd worden als andere functies. Indien er bijvoorbeeld componenten App, Header, List en ListItem zijn, worden deze ondergebracht in App.tsx, List.tsx en ListItem.tsx.  We bekomen een structuur die er als volgt uitziet:  - src --- App.tsx --- List.tsx --- ListItem.tsx --- types.ts   Het bestand List.tsx ziet er dan als volgt uit:  import ListItem from &quot;./ListItem&quot;; import { Game } from &quot;./types&quot;; interface ListProps { games: Game[] } const List = ({games}: ListProps) =&gt; { return ( &lt;div&gt; {games.map((game: Game) =&gt; { return &lt;ListItem key={game.id} game={game}/&gt; })} &lt;/div&gt; ); } export default List;   We zorgen met de laatste lijn dat we de List component exporteren zodat andere bestanden die kunnen importeren. Je ziet hierboven ook hoe dat importeren in zijn werk zal gaan. Je ziet dat hier het keyword default bij de export wordt gezet. Dit is nodig zodat je de componenten kan importeren op de volgende manier.  import ListItem from &quot;./ListItem&quot;;   Soms zie je ook de syntax met in de import. Dit wil zeggen dat er meerdere functies, variabelen,... worden geëxporteerd in een bestand. Een goed voorbeeld hiervan is een nieuw bestand dat we hebben aangemaakt voor alle types in te beschrijven. We hebben alle types die met het model te maken hebben in 1 bestand gezet: types.ts.  Op dit moment staat daar 1 interface in, maar het is uiteraard niet ondenkbaar dat daar meerdere interfaces zullen zitten. We exporteren dus elke interface apart.  export interface Game { id?: number name: string, releaseYear: number, sales: number }   ","version":"Next","tagName":"h2"},{"title":"Van component files naar React folders​","type":1,"pageTitle":"Folder structuur","url":"/webframeworks-cursus/wf-course/react/componenten/opsplitsen#van-component-files-naar-react-folders","content":" Naarmate een project groeit, worden componenten complexer. Er worden styles en tests toegevoegd. Je zou de vorige structuur kunnen blijven volgen en deze bestanden naast de component bestanden plaatsen. Vaak worden deze bestanden ook nog in een folder components geplaatst om het onderscheid te maken met andere code. De bestandenstructuur ziet er dan bijvoorbeeld zo uit:  src └── components ├── App.css ├── App.test.tsx ├── App.tsx ├── List.css ├── List.test.tsx └── List.tsx   Op termijn is deze aanpak niet houdbaar. Daarom verkiest men bij grotere projecten vaak één directory per component, als volgt:  src └── components ├── App │ ├── App.css │ ├── App.test.tsx │ └── App.tsx └── List ├── List.css ├── List.test.tsx └── List.tsx   De bestandsnamen in dit voorbeeld zijn zuiver ter illustratie. Afhankelijk van het gebruikte test framework, de techniek om componenten te stylen enzovoort kunnen er andere afspraken gevolgd worden. Hoe dan ook staan folders toe tijdens het ontwikkelen niet-relevante bestanden te verbergen.  In sommige gevallen horen componenten sterk samen. In het voorbeeld bovenaan deze pagina werd gebruikt gemaakt van ListItem. Deze wordt enkel gebruikt als onderdeel van de List component. Meestal worden zo'n componenten samen in één folder geplaatst, als volgt:  src └── components ├── App │ ├── App.css │ ├── App.test.tsx │ └── App.tsx └── List ├── List.css ├── List.test.tsx ├── List.tsx ├── ListItem.css ├── ListItem.test.tsx └── ListItem.tsx  ","version":"Next","tagName":"h2"},{"title":"Props","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/componenten/props","content":"","keywords":"","version":"Next"},{"title":"String doorgeven als property​","type":1,"pageTitle":"Props","url":"/webframeworks-cursus/wf-course/react/componenten/props#string-doorgeven-als-property","content":" Stel dat je een component hebt dat een gekleurd vierkant toont:  const ColorSquare = () =&gt; { return &lt;div style={{width: 100, height: 100, backgroundColor: 'red'}}/&gt; } const App = () =&gt; { return &lt;ColorSquare/&gt; }   Willen we het ColorSquare component ook gebruiken voor blauwe vierkanten moeten we een nieuwe property: color aanmaken:  interface ColorSquareProps { color: string } const ColorSquare = (props: ColorSquareProps) =&gt; { return &lt;div style={{width: 100, height: 100, backgroundColor: props.color}}/&gt; } const App = () =&gt; { return ( &lt;&gt; &lt;ColorSquare color=&quot;blue&quot;/&gt; &lt;ColorSquare color=&quot;red&quot;/&gt; &lt;/&gt; ); }   Hier zie je een aantal dingen:  ColorSquare krijgt een argument: props bij met het type ColorSquareProps. Hier zitten alle properties die worden doorgegeven aan de ColorSquare component.In TypeScript voorzien we altijd types voor elk object, dit is ook zo voor het props object.We halen de color property uit het props object aan de hand van de dot notatie.Properties worden doorgegeven zoals elk HTML attribuut.  ","version":"Next","tagName":"h2"},{"title":"Expressies doorgeven als property​","type":1,"pageTitle":"Props","url":"/webframeworks-cursus/wf-course/react/componenten/props#expressies-doorgeven-als-property","content":" We kunnen ook de grootte van onze ColorSquare doorgeven aan de hand van props:  interface ColorSquareProps { color: string; size: number } const ColorSquare = (props: ColorSquareProps) =&gt; { return &lt;div style={{width: props.size, height: props.size, backgroundColor: props.color}}/&gt; } const App = () =&gt; { return &lt;ColorSquare color=&quot;blue&quot; size={200}/&gt; }   Belangrijk hier is dat getallen doorgegeven worden tussen accolades en niet tussen dubbele quotes.  Dit geldt ook voor alle andere soorten expressies. Wil je bijvoorbeeld werken met variabelen dan moeten deze ook tussen accolades staan.  const App = () =&gt; { let color: string = &quot;blue&quot;; let size: number = 200; return &lt;ColorSquare color={color} size={size}/&gt; }   ","version":"Next","tagName":"h2"},{"title":"Destructuring props​","type":1,"pageTitle":"Props","url":"/webframeworks-cursus/wf-course/react/componenten/props#destructuring-props","content":" Om je code te vereenvoudigen kan je gebruik maken van object destructuring om de properties al uit het props object te halen.  const ColorSquare = ({size, color}: ColorSquareProps) =&gt; { return &lt;div style={{width: size, height: size, backgroundColor: color}}/&gt; }   Op deze manier moeten we dus niet elke keer de property uit het props object halen.  ","version":"Next","tagName":"h2"},{"title":"Interface vervangen door type alias​","type":1,"pageTitle":"Props","url":"/webframeworks-cursus/wf-course/react/componenten/props#interface-vervangen-door-type-alias","content":" We hebben hiervoor aangegeven dat je altijd een interface moet aanmaken voor elk component. We kunnen dit ook in de functie declaratie zelf doen.  const ColorSquare = ({size, color}: {color: string, size: number}) =&gt; { return &lt;div style={{width: size, height: size, backgroundColor: color}}/&gt; }   ","version":"Next","tagName":"h2"},{"title":"H2O Game Shop​","type":1,"pageTitle":"Props","url":"/webframeworks-cursus/wf-course/react/componenten/props#h2o-game-shop","content":" We grijpen nu even terug naar ons voorbeeld van de games winkel die we aan het opbouwen zijn.  Op dit moment hebben we nog altijd onze data die we gebruiken voor onze lijst in een globale variabele gestoken in de huidige applicatie. Het is uiteraard niet houdbaar om alles in globale variabelen te steken en deze zo te delen onder verschillende componenten. De juiste manier om dit te doen in React is deze lijst of andere variabelen door te geven als props of properties. We geven dus informatie door van het ene component naar de andere.  Voordat we props voor de eerste keer gaan gebruiken in onze applicatie gaan we eerst onze lijst van games verplaatsen naar het App component zelf.  const App = () =&gt; { const games : Game[] = [ //... ]; return ( &lt;div&gt; &lt;h1&gt;Welcome to the H2O Game shop&lt;/h1&gt; &lt;List/&gt; &lt;/div&gt; ); }   Nu geeft uiteraard de List component een foutmelding omdat de games variabele niet meer globaal staat en dit component dus geen toegang heeft tot deze lijst. We gaan dit oplossen door de games variabele door te geven aan de List component aan de hand van een games property.  interface ListProps { games: Game[] } const List = ({games}: ListProps) =&gt; { return ( &lt;div&gt; {games.map((game: Game) =&gt; { return &lt;React.Fragment key={game.id}&gt; &lt;h2&gt;{game.name} ({game.releaseYear})&lt;/h2&gt; &lt;p&gt;Aantal keer verkocht: {game.sales}&lt;/p&gt; &lt;/React.Fragment&gt; })} &lt;/div&gt; ); } const App = () =&gt; { const games : Game[] = [ //... ]; return ( &lt;div&gt; &lt;h1&gt;Welcome to the H2O Game shop&lt;/h1&gt; &lt;List games={games}/&gt; &lt;/div&gt; ); }   Nu kunnen we onze kennis over props gaan gebruiken om onze List component nog verder op te splitsen in kleinere componenten als we dit willen. Zo kunnen we een ListItem introduceren die verantwoordelijk is voor het tonen van 1 item van de lijst.  interface ListItemProps { game: Game } const ListItem = ({game} : ListItemProps) =&gt; { return ( &lt;React.Fragment&gt; &lt;h2&gt;{game.name} ({game.releaseYear})&lt;/h2&gt; &lt;p&gt;Aantal keer verkocht: {game.sales}&lt;/p&gt; &lt;/React.Fragment&gt; ) } const List = ({games}: ListProps) =&gt; { return ( &lt;div&gt; {games.map((game: Game) =&gt; { return &lt;ListItem key={game.id} game={game}/&gt; })} &lt;/div&gt; ); }   Het gebeurt vaak dat props doorheen meerdere componenten worden doorgegeven. Indien je componenten structuur dieper en dieper wordt, wordt het ook altijd maar minder praktisch om dingen te gaan blijven doorgeven aan de hand van properties. We zien later nog hoe we dit probleem kunnen oplossen. ","version":"Next","tagName":"h2"},{"title":"Context","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/child-parent/context","content":"","keywords":"","version":"Next"},{"title":"Delen van data via context​","type":1,"pageTitle":"Context","url":"/webframeworks-cursus/wf-course/react/child-parent/context#delen-van-data-via-context","content":" In een React applicatie wordt data van het bovenste component doorgegeven naar het onderste component aan de hand van props. Dit is mogelijk in een applicatie waar de component structuur niet heel diep is, maar naar mate de applicatie groeit, groeit meestal ook de diepte van je componenten structuur. Je zal dan vaak een prop verschillende niveau's diep moeten doorgeven. Dit concept heet property drilling, en is in grote applicaties niet wenselijk.    Stel dat we een light theme en een dark theme willen ondersteunen in onze applicatie. Elk component heeft deze prop nodig want elk component moet zijn UI aanpassen als de theme light of dark is.  Hieronder kan je een voorbeeld hiervan zien:  const ComponentA = ({ theme }: { theme: string }) =&gt; { return ( &lt;div style={getThemeStyle(theme, &quot;red&quot;)}&gt; &lt;ComponentB theme={theme} /&gt; &lt;/div&gt; ); }; const ComponentB = ({ theme }: { theme: string }) =&gt; { return ( &lt;div style={getThemeStyle(theme, &quot;green&quot;)}&gt; &lt;ComponentC theme={theme} /&gt; &lt;/div&gt; ); }; const ComponentC = ({ theme }: { theme: string }) =&gt; { return ( &lt;div style={getThemeStyle(theme, &quot;blue&quot;)}&gt; &lt;ComponentD theme={theme} /&gt; &lt;/div&gt; ); }; const ComponentD = ({ theme }: { theme: string }) =&gt; { return &lt;p style={{color: theme === &quot;dark&quot; ? &quot;white&quot; : &quot;black&quot;}}&gt;{theme}&lt;/p&gt;; }; const App = () =&gt; { const [theme, setTheme] = useState(&quot;light&quot;); return ( &lt;&gt; &lt;button onClick={()=&gt;{ setTheme(theme =&gt; theme == &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot;)}}&gt;Toggle theme!&lt;/button&gt; &lt;ComponentA theme={theme} /&gt; &lt;/&gt; ); };   Je ziet dat zelfs voor een kleine applicatie, zoals die hierboven, dat we deze theme prop al moeten doorgeven doorheen 3 niveaus van componenten. Bij grotere applicaties gaat dit nog veel erger worden. Daarom heeft React voor de Context API gezorgd. Dit is een manier om data te gaan delen doorheen componenten zonder door heel de structuur te moeten doorgegeven worden. Dit is zeer handig als de tussenliggende lagen geen nood hebben aan deze data. Deze hoeven dan ook niet de context te gebruiken.    Het eerste wat we moeten doen is een Context aanmaken aan de hand van de createContext  interface IThemeContext { theme: string } export const ThemeContext = React.createContext&lt;IThemeContext&gt;({theme: 'light'});   Je moet altijd een default waarde meegeven aan de context. Deze default waarde wordt enkel gebruikt als er geen provider aanwezig is bovenaan in de component structuur. We geven hier een object met een mode property. Dus in ons geval zal onze layout dus standaard in light mode staan.  Nu moeten we een Provider maken van onze ThemeContext zodat we de values kunnen meegeven die we in de componenten willen gebruiken. De provider moet rond de bovenste component staan die onze context willen gebruiken.  const App = () =&gt; { const [theme, setTheme] = useState(&quot;light&quot;); return ( &lt;ThemeContext.Provider value={{theme: theme}}&gt; &lt;...&gt; &lt;/...&gt; &lt;/ThemeContext.Provider&gt; ); };   Nu kan je de values van de ThemeContext provider opvragen aan de hand van de useContext hook.  const ComponentA = () =&gt; { const {theme} = useContext(ThemeContext); return ( &lt;div style={getThemeStyle(theme, &quot;red&quot;)}&gt; &lt;ComponentB/&gt; &lt;/div&gt; ); }; const ComponentB = () =&gt; { const {theme} = useContext(ThemeContext); return ( &lt;div style={getThemeStyle(theme, &quot;green&quot;)}&gt; &lt;ComponentC /&gt; &lt;/div&gt; ); }; const ComponentC = () =&gt; { const {theme} = useContext(ThemeContext); return ( &lt;div style={getThemeStyle(theme, &quot;blue&quot;)}&gt; &lt;ComponentD /&gt; &lt;/div&gt; ); }; const ComponentD = () =&gt; { const {theme} = useContext(ThemeContext); return &lt;p style={{color: theme === &quot;dark&quot; ? &quot;white&quot; : &quot;black&quot;}}&gt;{theme}&lt;/p&gt;; }; const App = () =&gt; { const [theme, setTheme] = useState(&quot;light&quot;); return ( &lt;ThemeContext.Provider value={{theme: theme}}&gt; &lt;&gt; &lt;button onClick={()=&gt;{ setTheme(theme =&gt; theme == &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot;)}}&gt;Toggle theme!&lt;/button&gt; &lt;ComponentA /&gt; &lt;/&gt; &lt;/ThemeContext.Provider&gt; ); };   Je ziet nu dat elk component toegang heeft tot de mode variabele die we in de context hebben aangeboden zonder dat we deze moeten doorgeven doorheen de component hierarchie.  ","version":"Next","tagName":"h2"},{"title":"Functies in context​","type":1,"pageTitle":"Context","url":"/webframeworks-cursus/wf-course/react/child-parent/context#functies-in-context","content":" We kunnen ook functies toevoegen in onze ThemeContext zodat we bijvoorbeeld ook vanuit elk component de theme kunnen aanpassen. We voegen nu aan de createContext functie een setMode functie toe. We moeten hier een default value voor aanbieden, op dit moment hebben we nog geen handler dus we geven een lege functie mee.  interface IThemeContext { theme: string, setTheme: (theme: string) =&gt; void } export const ThemeContext = React.createContext&lt;IThemeContext&gt;({theme: &quot;light&quot;, setTheme: (theme: string) =&gt; {}});   We geven hier bij de createContext een interface mee tussen de &lt;&gt; haken zodat TypeScript weet welke keys er in de context zullen voorkomen en welke types deze hebben.  Als we nu de setTheme functie (van de useState) meegeven aan de provider dan is deze functie beschikbaar in elk component.  const ComponentD = () =&gt; { const {theme,setTheme} = useContext(ThemeContext); return &lt;button onClick={() =&gt; { setTheme(theme === &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot;)}} style={{backgroundColor: theme === &quot;dark&quot; ? &quot;black&quot; : &quot;white&quot;, color: theme === &quot;dark&quot; ? &quot;white&quot; : &quot;black&quot;}}&gt;{theme}&lt;/button&gt;; };   ","version":"Next","tagName":"h2"},{"title":"Data Context​","type":1,"pageTitle":"Context","url":"/webframeworks-cursus/wf-course/react/child-parent/context#data-context","content":" Een veel voorkomend patroon is dat je data vanuit een API ophaalt en deze data dan doorgeeft aan verschillende componenten. Dit kan je doen door de data in de state van de bovenste component te plaatsen en deze dan door te geven aan de onderliggende componenten. Je zou dit kunnen doen aan de hand van props, maar dit is niet altijd even handig. Dit wordt meestal gedaan aan de hand van de Context API.  In dit voorbeeld gaan we gebruik maken van de API op https://jsonplaceholder.typicode.com/posts. Deze API geeft een lijst van posts terug. We maken een interface aan voor een post.  export interface Post { userId: number; id: number; title: string; body: string; }   Om onze code wat overzichtelijker te maken gaan we alle code die te maken heeft met de data van de API in een apart bestand plaatsen. We noemen dit bestand dataContext.tsx.  import React, { useState, useContext, useEffect } from &quot;react&quot;; export interface DataContext { posts: Post[]; loading: boolean; loadData: () =&gt; void; } export const DataContext = React.createContext&lt;DataContext&gt;({posts: [], loading: false, loadData: () =&gt; {}}); export const DataProvider = ({children}: {children: React.ReactNode}) =&gt; { const [posts, setPosts] = useState&lt;Post[]&gt;([]); const [loading, setLoading] = useState&lt;boolean&gt;(false); const loadData = async () =&gt; { setLoading(true); const response = await fetch(&quot;https://jsonplaceholder.typicode.com/posts&quot;); const json = await response.json(); setPosts(json); setLoading(false); } useEffect(() =&gt; { loadData(); }, []); return ( &lt;DataContext.Provider value={{posts: posts, loadData: loadData, loading: loading}}&gt; {children} &lt;/DataContext.Provider&gt; ) }   In de DataProvider component maken we een state aan voor de posts. We maken ook een functie aan om de data op te halen van de API. Deze functie wordt aangeroepen in de useEffect hook zodat de data wordt opgehaald als de component gemount wordt. We geven de posts en de loadData functie mee aan de provider zodat deze beschikbaar zijn in de onderliggende componenten. We voorzien ook een loading property zodat we kunnen zien of de data aan het laden is of niet.  Nu kunnen we de DataProvider component gebruiken in onze App component. Je kan zien dat het nu zeer eenvoudig is de data te gebruiken in de onderliggende componenten. We moeten enkel de useContext hook gebruiken om de data op te halen.  const ReloadButton = () =&gt; { const { loadData, loading } = useContext(DataContext); return ( &lt;button disabled={loading} onClick={() =&gt; loadData()}&gt;reload&lt;/button&gt; ) } const PostList = () =&gt; { const { posts } = useContext(DataContext); return ( &lt;div&gt; &lt;h1&gt;Posts&lt;/h1&gt; &lt;ul&gt; {posts.map((post, index) =&gt; ( &lt;li key={index}&gt;{post.title}&lt;/li&gt; ))} &lt;/ul&gt; &lt;/div&gt; ) } const App = () =&gt; { return ( &lt;DataProvider&gt; &lt;ReloadButton/&gt; &lt;PostList/&gt; &lt;/DataProvider&gt; ) }   Het is ook mogelijk om functies toe te voegen om de data te gaan aanpassen. Zo kan je functies voorzien om posts toe te voegen, te verwijderen of te updaten. Deze functies worden dan ook meegegeven aan de provider zodat deze beschikbaar zijn in de onderliggende componenten. Je kan dit in de array zelf doen of een POST request maken naar een backend.  const createPost = async (post: Post) =&gt; { setPosts([...posts, post]); await fetch(&quot;https://jsonplaceholder.typicode.com/posts&quot;, { method: &quot;POST&quot;, body: JSON.stringify(post), headers: { &quot;Content-type&quot;: &quot;application/json; charset=UTF-8&quot; } }); }   Vergeet niet om de createPost functie mee te geven aan de provider.  &lt;DataContext.Provider value={{posts: posts, loadData: loadData, loading: loading, createPost: createPost}}&gt;   Het volledige voorbeeld kan je hier vinden:  import { DataProvider } from './dataContext'; import ReloadButton from './components/ReloadButton'; import PostForm from './components/PostForm'; import PostList from './components/PostList'; const App = () =&gt; { return ( &lt;DataProvider&gt; &lt;PostForm/&gt; &lt;ReloadButton/&gt; &lt;PostList/&gt; &lt;/DataProvider&gt; ) } export default App  ","version":"Next","tagName":"h2"},{"title":"Callbacks en properties","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/child-parent/props","content":"","keywords":"","version":"Next"},{"title":"Parent, child en siblings​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#parent-child-en-siblings","content":" Vooraleer we gaan bespreken hoe deze componenten gaan kunnen communiceren moeten we even definieren wat parent (ouder), child (kind) en siblings (broers en zussen) zijn.  const ComponentC = () =&gt; { return &lt;div style={StyleC}&gt;&lt;p&gt;Component C&lt;/p&gt;&lt;/div&gt; } const ComponentB = () =&gt; { return &lt;div style={StyleB}&gt;&lt;p&gt;Component B&lt;/p&gt;&lt;/div&gt; } const ComponentA = () =&gt; { return (&lt;div style={StyleA}&gt; &lt;p&gt;Component A&lt;/p&gt; &lt;ComponentB/&gt; &lt;ComponentC/&gt; &lt;/div&gt; ) }   We zeggen hier dat ComponentA de parent is van ComponentB en ComponentC. ComponentB en ComponentC zijn dan de child components van ComponentA. ComponentB en ComponentC noemen we siblings.  ","version":"Next","tagName":"h2"},{"title":"Parent-to-child communicatie​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#parent-to-child-communicatie","content":"   ","version":"Next","tagName":"h2"},{"title":"Via props​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#via-props","content":" We hebben tot nu toe geleerd hoe we data kunnen doorgeven aan een component aan de hand van props. Eigenlijk is dit communicatie tussen het Parent en het Child component.  const Child = ({someProperty}: ChildProps) =&gt; { return &lt;div&gt;{someProperty}&lt;/div&gt; } const Parent = () =&gt; { return &lt;Child someProperty={5}/&gt; }   ","version":"Next","tagName":"h3"},{"title":"Voorbeeld​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#voorbeeld","content":" Stel dat we het uitzicht van de twee child componenten willen aanpassen als we op de parent drukken. Dan kunnen we een property mouseDown toevoegen aan de child components waar we kunnen doorgeven dat het parent component is ingedrukt. Uiteraard hebben we hier ook een state nodig in het parent component om bij te houden dat het component is ingedrukt of niet.  const ComponentC = ({mouseDown} : ChildProps) =&gt; { let style = mouseDown ? {...StyleC, backgroundColor: &quot;red&quot;} : StyleC; return &lt;div style={style}&gt;&lt;p&gt;Component C&lt;/p&gt;&lt;/div&gt; } const ComponentB = ({mouseDown} : ChildProps) =&gt; { let style = mouseDown ? {...StyleB, backgroundColor: &quot;green&quot;} : StyleB; return &lt;div style={style}&gt;&lt;p&gt;Component B&lt;/p&gt;&lt;/div&gt; } const ComponentA = () =&gt; { const [mouseDown, setMouseDown] = useState(false); return (&lt;div style={StyleA} onMouseDown={() =&gt; setMouseDown(true)} onMouseUp={() =&gt; setMouseDown(false)}&gt; &lt;p&gt;Component A&lt;/p&gt; &lt;ComponentB mouseDown={mouseDown}/&gt; &lt;ComponentC mouseDown={mouseDown}/&gt; &lt;/div&gt; ) }   ","version":"Next","tagName":"h3"},{"title":"Child-to-parent communicatie​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#child-to-parent-communicatie","content":"   ","version":"Next","tagName":"h2"},{"title":"Via callback functies​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#via-callback-functies","content":" Willen we nu kunnen communiceren vanuit de child componenten naar de parent component dan is dit iets complexer. De eenvoudigste manier om dit te doen is door een functie door tegeven vanuit de parent naar het child component. Het child component kan die functie dan gebruiken om te communiceren met de parent. Dit concept noemen we callback functies  interface ChildProps { callbackFunction: () =&gt; void } const Child = ({callbackFunction}: ChildProps) =&gt; { return &lt;div&gt;&lt;button onClick={callbackFunction}&gt;Click me&lt;/button&gt;&lt;/div&gt; } const Parent = () =&gt; { return &lt;Child callbackFunction={() =&gt; { console.log(&quot;Child was clicked&quot;); }}/&gt; }   ","version":"Next","tagName":"h3"},{"title":"Voorbeeld​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#voorbeeld-1","content":" We passen het voorbeeld van hiervoor aan zodat de logica nu omgekeerd is. Als we op de child component klikken dan moet de parent component van kleur veranderen. Dus we voorzien een callback onMouse met een argument down die we dan doorgeven aan de child componenten. Als er iemand dan duwt op het child component wordt deze onMouse handler aangeroepen. Deze zorgt ervoor dat de mouseDown state wordt aangepast afhankelijk of de muis ingedrukt is of niet.  interface ChildProps { onMouse: (down: boolean) =&gt; void } const ComponentC = ({onMouse} : ChildProps) =&gt; { return &lt;div onMouseDown={() =&gt; onMouse(true)} onMouseUp={() =&gt; onMouse(false)} style={StyleC}&gt;&lt;p&gt;Component C&lt;/p&gt;&lt;/div&gt; } const ComponentB = ({onMouse} : ChildProps) =&gt; { return &lt;div onMouseDown={() =&gt; onMouse(true)} onMouseUp={() =&gt; onMouse(false)} style={StyleB}&gt;&lt;p&gt;Component B&lt;/p&gt;&lt;/div&gt; } const ComponentA = () =&gt; { const [mouseDown, setMouseDown] = useState(false); const mouseHandler = (down: boolean) =&gt; { setMouseDown(down); } let style = {...StyleA, ...mouseDown ? { backgroundColor: &quot;blue&quot;} : {}} return (&lt;div style={style}&gt; &lt;p&gt;Component A&lt;/p&gt; &lt;ComponentB onMouse={mouseHandler}/&gt; &lt;ComponentC onMouse={mouseHandler}/&gt; &lt;/div&gt; ) }   ","version":"Next","tagName":"h3"},{"title":"Sibling communicatie​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#sibling-communicatie","content":"   Ook communicatie tussen siblings is mogelijk. Dit gebeurt dan via de parent die de staat van beide componenten bij zal houden. Het is een beetje een combinatie van de bovenstaande twee.  interface ChildProps { onMouse: (down: boolean) =&gt; void; mouseDown: boolean; } const ComponentC = ({mouseDown, onMouse} : ChildProps) =&gt; { let style = mouseDown ? {...StyleC, backgroundColor: &quot;red&quot;} : StyleC; return &lt;div style={style} onMouseDown={() =&gt; onMouse(true)} onMouseUp={() =&gt; onMouse(false)}&gt;&lt;p&gt;Component C&lt;/p&gt;&lt;/div&gt; } const ComponentB = ({mouseDown, onMouse} : ChildProps) =&gt; { let style = mouseDown ? {...StyleB, backgroundColor: &quot;green&quot;} : StyleB; return &lt;div style={style} onMouseDown={() =&gt; onMouse(true)} onMouseUp={() =&gt; onMouse(false)}&gt;&lt;p&gt;Component B&lt;/p&gt;&lt;/div&gt; } const ComponentA = () =&gt; { const [mouseDownB, setMouseDownB] = useState(false); const [mouseDownC, setMouseDownC] = useState(false); return (&lt;div style={StyleA}&gt; &lt;p&gt;Component A&lt;/p&gt; &lt;ComponentB mouseDown={mouseDownC} onMouse={(down) =&gt; { setMouseDownB(down)}}/&gt; &lt;ComponentC mouseDown={mouseDownB} onMouse={(down) =&gt; { setMouseDownC(down)}}/&gt; &lt;/div&gt; ) }   ","version":"Next","tagName":"h2"},{"title":"InputView component​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#inputview-component","content":" We kunnen deze dingen nu toepassen op ons InputView child component. Schematisch zal dit als volgt uitzien:    interface InputViewProps { onAddClick: (text: string) =&gt; void }   Vervolgens voegen we deze properties toe aan het InputView component. En zorgen we ervoor dat deze wordt aangeroepen als we op de button klikken. Als argument voor text gebruiken we hier de waarde van de state.  const InputView = ({onAddClick} : InputViewProps) =&gt; { const [text, setText] = useState&lt;string&gt;(''); const handleChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { setText(event.target.value); } const handleClick: React.MouseEventHandler&lt;HTMLButtonElement&gt; = (event) =&gt; { console.log(`InputView.handleClick: ${text}`); onAddClick(text); } return ( &lt;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; onChange={handleChange} value={text}/&gt; &lt;button onClick={handleClick}&gt;Add&lt;/button&gt; &lt;/&gt; ); }   Nu kan je de functie die verantwoordelijk is voor de onAddClick af te handelen gewoon doorgeven aan de hand van een property en het argument afprinten op onze console.  const App = () =&gt; { return ( &lt;div&gt; &lt;InputView onAddClick={(text) =&gt; console.log(`App.onAddClick: ${text}`)}/&gt; &lt;/div&gt; ); }   Uiteraard hadden we deze console.log ook kunnen uitvoeren in ons InputView component dus op dit moment lijkt het allemaal een beetje overbodig.  We voorzien nu een lijst in het App component dat een aantal Todo's zal bijhouden. Dit doen we aan de hand van een state. Het InputView component heeft geen toegang tot die state, dus moet het wel via de callback handler van hierboven gebeuren:  const App = () =&gt; { const [todos, setTodos] = useState&lt;string[]&gt;([]); return ( &lt;div&gt; &lt;ul&gt; {todos.map((todo,i) =&gt; &lt;li key={i}&gt;{todo}&lt;/li&gt;)} &lt;/ul&gt; &lt;InputView onAddClick={(text) =&gt; setTodos(todos =&gt; [...todos, text])}/&gt; &lt;/div&gt; ); }   ","version":"Next","tagName":"h2"},{"title":"SetState functie doorgeven​","type":1,"pageTitle":"Callbacks en properties","url":"/webframeworks-cursus/wf-course/react/child-parent/props#setstate-functie-doorgeven","content":" Hier bestaat ook nog een andere variant voor die we kunnen gebruiken. We zouden ook de setter van de state en de waarde van de state zelf kunnen doorgeven als properties aan de InputView zodat deze toch toegang heeft tot deze functie (en waarde):  interface InputViewProps { todos: string[]; setTodos: (todos: string[]) =&gt; void } const InputView = ({todos, setTodos} : InputViewProps) =&gt; { const [text, setText] = useState&lt;string&gt;(''); const handleChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { setText(event.target.value); } const handleClick: React.MouseEventHandler&lt;HTMLButtonElement&gt; = (event) =&gt; { console.log(`InputView: handleClick(${text})`); setTodos([...todos, text]) } return ( &lt;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; onChange={handleChange} value={text}/&gt; &lt;button onClick={handleClick}&gt;Add&lt;/button&gt; &lt;/&gt; ); } const App = () =&gt; { const [todos, setTodos] = useState&lt;string[]&gt;([]); return ( &lt;div&gt; &lt;ul&gt; {todos.map((todo,i) =&gt; &lt;li key={i}&gt;{todo}&lt;/li&gt;)} &lt;/ul&gt; &lt;InputView setTodos={setTodos} todos={todos}/&gt; &lt;/div&gt; ); }  ","version":"Next","tagName":"h2"},{"title":"React app aanmaken","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/create-react-app","content":"","keywords":"","version":"Next"},{"title":"Vite​","type":1,"pageTitle":"React app aanmaken","url":"/webframeworks-cursus/wf-course/react/create-react-app#vite","content":" Er zijn verschillende manieren om een react applicatie aan te maken. Je kan gebruik maken van een volledig react framework zoals next.js of gatsby.js. Deze frameworks zijn heel krachtig en bieden veel functionaliteit aan. Maar soms is het ook handig om een eenvoudige react applicatie aan te maken zonder al te veel configuratie.  In deze cursus gaan we gebruik maken van vite om onze eerste react applicatie aan te maken. Vite is een van de snelste build tools voor het aanmaken van een react applicatie. Het is ook heel eenvoudig in gebruik en bevat een development server die automatisch je applicatie herlaadt wanneer je een wijziging maakt aan je code.  ","version":"Next","tagName":"h2"},{"title":"Een react applicatie aanmaken​","type":1,"pageTitle":"React app aanmaken","url":"/webframeworks-cursus/wf-course/react/create-react-app#een-react-applicatie-aanmaken","content":" Om een react applicatie aan te maken met vite moeten we enkel het volgende commando uitvoeren:  npm create vite@latest   Je zal hier dan een aantal vragen krijgen over de configuratie van je project. Zorg dat je de volgende opties selecteert:  │ ◇ Project name: │ our-first-react-app │ ◇ Select a framework: │ React │ ◇ Select a variant: │ TypeScript + SWC   Project name kies je uiteraard zelf. De andere opties zorgen ervoor dat we een react applicatie aanmaken met typescript. SWC is een snelle JavaScript/TypeScript transpiler die gebruikt wordt door vite.  Je kan ook het commando uitvoeren zonder de vragen te beantwoorden door de volgende opties mee te geven:  npm create vite@latest our-first-react-app -- --template react-ts   Let op het extra -- teken. Dit zorgt ervoor dat de opties niet door npm worden geïnterpreteerd, maar door vite. Zonder ga je toch nog de interactieve modus te zien krijgen.  We kunnen nu de folder our-first-react-app openen in Visual Studio Code en naar de inhoud van het project kijken:    Hier merk je onder andere volgende bestanden en folders in op:  node_modules deze folder bevat alle packages die werden geïnstalleerd bij het runnen van het vite commando. Alle packages die je zelf installeert met npm install zullen ook in deze folder terecht komen. Normaal doe je nooit rechtstreeks aanpassingen in deze folder.package.json beschrijft welke packages geïnstalleerd moeten zijn om deze applicatie uit te voeren. We noemen dit ook de dependencies van de applicatie. Het npm install commando zal deze dependencies dan installeren in de node_modules folder.src bevat de eigenlijke bestanden die rechtstreeks te maken hebben met react. Hier zal jouw broncode in komen. Het belangrijkste bestand op dit moment is het App.tsx bestand. Daar zullen we eerst onze eerste React code schrijven. Later zullen we dit opsplitsen in verschillende bestanden om het overzicht te bewaren.public bevat het HTML-bestand waarin de react applicatie zal getoond worden. Hier moet je meestal niets voor aanpassen want alle visuele componenten worden in react zelf gerenderd. Deze folder bevat ook andere dingen zoals het icoontje dat je in het tabblad van je browser ziet.  Je kan de applicatie opstarten door npm run dev uit te voeren in je terminal venster. Als alles in orde is zal je browser automatisch openen op de eerste en enige pagina van jouw webapplicatie:    info Als je problemen hebt met het bereiken van de applicatie vanuit een devcontainer kan je de package.json aanpassen. Voeg de volgende regel aanpassen in de scripts sectie: &quot;dev&quot;: &quot;vite --host&quot;,   ","version":"Next","tagName":"h2"},{"title":"Je eerste component​","type":1,"pageTitle":"React app aanmaken","url":"/webframeworks-cursus/wf-course/react/create-react-app#je-eerste-component","content":" Alle React applicaties zijn gebouwd uit verschillende React componenten. Componenten stellen afgebakende stukjes van de applicatie voor. Ze worden in moderne React code uitgedrukt als functies. Ze accepteren invoerwaarden (deze noemen we “props”) en geven een beschrijving terug van wat er in de gegenereerde pagina zou moeten staan. Met componenten splits je de UI in onafhankelijke, herbruikbare delen.  Het eerste component waar je altijd mee in aanraking zal komen kan je vinden in het src/App.tsx bestand. Deze zal er een beetje zoals het onderstaand bestand uitzien:  import { useState } from 'react' import reactLogo from './assets/react.svg' import viteLogo from '/vite.svg' import './App.css' function App() { const [count, setCount] = useState(0) return ( &lt;&gt; &lt;div&gt; &lt;a href=&quot;https://vite.dev&quot; target=&quot;_blank&quot;&gt; &lt;img src={viteLogo} className=&quot;logo&quot; alt=&quot;Vite logo&quot; /&gt; &lt;/a&gt; &lt;a href=&quot;https://react.dev&quot; target=&quot;_blank&quot;&gt; &lt;img src={reactLogo} className=&quot;logo react&quot; alt=&quot;React logo&quot; /&gt; &lt;/a&gt; &lt;/div&gt; &lt;h1&gt;Vite + React&lt;/h1&gt; &lt;div className=&quot;card&quot;&gt; &lt;button onClick={() =&gt; setCount((count) =&gt; count + 1)}&gt; count is {count} &lt;/button&gt; &lt;p&gt; Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to test HMR &lt;/p&gt; &lt;/div&gt; &lt;p className=&quot;read-the-docs&quot;&gt; Click on the Vite and React logos to learn more &lt;/p&gt; &lt;/&gt; ) } export default App   info Je bestand heet App.tsx, niet App.ts. Het bevat geen alledaagse TypeScript code. Het maakt ook gebruik van de TSX-syntax, die verderop wordt uitgelegd. Als je de extensie verkeerd invult, zal je een foutmelding krijgen.  We zullen nu even het component herleiden tot de essentie door wat overbodige boilerplate code weg te halen. Zo bekomen we tot een heel eenvoudige Hello world applicatie:  import React from &quot;react&quot;; const App = () =&gt; { return ( &lt;div&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/div&gt; ); }; export default App;   We zien hier een aantal dingen:  We zien hier eigenlijk gewoon een eenvoudige functie. We noemen deze in React geen functie maar een function component. Op deze manier maken we het onderscheid duidelijk met functies die werk verrichten dat niet rechstreeks zichtbaar is.Deze function component heeft geen parameters, maar in verdere delen zullen we zien dat we ook parameters kunnen meegeven aan componenten. Parameters van een component heten props.Deze functie returnt een waarde die genoteerd is in een HTML-achtige syntax. Deze HTML-achtige syntax heet TSX. Ook al ziet dit er grotendeels uit als HTML, is het eigenlijk TypeScript. Om TSX over meerdere regels te kunnen spreiden zonder last te hebben van automatische puntkomma's, zetten we de hele TSX-expressie tussen ronde haakjes.Af en toe zijn er lichte verschillen met echte HTML. Je ziet dit bijvoorbeeld aan het gebruik van className. In echte HTML is dit class.  info Wanneer React gebruikt wordt met JavaScript, spreekt men over JSX in plaats van TSX.  Omdat de component een functie is, kunnen we in de body van de functie alles doen wat onder normale omstandigheden kan in TypeScript functies. We kunnen bijvoorbeeld, voor we de return uitvoeren, variabelen initialiseren en berekeningen uitvoeren:  import React from 'react'; const App = () =&gt; { // we bevinden ons in de body van een TypeScript functie // we kunnen dus variabelen aanmaken zoals anders const title = &quot;World&quot;; return ( &lt;div&gt; &lt;h1&gt;Hello World&lt;/h1&gt; &lt;/div&gt; ); } export default App;  ","version":"Next","tagName":"h3"},{"title":"Hooks","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/hooks","content":"Hooks Componenten ontvangen informatie van hun oudercomponenten via props. Dit biedt de basisstructuur, maar om een interactieve applicatie te ontwikkelen, volstaat het niet alleen data te herbruiken. Het is ook nodig data te kunnen wijzigen of uit te lezen uit andere bronnen dan de props, bijvoorbeeld uit een database of uit de URL. Hiervoor wordt een groep functies gebruikt die we in componenten kunnen integreren. Deze functies heten hooks. We hebben tot nu toe al 1 hook gezien: useState. In dit onderdeel behandelen we er nog een paar interessante.","keywords":"","version":"Next"},{"title":"Styling","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/componenten/stylen","content":"","keywords":"","version":"Next"},{"title":"CSS Modules​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#css-modules","content":" CSS Modules is de aanpak die het dichtst aanleunt bij traditionele css bestanden zoals deze gebruikt worden in statische HTML-pagina's. Alle elementen krijgen een className toegewezen en krijgen een style toegewezen via een CSS bestand.  info In React gebruiken we niet class maar className omdat class een reserved keyword is in TypeScript.  In React willen we dat componenten zo veel mogelijk op zichzelf gebruikt kunnen worden. Zo kan één component zonder aanpassingen in verschillende applicaties gebruikt worden. Daarom maken we per component een apart CSS bestand aan. Het is technisch mogelijk om alles in één algemene file index.css te plaatsen, maar dan is de CSS-code voor één component gekoppeld aan die van alle andere componenten.  ","version":"Next","tagName":"h2"},{"title":"Rechtstreeks importeren​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#rechtstreeks-importeren","content":" Je kan CSS bestanden gebruiken in een React component door deze te importeren op de volgende manier:  import './styles.css';   Bijvoorbeeld de volgende styles.css zorgt voor een rode achtergrond en gele letters voor ons App component.  .App { padding: 10px; background-color: red; color: yellow }   Het nadeel van deze manier is dat we moeten opletten dat al deze CSS bestanden niet dezelfde namen voor klassen gebruiken. Als dit wel gebeurt zullen deze CSS classes met elkaar botsen en zal de ene de andere overschrijven.  ","version":"Next","tagName":"h3"},{"title":"Werken met CSS modules​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#werken-met-css-modules","content":" Om het probleem van herhaalde klassen op te lossen, kunnen we gebruik maken van CSS modules. Het gebruik van modules is zeer gelijkaardig aan dat van gewone CSS bestanden, maar modules zijn geïsoleerd van elkaar. Om gebruik te maken van de CSS Modules moet het CSS bestand de naam krijgen van de component, gevolgd door .module.css  Als we nu gebruik willen maken van CSS modules in de App component, moeten we de CSS file hernoemen naar App.module.css en moeten we de manier van importeren aanpassen als volgt:  import styles from './App.module.css';   In plaats van de className property rechstreeks in te vullen, halen we deze uit het styles object:  import styles from './App.module.css'; const App = () =&gt; { return ( &lt;div className={styles.App}&gt; &lt;h1&gt;Hello component&lt;/h1&gt; &lt;/div&gt; ); } export default App;   info Visual studio code ondersteunt geen auto completion van CSS-Module styles. Je kan wel een plugin hier voor downloaden. https://marketplace.visualstudio.com/items?itemName=clinyong.vscode-css-modules  Wil je meer dan een className toekennen aan een element met CSS modules, dan moet je string interpolation gebruiken:  import styles from './App.module.css'; const App = () =&gt; { return ( &lt;div className={styles.App}&gt; &lt;h1 className={`${styles.red} ${styles.upper}`}&gt;Hello component&lt;/h1&gt; &lt;/div&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"CSS-in-JS​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#css-in-js","content":" De manier van styling die we hierboven hebben toegepast is zeer gelijkaardig aan de werkwijze voor statische HTML-pagina's. In React kan je de styles ook rechtstreeks ook in JavaScript definiëren. Het voordeel van deze manier is dat we niet afhankelijk zijn van aparte CSS-bestanden.  De eerste manier om dit te doen is via inline styles. Je geeft rechtstreeks de styles mee aan de hand van de style property.  const Header = () =&gt; { return ( &lt;h1 style={{fontSize: '22pt', borderBottom: '2px solid black', textTransform: 'uppercase'}}&gt;Welcome to the H2O Game shop&lt;/h1&gt; ); }   Je ziet dat we hier niet de schrijfwijze font-size, border-bottom of text-transform gebruiken, die we wel in een CSS-bestand zouden gebruiken. De regel is hier dat we de camel case varianten gebruiken van CSS properties. Dit komt omdat JavaScript - interpreteert als een minteken en niet als geldig onderdeel van een identifier. Zo wordt bv font-size dus fontSize.  import { CSSProperties } from 'react'; const headerStyle : CSSProperties = { fontSize: '22pt', borderBottom: '2px solid black', textTransform: 'uppercase' } const Header = () =&gt; { return ( &lt;h1 style={headerStyle}&gt;Welcome to the H2O Game shop&lt;/h1&gt; ); }   ","version":"Next","tagName":"h2"},{"title":"Conditionele styling​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#conditionele-styling","content":" Soms wil je een bepaalde stijl toepassen op basis van een bepaalde conditie. Bijvoorbeeld afhankelijk van een bepaalde property. Als we bijvoorbeeld een property toevoegen die aangeeft of we de tekst in hoofdletters willen tonen of niet, kunnen we dit als volgt doen:  interface HeaderProps { uppercase?: boolean } const Header = ({uppercase = true}: HeaderProps) =&gt; { return ( &lt;h1 style={{fontSize: '22pt', borderBottom: '2px solid black', textTransform: uppercase ? 'uppercase' : ''}}&gt;Welcome to the H2O Game shop&lt;/h1&gt; ); } const App = () =&gt; { return ( &lt;&gt; &lt;Header/&gt; &lt;Header uppercase={false}/&gt; &lt;/&gt; ); }   Je kan ook aan de hand van een bepaalde conditie een bepaalde style toevoegen aan een bestaand style object. Dit kan je doen door gebruik te maken van de spread operator.  import { CSSProperties } from 'react'; interface HeaderProps { uppercase?: boolean highlighted?: boolean } const Header = ({uppercase = true, highlighted = false}: HeaderProps) =&gt; { const highlightedStyle : CSSProperties = highlighted ? {backgroundColor: 'yellow'} : {}; const uppercaseStyle : CSSProperties = uppercase ? {textTransform: 'uppercase'} : {}; return ( &lt;h1 style={{fontSize: '22pt', borderBottom: '2px solid black', ...uppercaseStyle, ...highlightedStyle}}&gt;Welcome to the H2O Game shop&lt;/h1&gt; ); } const App = () =&gt; { return ( &lt;&gt; &lt;Header/&gt; &lt;Header uppercase={false}/&gt; &lt;Header highlighted={false}/&gt; &lt;Header uppercase={false} highlighted={true}/&gt; &lt;/&gt; ); }   Dit kan je ook doen met CSS modules. Je kan dan conditioneel bepaalde classes toevoegen aan de className property.  import styles from './App.module.css'; interface HeaderProps { uppercase?: boolean highlighted?: boolean } const Header = ({uppercase = true, highlighted = false}: HeaderProps) =&gt; { return ( &lt;h1 className={`${styles.header} ${uppercase ? styles.upper : ''} ${highlighted ? styles.highlighted : ''}`}&gt;Welcome to the H2O Game shop&lt;/h1&gt; ); } const App = () =&gt; { return ( &lt;&gt; &lt;Header/&gt; &lt;Header uppercase={false}/&gt; &lt;Header highlighted={false}/&gt; &lt;Header uppercase={false} highlighted={true}/&gt; &lt;/&gt; ); }   Dit werkt ook gelijkaardig bij het gebruik van gewone CSS bestanden zonder modules.  ","version":"Next","tagName":"h2"},{"title":"Tailwind CSS​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#tailwind-css","content":" Tailwind CSS is een utility-first CSS framework dat je toelaat om snel en efficiënt stijlen toe te passen op je HTML-elementen door middel van vooraf gedefinieerde klassen. In plaats van aangepaste CSS te schrijven, gebruik je Tailwind's klassen om je elementen te stylen. De laatste jaren is Tailwind CSS enorm populair geworden in de react community vanwege de flexibiliteit en snelheid die het biedt bij het ontwikkelen van gebruikersinterfaces.  De instructies om Tailwind CSS te installeren in een React project kan je vinden op de officiële Tailwind CSS website: https://tailwindcss.com/docs/installation/using-vite  ","version":"Next","tagName":"h2"},{"title":"Voorbeeld​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#voorbeeld","content":" Hier is een eenvoudig voorbeeld van hoe je Tailwind CSS kunt gebruiken in een React component:  const App = () =&gt; { return ( &lt;div className=&quot;min-h-screen bg-gray-100 flex items-center justify-center&quot;&gt; &lt;div className=&quot;bg-white p-8 rounded shadow-md w-full max-w-md&quot;&gt; &lt;h1 className=&quot;text-2xl font-bold mb-4 text-center&quot;&gt;Welcome to the H2O Game shop&lt;/h1&gt; &lt;p className=&quot;text-gray-700 mb-6 text-center&quot;&gt;Find the best games here!&lt;/p&gt; &lt;button className=&quot;w-full bg-blue-500 text-white py-2 px-4 rounded hover:bg-blue-600 transition duration-300&quot;&gt;Shop Now&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"shadcn UI​","type":1,"pageTitle":"Styling","url":"/webframeworks-cursus/wf-course/react/componenten/stylen#shadcn-ui","content":" shadcn UI is een verzameling van herbruikbare, toegankelijke en aanpasbare componenten gebouwd met Tailwind CSS. Het biedt een snelle manier om mooie en functionele gebruikersinterfaces te creëren zonder dat je alles van nul hoeft op te bouwen. De componenten zijn ontworpen om goed samen te werken met Tailwind CSS, waardoor je gemakkelijk je eigen stijlen kunt toevoegen of aanpassen.  De installatie instructies voor shadcn UI (met vite) kan je vinden op de officiële shadcn UI website: https://ui.shadcn.com/docs/installation/vite  Als je snel aan de slag wilt met deze UI componenten kan ook gebruik maken van een starter template:  npx degit similonap/vite-template-react-shadcn react-vite-shadcn   Dit commando maakt een nieuwe map react-vite-shadcn aan met daarin een basis Vite + React project waarin shadcn UI (en tailwindcss) reeds is geïnstalleerd. Je kan dan meteen starten met het bouwen van je applicatie. ","version":"Next","tagName":"h3"},{"title":"Event Handling","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/event-handling","content":"","keywords":"","version":"Next"},{"title":"Text Input​","type":1,"pageTitle":"Event Handling","url":"/webframeworks-cursus/wf-course/react/event-handling#text-input","content":" We gaan nu eens kijken hoe we onze applicatie iets interactiever kunnen maken door de hand van form elementen en event handling. We gaan nu een nieuwe component introduceren genaamd InputView. Deze staat toe een naam en een jaartal in te vullen.  const InputView = () =&gt; { return ( &lt;div&gt; &lt;div style={styles.inputFields}&gt; &lt;label htmlFor=&quot;name&quot;&gt;name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; /&gt; &lt;label htmlFor=&quot;year&quot;&gt;year:&lt;/label&gt; &lt;input type=&quot;number&quot; id=&quot;year&quot; name=&quot;year&quot; min=&quot;1900&quot; max=&quot;2021&quot; /&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; id=&quot;submit&quot; value=&quot;Add Movie&quot; /&gt; &lt;/div&gt; ) }   Hier hebben we één tekstveld voor de naam van de film en een numeriek invoerveld voor het jaartal. We zetten hier een maximum 2021 en een minimum van 1900. Tot nu toe wordt er nog niets gedaan met deze invoervelden.  Om hier iets mee te doen, maken we een functie om iets te doen wanneer er iets ingetypt wordt in het invoerveld. Dit soort functie is een event listener. Verderop in de code zullen we er voor zorgen dat deze functie loopt zodra een bepaald type gebeurtenis (event) zich voordoet.  const handleChange = (event) =&gt; { console.log(event.target.value); }   We kunnen de gewenste interface van de handleChange functie hierboven te weten komen door de muis over de onChange property te plaatsen. Je krijgt dan iets gelijkaardig aan:    We kunnen nu de signatuur handleChange aanpassen om de waarschuwing van hierboven op te lossen.  const handleChange : React.ChangeEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { console.log(event.target.value); }   We kunnen op dezelfde manier een functie maken om een click af te handelen:  const handleClick : React.MouseEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { console.log(&quot;button clicked&quot;); }   Het is ook mogelijk om de event handlers op te geven een anonieme handler functie:  const InputView = () =&gt; { return ( &lt;div&gt; &lt;div style={styles.inputFields}&gt; &lt;label htmlFor=&quot;name&quot;&gt;name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; onChange={(event) =&gt; { console.log(event.target.value); }}/&gt; &lt;label htmlFor=&quot;year&quot;&gt;year:&lt;/label&gt; &lt;input type=&quot;number&quot; id=&quot;year&quot; name=&quot;year&quot; min=&quot;1900&quot; max=&quot;2021&quot; onChange={(event) =&gt; { console.log(event.target.value); }}/&gt; &lt;/div&gt; &lt;input type=&quot;button&quot; id=&quot;submit&quot; value=&quot;Add Movie&quot; onClick={(event) =&gt; { console.log(&quot;button clicked&quot;);}}/&gt; &lt;/div&gt; ) }   Hier ben je niet verplicht een type mee te geven omdat hij zelf het type kan afleiden.  notitie In HTML is er een verschil tussen een input en een change event. Bij React is dit niet het geval. Beide triggeren bij elke wijziging aan het input veld.  ","version":"Next","tagName":"h2"},{"title":"Checkbox​","type":1,"pageTitle":"Event Handling","url":"/webframeworks-cursus/wf-course/react/event-handling#checkbox","content":" Checkbox werkt zeer gelijkaardig aan de andere input elementen. We gebruiken hier ook een onChange handler.  const App = () =&gt; { return ( &lt;&gt; &lt;label&gt; &lt;input type=&quot;checkbox&quot; onChange={(event) =&gt; console.log(event.target.checked)} /&gt; Toggle &lt;/label&gt; &lt;/&gt; ) } export default App;   Het type van deze handler is ook React.ChangeEventHandler&lt;HTMLInputElement&gt;  ","version":"Next","tagName":"h2"},{"title":"Select​","type":1,"pageTitle":"Event Handling","url":"/webframeworks-cursus/wf-course/react/event-handling#select","content":" const App = () =&gt; { return ( &lt;&gt; &lt;label htmlFor=&quot;cars&quot;&gt;Choose a car:&lt;/label&gt; &lt;select id=&quot;cars&quot; name=&quot;cars&quot; onChange={(event) =&gt; console.log(event.target.value)}&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;/&gt; ) } export default App;   Deze handler heeft het type React.ChangeEventHandler&lt;HTMLSelectElement&gt;  ","version":"Next","tagName":"h2"},{"title":"Textarea​","type":1,"pageTitle":"Event Handling","url":"/webframeworks-cursus/wf-course/react/event-handling#textarea","content":" Eigenlijk is een textarea gewoon een input element met een ander type. Het werkt dus op dezelfde manier.  const App = () =&gt; { const handleChange : React.ChangeEventHandler&lt;HTMLTextAreaElement&gt; = (event) =&gt; { console.log(event.target.value); } return ( &lt;&gt; &lt;label htmlFor=&quot;story&quot;&gt;Story:&lt;/label&gt; &lt;textarea id=&quot;story&quot; name=&quot;story&quot; rows={5} cols={33} onChange={handleChange}&gt; &lt;/textarea&gt; &lt;/&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"Form​","type":1,"pageTitle":"Event Handling","url":"/webframeworks-cursus/wf-course/react/event-handling#form","content":" Je kan een formulier ook afhandelen met een onSubmit event. Dit event wordt getriggerd als je op enter drukt in een input veld of als je op een button met type submit klikt. Je kan dan aan de hand van het FormData object de verschillende velden van het formulier uitlezen.  import { FormEvent } from &quot;react&quot;; const MyForm = () =&gt; { const handleSubmit = (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; { event.preventDefault(); const form = event.currentTarget; const formData = new FormData(form); const name = formData.get(&quot;name&quot;); const year = formData.get(&quot;year&quot;); console.log(&quot;Name:&quot;, name); console.log(&quot;Year:&quot;, year); }; return ( &lt;form onSubmit={handleSubmit} style={styles.formStyle}&gt; &lt;label htmlFor=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot; style={styles.inputStyle} /&gt; &lt;label htmlFor=&quot;year&quot;&gt;Year:&lt;/label&gt; &lt;input type=&quot;number&quot; id=&quot;year&quot; name=&quot;year&quot; min=&quot;1900&quot; max=&quot;2021&quot; style={styles.inputStyle} /&gt; &lt;button type=&quot;submit&quot; style={styles.buttonStyle}&gt; Submit &lt;/button&gt; &lt;/form&gt; ); }; export default MyForm;   Even een overzicht van wat hierboven allemaal gebeurt:  We maken een functie handleSubmit die een event van type FormEvent&lt;HTMLFormElement&gt; aanneemt.We roepen de referentie van het formulier op via event.currentTarget.We roepen event.preventDefault() aan om te voorkomen dat de pagina herlaadt bij het versturen van het formulier.We halen het formulier element op via `event.currentTargetWe maken een nieuw FormData object aan met het formulier element.We halen de waarden van de velden op met `formData.get(&quot;veldnaam&quot;)We loggen de waarden naar de console. ","version":"Next","tagName":"h2"},{"title":"Recepten voor React.js","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/recepten","content":"Recepten voor React.js Hier komen extra voorbeelden die gebruik gaan maken van de leerstof die we over verschillende hoofdstukken gezien hebben. Deze voorbeelden horen dus niet bij een bepaald hoofdstuk.","keywords":"","version":"Next"},{"title":"useRef","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/hooks/useRef","content":"","keywords":"","version":"Next"},{"title":"Werking​","type":1,"pageTitle":"useRef","url":"/webframeworks-cursus/wf-course/react/hooks/useRef#werking","content":" Wanneer je wil dat een component een waarde wil onthouden, maar je wil niet dat de component opnieuw gerenderd wordt wanneer die waarde verandert, kan je gebruik maken van de useRef hook. Deze hook is een manier om een waarde te onthouden tussen renders van een component.  Om een useRef te gebruiken, moet je eerst de hook importeren:  import { useRef } from &quot;react&quot;;   In je component kan je dan een useRef aanmaken en initialiseren met een waarde:  const myRef = useRef(initialValue);   Als je dan de waarde van de myRef variabele bekijkt, zal je zien dat het een object bevat met een current eigenschap. Deze eigenschap bevat de waarde die je hebt meegegeven aan useRef:  console.log(myRef.current); // Geeft de waarde van initialValue // { // current: 0 // }   Je kan de waarde van een useRef aanpassen door de current eigenschap te veranderen:  import React, { useRef } from &quot;react&quot;; const App = () =&gt; { const myRef = useRef(0); const handleClick = () =&gt; { myRef.current += 1; console.log(myRef.current); } return ( &lt;&gt; &lt;h1&gt;Counter&lt;/h1&gt; &lt;p&gt;{myRef.current}&lt;/p&gt; &lt;button onClick={handleClick}&gt;Increment&lt;/button&gt; &lt;/&gt; ); } export default App;   Merk op dat wanneer je de waarde van een useRef aanpast er dus geen nieuwe render van het component wordt getriggered. Dus zelfs al verhoog je de waarde van myRef.current, zal de waarde niet opnieuw in de DOM worden geupdated en dus niet op het scherm verschijnen. In de console zal je wel zien dat de waarde van myRef.current is veranderd.  ","version":"Next","tagName":"h2"},{"title":"Toepassingen​","type":1,"pageTitle":"useRef","url":"/webframeworks-cursus/wf-course/react/hooks/useRef#toepassingen","content":" Dit is allemaal leuk en aardig, maar wat kan je nu eigenlijk doen met useRef? Hier zijn enkele toepassingen:  ","version":"Next","tagName":"h2"},{"title":"TimeoutId of intervalId bijhouden​","type":1,"pageTitle":"useRef","url":"/webframeworks-cursus/wf-course/react/hooks/useRef#timeoutid-of-intervalid-bijhouden","content":" Stel dat we een StopWatch component willen maken.  import { useState, useRef } from 'react'; const StopWatch = () =&gt; { const [secondsPassed, setSecondsPassed] = useState(0); const handleStart = () =&gt; { setSecondsPassed(0); setInterval(() =&gt; { setSecondsPassed(passed =&gt; passed + 1); }, 1000); } return ( &lt;&gt; &lt;h1&gt;Seconds passed: {secondsPassed}&lt;/h1&gt; &lt;button onClick={handleStart}&gt; Start &lt;/button&gt; &lt;/&gt; ); } export default StopWatch;   Als we nu deze component willen uitbreiden met een stop knop moeten we de referentie naar de interval bijhouden. We kunnen dit niet in een gewone variabele doen of in de state, omdat dit de component zou triggeren om opnieuw te renderen en dit kan onverwachte gevolgen hebben. We kunnen dit wel doen met een useRef:  import { useState, useRef } from 'react'; const StopWatch = () =&gt; { const [secondsPassed, setSecondsPassed] = useState(0); const intervalRef = useRef&lt;number&gt;(); const handleStart = () =&gt; { setSecondsPassed(0); intervalRef.current = setInterval(() =&gt; { setSecondsPassed(passed =&gt; passed + 1); }, 1000); } const handleStop = () =&gt; { clearInterval(intervalRef.current); } return ( &lt;&gt; &lt;h1&gt;Seconds passed: {secondsPassed}&lt;/h1&gt; &lt;button onClick={handleStart}&gt; Start &lt;/button&gt; &lt;button onClick={handleStop}&gt; Stop &lt;/button&gt; &lt;/&gt; ); } export default StopWatch;   ","version":"Next","tagName":"h3"},{"title":"DOM manipulatie​","type":1,"pageTitle":"useRef","url":"/webframeworks-cursus/wf-course/react/hooks/useRef#dom-manipulatie","content":" Focus op een input element zetten​  Een andere toepassing van useRef is om een referentie naar een DOM element bij te houden. Dit kan handig zijn als je bijvoorbeeld de focus wil zetten op een input element wanneer de component mount:  import { useEffect, useRef } from 'react'; const FocusInput = () =&gt; { const inputRef = useRef&lt;HTMLInputElement&gt;(null); return ( &lt;&gt; &lt;input ref={inputRef} /&gt; &lt;button onClick={() =&gt; { inputRef.current?.focus(); }}&gt; Focus the input &lt;/button&gt; &lt;/&gt; ); } export default FocusInput;   Wat hier gebeurt is dat we een referentie naar de input bijhouden in inputRef. Wanneer de button wordt geklikt, zetten we de focus op de input door de focus methode aan te roepen op inputRef.current.  Video element bedienen​  Een andere toepassing is het bedienen van een video element. Stel dat we een video element hebben en we willen de video pauzeren wanneer de gebruiker op een knop klikt:  import { useState, useRef } from 'react'; const VideoPlayer = () =&gt; { const [isPlaying, setIsPlaying] = useState(false); const ref = useRef(); function handleClick() { const nextIsPlaying = !isPlaying; if (nextIsPlaying) { ref.current.play(); } else { ref.current.pause(); } setIsPlaying(nextIsPlaying); } return ( &lt;&gt; &lt;button onClick={handleClick}&gt; {isPlaying ? 'Pause' : 'Play'} &lt;/button&gt; &lt;video width=&quot;250&quot; ref={ref}&gt; &lt;source src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4&quot; type=&quot;video/mp4&quot; /&gt; &lt;/video&gt; &lt;/&gt; ) } export default VideoPlayer;   Groottes van elementen meten​  Een andere toepassing is het meten van de grootte van een element. Stel dat we een component hebben dat de grootte van een element moet meten en weergeven:  import { useEffect, useRef, useState } from 'react'; const SizeMeasurer = () =&gt; { const [size, setSize] = useState({ width: 0, height: 0 }); const ref = useRef&lt;HTMLDivElement&gt;(null); useEffect(() =&gt; { if (ref.current) { setSize({ width: ref.current.offsetWidth, height: ref.current.offsetHeight }); } }, [ref.current]); return ( &lt;div ref={ref}&gt; &lt;h1&gt;Width: {size.width}&lt;/h1&gt; &lt;h1&gt;Height: {size.height}&lt;/h1&gt; &lt;/div&gt; ); } export default SizeMeasurer;  ","version":"Next","tagName":"h3"},{"title":"useEffect","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect","content":"","keywords":"","version":"Next"},{"title":"Side effects​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#side-effects","content":" Een React component gebruikt props en/of state en bepaalt hiermee een output van het component (renderen van het component). Als het react component lijnen code bevat die niet rechtstreeks bijdragen aan deze output, dan noemen we deze side-effects.  Voorbeelden van side-effects zijn fetch requests (API), DOM manipulaties, gebruiken van timer functies (setTimeout, setInterval), ...  We willen deze side-effect logica zo hard mogelijk scheiden van de de rest van het component. We willen nooit side-effect logica rechtsreeks in het component schrijven. We hebben geen controle over hoeveel keer een component zal worden gerendered. Dit betekent dus als we side-effect logica gewoon in het component zouden schrijven dat deze ook telkens zou worden uitgevoerd als het component gerendered wordt.  interface GreetProps { name: string } const Greet = ({ name } : GreetProps) =&gt; { const message = `Hello, ${name}!`; // Output gerelateerd // Niet doen: document.title = `Greetings to ${name}`; // Side-effect! return &lt;div&gt;{message}&lt;/div&gt;; // Output gerelateerd }   Hoe kunnen we nu er voor zorgen dat de side-effect losgekoppeld wordt van de rest van onze rendering code? Hiervoor hebben we de useEffect() hook. Aan deze hook kan je code meegeven die los van de rendering code wordt uitgevoerd.  import { useEffect } from &quot;react&quot;; interface GreetProps { name: string } const Greet = ({ name } : GreetProps) =&gt; { const message = `Hello, ${name}!`; // Output gerelateerd useEffect(() =&gt; { document.title = `Greetings to ${name}`; // Side-effect! }, [name]); return &lt;div&gt;{message}&lt;/div&gt;; // Output gerelateerd }   Het updaten van de titel van het document is duidelijk een side-effect omdat het niet rechtstreeks te bijdraagt tot de output van het component. Daarom plaatsen we document.title in de callback en geven we die mee met de useEffect() functie.  We willen ook niet dat de titel van het document geupdated wordt elke keer dat het Greet component gerendered wordt. Deze code mag enkel alleen maar uitgevoerd worden als de name property veranderd. Dat is de reden waarom we deze meegeven in de dependency array.  ","version":"Next","tagName":"h2"},{"title":"Dependencies array​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#dependencies-array","content":" We hebben tot nu toe al kort gezien dat er een tweede argument kan worden meegegeven aan de useEffect() hook. Deze bepaald wanneer de meegegeven callback zal worden uitgevoerd.  Er zijn een aantal manieren om deze dependency array te gebruiken:  ","version":"Next","tagName":"h2"},{"title":"Geen dependencies​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#geen-dependencies","content":" De side-effect callback zal worden uitgevoerd na elke render van het component.  import { useEffect } from &quot;react&quot;; const App = () =&gt; { useEffect(() =&gt; { console.log(&quot;useEffect called&quot;); }); }   Deze wordt in principe niet veel gebruikt.  ","version":"Next","tagName":"h3"},{"title":"Een lege array​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#een-lege-array","content":" De side-effect wordt 1 keer uitgevoerd na de eerste render. Daarna niet meer  import { useEffect } from &quot;react&quot;; const App = () =&gt; { useEffect(() =&gt; { console.log(&quot;useEffect called only once!&quot;); },[]); }   Een voorbeeldgebruik hiervoor is bijvoorbeeld het inladen van gegevens van een API. Gewoonlijk wil je dit maar 1 keer doen.  ","version":"Next","tagName":"h3"},{"title":"Een array van states en props​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#een-array-van-states-en-props","content":" De side-effect wordt enkel uitgevoerd als een van de meegegeven dependencies veranderen.  const App = ({}) =&gt; { const [count, setCount] = useState(0); useEffect(() =&gt; { console.log(&quot;useEffect called when count changes&quot;); },[count]); return ( &lt;div&gt; &lt;p&gt;Count: {count}&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt; &lt;/div&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"Side-effect cleanup​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#side-effect-cleanup","content":" Sommige side-effects hebben cleanup nodig: afsluiten van verbindingen, timers clearen.  Je kan de cleanup code plaatsen in een functie die je als return waarde teruggeeft:  useEffect(() =&gt; { // Side-effect... return () =&gt; { // Side-effect cleanup... }; }, []);   Een concreet voorbeeld hiervan is het zetten van een timer. Als we geen cleanup code voorzien worden timers nooit gestopt en blijven die gewoon lopen zelfs al veranderd hier de interval.  import { useEffect,useState } from &quot;react&quot;; interface TimerProps { interval: number } const Timer = ({interval} : TimerProps) =&gt; { const [number, setNumber] = useState(0); useEffect(() =&gt; { let handle = setInterval(() =&gt; { setNumber(number =&gt; number + 1); },interval); return () =&gt; { clearInterval(handle); } },[interval]); return &lt;p&gt;{number}&lt;/p&gt; } const App = () =&gt; { const [timerInterval, setTimerInterval] = useState(1000); return ( &lt;&gt; &lt;div&gt; &lt;input type=&quot;range&quot; min=&quot;1&quot; max=&quot;2000&quot; value={interval} onChange={(e) =&gt; setTimerInterval(parseInt(e.target.value))}/&gt; &lt;label htmlFor=&quot;volume&quot;&gt;{interval}&lt;/label&gt; &lt;/div&gt; &lt;Timer interval={timerInterval} /&gt; &lt;/&gt; ); } export default App;   ","version":"Next","tagName":"h2"},{"title":"Praktische voorbeelden​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#praktische-voorbeelden","content":" ","version":"Next","tagName":"h2"},{"title":"Oproepen van een API​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#oproepen-van-een-api","content":" Een perfect voorbeeld waar useEffect() wordt gebruikt is het ophalen van data uit een API. We gaan in dit voorbeeld gebruik maken van de World Time API:  http://worldtimeapi.org/api/timezone/Europe/Brussels   De data voldoet aan de volgende interface:  interface TimezoneInfo { abbreviation: string; client_ip: string; datetime: Date; day_of_week: number; day_of_year: number; dst: boolean; dst_from: Date; dst_offset: number; dst_until: Date; raw_offset: number; timezone: string; unixtime: number; utc_datetime: Date; utc_offset: string; week_number: number; }   Het ophalen van data heeft nooit direct invloed op het renderen van het component. Dit komt omdat dit asynchroon gebeurd, dus op de moment dat de API aangeroepen wordt is er nog geen data beschikbaar en het renderen van componenten in react kan nooit asynchroon gebeuren. Daarom moet deze code in een side effect gebeuren.  const App = () =&gt; { const [timezoneInfo, setTimezoneInfo] = useState&lt;TimezoneInfo&gt;(); useEffect(() =&gt; { const fetchFunction = async() =&gt; { let result = await fetch(&quot;https://worldtimeapi.org/api/timezone/Europe/Brussels&quot;); let json : TimezoneInfo = await result.json(); setTimezoneInfo(json); } fetchFunction(); },[]); return ( &lt;&gt; {timezoneInfo &amp;&amp; ( &lt;ul&gt; &lt;li&gt;IP: {timezoneInfo.client_ip}&lt;/li&gt; &lt;li&gt;TimeZone: {timezoneInfo.timezone}&lt;/li&gt; &lt;li&gt;Time: {timezoneInfo.datetime}&lt;/li&gt; &lt;/ul&gt; )} &lt;/&gt; ); }   We gebruiken hier een useEffect met een lege dependency array omdat we deze API call maar 1 keer willen uitvoeren bij het mounten van dit component.  De callback die we meegeven aan useEffect mag niet async zijn dus we maken een aparte asynchrone functie die we dan in de useEffect callback oproepen.  ","version":"Next","tagName":"h3"},{"title":"Opslaan in LocalStorage​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#opslaan-in-localstorage","content":" Local storage laat toe bepaalde configuraties of user settings bij te houden in de browser van de gebruiker. Local storage kan bijvoorbeeld gebruikt worden om de inhoud van een veld op te slaan, zodat dit terug kan worden ingevuld wanneer de gebruiker de pagina opnieuw opent.  We kunnen deze waarde alvast uitlezen bij het zetten van de default waarde van onze state. Veronderstel bijvoorbeeld een veld name voor de naam van de gebruiker:  const [name, setName] = useState&lt;string&gt;(localStorage.getItem(&quot;name&quot;) ?? &quot;&quot;);   info De operator ?? staat toe een defaultwaarde te voorzien. Als de waarde langs de linkerkant null of undefined is, wordt de waarde langs de rechterkant gebruikt.  Door middel van een side-effect kunnen we elke wijziging aan de state variabele name opslaan. Om dit te verwezenlijken moeten we name in de dependency array meenemen zodat onze callback functie telkens wordt opgeroepen als deze veranderd.  const App = () =&gt; { const [name, setName] = useState&lt;string&gt;(localStorage.getItem(&quot;name&quot;) ?? &quot;&quot;); useEffect(() =&gt; { localStorage.setItem(&quot;name&quot;, name); },[name]); return ( &lt;&gt; &lt;input type=&quot;text&quot; value={name} onChange={(e) =&gt; setName(e.target.value)}/&gt; &lt;/&gt; ) }   ","version":"Next","tagName":"h3"},{"title":"Strict mode​","type":1,"pageTitle":"useEffect","url":"/webframeworks-cursus/wf-course/react/hooks/useEffect#strict-mode","content":" waarschuwing Dit is geavanceerde leerstof. Dit legt uit waarom effects onverwacht twee keer worden uitgevoerd en hoe we dit kunnen oplossen. Begrijp je dit niet? Geen probleem, je kan dit overslaan. Dit zal je geen problemen geven bij het maken van de oefeningen.  In de vorige voorbeelden hebben we gezegd dat de useEffect hook met een lege dependency array maar 1 keer wordt uitgevoerd. Je zult opmerken dat deze useEffect hook toch 2 keer wordt uitgevoerd. Dit komt omdat de App component in strict mode staat. Dit is een feature van React die ervoor zorgt dat componenten in development mode altijd een tweede keer worden gerendered. Dit is om te controleren of de rendering van het component geen side-effects heeft. Bijvoorbeeld: dat je useEffect hook een cleanup functie teruggeeft.  Je kan dit uitschakelen door de React.StrictMode component te verwijderen uit de index.tsx file.  import { StrictMode } from 'react'; import { createRoot } from 'react-dom/client'; const root = createRoot(document.getElementById('root')); root.render( &lt;StrictMode&gt; &lt;App /&gt; &lt;/StrictMode&gt; );   Zonder de StrictMode component zal de useEffect hook maar 1 keer worden uitgevoerd.  Is het dan best dat je deze afzet? Nee want het kan je fouten in je code helpen opsporen. Je zal er dus voor moeten zorgen dat je altijd een cleanup functie voorziet voor het opruimen van je vorige effect.  Dit is vaak gemakkelijker gezegd dan gedaan. Want bijvoorbeeld wat doen we dan bij een API call? We kunnen de fetch functie niet zomaar stoppen. We moeten dus een manier hebben waar we het resultaat kunnen negeren als de fetch nog bezig is op de moment dat de cleanup functie is aangeroepen.  We gaan in dit voorbeeld een aantal todos inlezen bij het mounten van een component  useEffect(( ) =&gt; { let ignore = false; fetch(&quot;https://jsonplaceholder.typicode.com/todos&quot;) .then(response =&gt; response.json()) .then(todos =&gt;{ if (!ignore) { console.log(&quot;SET TODO&quot;) setTodos(todos); } }); return () =&gt; { // cleanup code ignore = true; } }, [])   met async/await:  useEffect(( ) =&gt; { let ignore = false; const fetchFunction = async() =&gt; { let result = await fetch(&quot;https://jsonplaceholder.typicode.com/todos&quot;); let json = await result.json(); if (!ignore) { console.log(&quot;SET TODO&quot;) setTodos(json); } } fetchFunction(); return () =&gt; { // cleanup code ignore = true; } }, [])  ","version":"Next","tagName":"h2"},{"title":"Lijsten","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/lijsten","content":"","keywords":"","version":"Next"},{"title":"Lijsten in React​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/wf-course/react/lijsten#lijsten-in-react","content":" Wanneer we in TSX een lijst opnemen in de gegenereerde inhoud, wordt er gewoon een tekstvoorstelling voor die lijst gegenereerd door elk element rechtstreeks in de HTML in te voegen. In de praktijk is dit niet zinvol.  const App = () =&gt; { return &lt;p&gt;{[&quot;een element&quot;, &quot;tweede element&quot;, &quot;derde element&quot;]}&lt;/p&gt;; };   Normaal willen we een HTML-tag met eigen inhoud renderen per element van de array. Dit kan door elk element van de array eerst te vertalen naar een TSX-expressie op zich door middel van de map functie.  map​  De map functie kan gebruikt worden om informatie uit een lijst van gegevens te extraheren of om te zetten. Ze kan dan ook gebruikt worden om TSX-elementen te vormen. In onderstaande CodePen vertaalt ze elk element van de invoerlijst met games (voorgesteld als string) naar een&lt;li&gt; element, genest binnen een &lt;ul&gt; element:  const App = () =&gt; { const games : string[] = [ &quot;World of Warcraft&quot;, &quot;Valheim&quot;, &quot;Minecraft&quot; ]; return ( &lt;&gt; &lt;h1&gt;Games&lt;/h1&gt; &lt;ul&gt; {games.map((game: string) =&gt; &lt;li key={game}&gt;{game}&lt;/li&gt;)} &lt;/ul&gt; &lt;/&gt; ); }   Door elke string te mappen naar een li-element, wordt de TypeScript-lijst getoond als een HTML-lijst.  Omdat React gebruik maakt van geoptimaliseerde technieken voor het tonen van lijsten moet je elk element van een lijst dat op deze manier in JSX wordt ingebed voorzien van een attribuut key. Dit moet voor elk element in de lijst anders zijn. Vaak wordt hier een achterliggend ID gebruikt dat met de data geassocieerd is in een database, omdat dat normaal al uniek is. Omdat we in bovenstaande CodePen geen ID hebben voor de games, gebruiken we de naam zelf als key.  Onderstaande CodePen toont hetzelfde principe, maar met objecten en complexere structuren:  interface Game { id: number name: string, releaseYear: number, sales: number } const App = () =&gt; { const games: Game[] = [ { id: 0, name: &quot;World of Warcraft&quot;, releaseYear: 2004, sales: 5 }, { id: 1, name: &quot;Valheim&quot;, releaseYear: 2021, sales: 10 }, { id: 2, name: &quot;Minecraft&quot;, releaseYear: 2011, sales: 20 } ] return ( &lt;&gt; &lt;h1&gt;Games&lt;/h1&gt; { games.map((game: Game) =&gt; &lt;React.Fragment key={game.id}&gt; &lt;h2&gt;{game.name} ({game.releaseYear})&lt;/h2&gt; &lt;p&gt;Aantal keer verkocht: {game.sales}&lt;/p&gt; &lt;/React.Fragment&gt; ) } &lt;/&gt; ); }   pas op Dit is zowat het enige scenario waarin je de lange notatie voor een Fragment moet gebruiken: wanneer je een key op het fragment moet zetten.  Index als key​  In de bovenstaande voorbeelden hebben we de naam van het spel gebruikt als key. Dit is een goede keuze, omdat de naam van het spel uniek is. Maar wat als we geen unieke eigenschap hebben om als key te gebruiken? In dat geval kan je de index van het element in de lijst gebruiken. Je kan hier het tweede argument van de map functie voor gebruiken. Deze geeft de index van het element in de lijst.   const App = () =&gt; { const numbers: number[] = [1, 2, 3, 4, 5, 1, 3]; return ( &lt;&gt; &lt;h1&gt;Numbers&lt;/h1&gt; &lt;ul&gt; {numbers.map((number: number, index: number) =&gt; &lt;li key={index}&gt;{number}&lt;/li&gt;)} &lt;/ul&gt; &lt;/&gt; ); }   pas op Het gebruiken van de index als de key is niet de beste keuze, omdat het de prestaties van React negatief kan beïnvloeden. React gebruikt de key om te bepalen welke elementen in de lijst veranderd zijn, toegevoegd of verwijderd. Als je de index gebruikt, kan React niet meer bepalen welke elementen veranderd zijn, omdat de index van elk element in de lijst verandert als je een element toevoegt of verwijdert. Probeer dus dit niet te doen, tenzij je echt geen andere keuze hebt.  filter​  Onderstaande code toont filter en map in combinatie in een React applicatie:  interface Game { id: number name: string, releaseYear: number, sales: number } const App = () =&gt; { const games: Game[] = [ { id: 0, name: &quot;World of Warcraft&quot;, releaseYear: 2004, sales: 5 }, { id: 1, name: &quot;Valheim&quot;, releaseYear: 2021, sales: 10 }, { id: 2, name: &quot;Minecraft&quot;, releaseYear: 2011, sales: 20 } ] return ( &lt;&gt; &lt;h1&gt;Games&lt;/h1&gt; { games.filter((game) =&gt; game.sales &gt;= 8).map((game) =&gt; &lt;React.Fragment key={game.id}&gt; &lt;h2&gt;{game.name} ({game.releaseYear})&lt;/h2&gt; &lt;p&gt;Aantal keer verkocht: {game.sales}&lt;/p&gt; &lt;/React.Fragment&gt; ) } &lt;/&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"For loop in JSX​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/wf-course/react/lijsten#for-loop-in-jsx","content":" In JSX kan je niet zomaar een for loop gebruiken. Je kan wel een for loop simuleren door een array van de gewenste lengte te maken en deze te mappen naar de gewenste output. Onderstaande code toont hoe je dit kan doen:   const App = () =&gt; { let numbers: number[] = []; for (let i = 1; i &lt;= 5; i++) { numbers.push(i); } return ( &lt;&gt; &lt;h1&gt;Numbers&lt;/h1&gt; &lt;ul&gt; {numbers.map((number: number) =&gt; &lt;li key={number}&gt;{number}&lt;/li&gt;)} &lt;/ul&gt; &lt;/&gt; ); }   Je kan deze code ook schrijven met de Array.from functie:   const App = () =&gt; { const numbers: number[] = Array.from({length: 5}, (_, index) =&gt; index + 1); return ( &lt;&gt; &lt;h1&gt;Numbers&lt;/h1&gt; &lt;ul&gt; {numbers.map((number: number) =&gt; &lt;li key={number}&gt;{number}&lt;/li&gt;)} &lt;/ul&gt; &lt;/&gt; ); }   Je zou op deze manier ook een multidimensionale array kunnen maken. Stel dat we een 2D array willen maken van 3x3 met enkel nullen. Dit kan als volgt:   const App = () =&gt; { const grid: number[][] = Array.from({length: 3}, () =&gt; Array.from({length: 3}, () =&gt; 0)); return ( &lt;&gt; &lt;h1&gt;Grid&lt;/h1&gt; &lt;table&gt; &lt;tbody&gt; {grid.map((row: number[], rowIndex: number) =&gt; ( &lt;tr key={rowIndex}&gt; {row.map((cell: number, cellIndex: number) =&gt; ( &lt;td key={cellIndex}&gt;{cell}&lt;/td&gt; ))} &lt;/tr&gt; ))} &lt;/tbody&gt; &lt;/table&gt; &lt;/&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"Element herhalen​","type":1,"pageTitle":"Lijsten","url":"/webframeworks-cursus/wf-course/react/lijsten#element-herhalen","content":" In React kan je een element herhalen door een array van elementen te maken en deze te renderen. Onderstaande code toont hoe je dit kan doen:   const App = () =&gt; { const elements: JSX.Element[] = []; for (let i = 1; i &lt;= 5; i++) { elements.push(&lt;p key={i}&gt;Element {i}&lt;/p&gt;); } return ( &lt;&gt; {elements} &lt;/&gt; ); }   Je kan deze code ook schrijven met de Array.from functie:   const App = () =&gt; { return ( &lt;&gt; { Array.from({length: 5}, (_, index) =&gt; &lt;p key={index + 1}&gt;Element {index + 1}&lt;/p } &lt;/&gt; ); }   Deze code werkt als volgt in React:  De Array.from functie maakt een array van 5 elementen en gebruikt de callback functie om elk element te vullen met een &lt;p&gt; element.De callback functie krijgt twee argumenten: de waarde van het element (die we niet gebruiken) en de index van het element. We gebruiken de index om het nummer van het element te bepalen. Vaak gebruiken we _ als naam voor de eerste parameter als we deze niet gebruiken.We geven elk &lt;p&gt; element een unieke key door de index van het element te gebruiken. ","version":"Next","tagName":"h2"},{"title":"React Router","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/routing","content":"","keywords":"","version":"Next"},{"title":"Twee soorten routering​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#twee-soorten-routering","content":" Het proces waarbij de resource die bij een uniform resource locator (URL) hoort wordt opgezocht, heet routering. Vanuit het perspectief van de eindgebruiker is routering dus een vertaling van URL's in de browserbalk naar webpagina's. Er zijn twee vormen van routering, beide met hun eigen voor- en nadelen.  ","version":"Next","tagName":"h2"},{"title":"Server-side routering​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#server-side-routering","content":" De oudste (maar daarom niet &quot;verouderde&quot;) vorm van routering is server-side routering. Hierbij wordt een HTTP request naar de server gestuurd, met daarin de te raadplegen URL. Het is dan de taak van de server deze URL te gebruiken om een bepaalde resource op te zoeken. Voor deze vorm van routering is niet noodzakelijk een specifiek framework vereist. Bovendien downloadt de gebruiker enkel de pagina's die hij/zij daadwerkelijk wil zien. Daar tegenover staat dat routering enkel mogelijk is zo lang de gebruiker verbonden blijft met het Internet. Ook kost het tijd om telkens een request te versturen en te wachten op een response.  ","version":"Next","tagName":"h3"},{"title":"Routering in single-page applicaties​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#routering-in-single-page-applicaties","content":" Een nieuwere vorm van routering, die we aantreffen in single-page applicaties, is client-side routering. Bij gebruik van client-side routering beschikt de client vanaf het opstarten van de applicatie over meerdere (applicatie)pagina's. Gebruik van een link binnen de applicatie zorgt er dan niet voor dat er opnieuw een HTTP request plaatsvindt. In plaats daarvan wordt door de applicatie zelf bepaald welke (applicatie)pagina moet worden getoond. Hierbij wordt géén nieuw HTML-bestand gedownload.  Omdat client-side routering geen extra netwerkverkeer vereist, kan deze vorm ook toegepast worden wanneer de gebruiker niet verbonden is met het Internet. Zo lang de opgevraagde pagina's al in de applicatie aanwezig zijn, is er geen probleem. Bovendien kan deze vorm van routering responsiever aanvoelen, omdat het tijd kost een request te versturen en op een response te wachten.  ","version":"Next","tagName":"h3"},{"title":"React router​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#react-router-1","content":" Om client-side routering toe te passen, moet de app zelf over de nodige logica beschikken om URL's om te zetten naar pagina's. Deze logica hoef je als applicatieprogrammeur zelf niet te verzinnen. In plaats daarvan kan je gebruik maken van de bibliotheek React Router. Deze ondersteunt alle gebruikelijke manieren om URL's te vertalen naar pagina's.  We gebruiken de laatste versie van React Router (versie 7). Deze versie heeft een aantal grote wijzigingen ondergaan ten opzichte van de vorige versies. Er zijn namelijk nieuwe manieren van definiëren van routes toegevoegd. Wij gebruiken in deze cursus de declaratieve manier van routes definiëren. Dus als je documentatie opzoekt, let er dan op dat je de juiste versie van de documentatie bekijkt.  ","version":"Next","tagName":"h2"},{"title":"Installatie​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#installatie","content":" Omdat React Router een externe bibliotheek is, moet je deze eerst installeren. Hiervoor gebruik je in de root directory van je React project volgend commando:  npm install --save react-router-dom@7   Ondersteuning voor TypeScript is in deze versie ingebouwd, dus de types hoef je niet apart te installeren.  Op het moment van schrijven is de recentste versie van React Router versie 7.8.2. Nieuwere versies die ook beginnen met het cijfer 7 zouden zonder problemen moeten werken. Daarom eindigt bovenstaand commando op @7.  waarschuwing Als versie 8 of hoger verschenen is op het moment dat je deze leerstof raadpleegt, moet je toch versie 7 gebruiken.  ","version":"Next","tagName":"h3"},{"title":"Voorbeeld​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#voorbeeld","content":" Om te zien hoe je React Router gebruikt, bekijken we een voorbeeld. Dit voorbeeld heeft een aantal pagina's en een gedeelde layout die op elke pagina getoond wordt.  import { Outlet, createBrowserRouter, RouterProvider, Route, NavLink } from &quot;react-router-dom&quot;; import styles from &quot;./App.module.css&quot;; const Root = () =&gt; { return ( &lt;div className={styles.container}&gt; &lt;div className={styles.head}&gt;Header&lt;/div&gt; &lt;div className={styles.nav}&gt; &lt;NavLink to=&quot;/&quot; &gt;Home&lt;/NavLink&gt; &lt;NavLink to=&quot;page1&quot;&gt;Page 1&lt;/NavLink&gt; &lt;NavLink to=&quot;page2&quot;&gt;Page 2&lt;/NavLink&gt; &lt;/div&gt; &lt;div className={styles.content}&gt; &lt;Outlet/&gt; &lt;/div&gt; &lt;div className={styles.footer}&gt; Footer &lt;/div&gt; &lt;/div&gt; ); } const Home = () =&gt; { return ( &lt;div&gt;This is the home page!&lt;/div&gt; ); } const Page1 = () =&gt; { return ( &lt;div&gt;Page 1&lt;/div&gt; ); } const Page2 = () =&gt; { return ( &lt;div&gt;Page 2&lt;/div&gt; ); } const App = () =&gt; { const router = createBrowserRouter([ { path: &quot;/&quot;, element: &lt;Root/&gt;, children: [ { path: &quot;&quot;, element: &lt;Home/&gt; }, { path: &quot;page1&quot;, element: &lt;Page1/&gt; }, { path: &quot;page2&quot;, element: &lt;Page2/&gt; } ] } ]); return ( &lt;div&gt; &lt;RouterProvider router={router} /&gt; &lt;/div&gt; ) } export default App;   Het eerst ding dat we moeten doen is een Browser Router aanmaken en onze eerste route configureren. Dit zal client-side routering mogelijk maken voor onze webapplicatie.  Dit doen we aan de hand van de createBrowserRouter functie. Deze functie heeft als argument een array van routes. Deze routes zijn van het type RouteObject. Deze RouteObject heeft een aantal properties:  path: de URL waarop de route moet reagerenelement: het element dat moet worden gerenderd wanneer de route wordt geactiveerdchildren: een array van RouteObject die de subroutes van de huidige route bevat...  Het object dat teruggegeven wordt door de createBrowserRouter functie moeten we meegeven aan de RouterProvider component.  Als je de code bekijkt, zie je dat we een Root component hebben gemaakt. Deze component bevat de basis structuur van onze webapplicatie. Deze structuur bestaat uit een header, een navigatiebalk, een content gedeelte en een footer. Deze component bevat ook de NavLink componenten. Deze componenten zorgen ervoor dat de gebruiker kan navigeren tussen de verschillende pagina's van onze webapplicatie.  Het Root component bevat ook een Outlet component. Dit is een component die de inhoud van de pagina zal renderen van de child route die geactiveerd is. Surft de gebruiker naar de &quot;/&quot; route, dan zal de Home component gerenderd worden. Surft de gebruiker naar de &quot;/page1&quot; route, dan zal de Page1 component gerenderd worden, enzovoort.  ","version":"Next","tagName":"h3"},{"title":"Links​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#links","content":" Er zijn twee verschillende manieren om links te maken in React Router. De eerste manier is door gebruik te maken van de Link component. Deze component heeft als enige property de to property. Deze property bevat de URL waar de gebruiker naar toe moet navigeren wanneer hij op de link klikt.  &lt;Link to=&quot;/page1&quot;&gt;Page 1&lt;/Link&gt;   Een tweede manier om links te maken is door gebruik te maken van de NavLink component. Deze component heeft dezelfde properties als de Link component. Het voordeel hier is dat je de link kan stylen aan de hand van CSS. Er wordt altijd automatisch een active class toegevoegd aan de link wanneer de link geactiveerd is. Je kan die class gebruiken om de link te stylen.  .active { color: red; }   Je kan ook een functie meegeven aan de className property. Deze functie bevat een object met een isActive property. Deze property bevat een boolean die aangeeft of de link geactiveerd is of niet.  &lt;NavLink className={({isActive}) =&gt; isActive ? styles.activeNavLink : styles.navLink} to=&quot;/&quot;&gt;Home&lt;/NavLink&gt;   ","version":"Next","tagName":"h3"},{"title":"Ontbrekende pagina's afhandelen​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#ontbrekende-paginas-afhandelen","content":" Als de gebruiker een URL gebruikt die niet naar een geldige pagina leidt, wordt er een algemene error pagina. Dat is niet gebruiksvriendelijk. Het is beter een pagina te voorzien die de gebruiker op de hoogte stelt dat het ingevoerde adres niet bestaat. Dit kan je doen door een route te voorzien met een wildcard te voorzien. Als je dan een component genaamd PageNotFound hebt, kan je de volgende route toevoegen:  { path: &quot;*&quot;, element: &lt;PageNotFound/&gt; }   Omdat deze route zo algemeen is, zal ze enkel matchen wanneer er geen betere match gevonden wordt.  ","version":"Next","tagName":"h3"},{"title":"URL parameters​","type":1,"pageTitle":"React Router","url":"/webframeworks-cursus/wf-course/react/routing#url-parameters","content":" Tot nu toe hebben we altijd routes gebruikt die exacte paden voorstellen. Soms wil je ook aan de hand van de url bepaalde parameters meegeven. Dat kan bijvoorbeeld een ID zijn: een uniek stukje informatie dat verwijst naar één specifieke user, één bestelling, één event op de kalender,... Als deze zaken voortdurend worden toegevoegd aan het systeem, is het niet mogelijk een route per user, per bestelling of per event te voorzien. Het is echter wel mogelijk een URL zoals /detail/:id toe te laten waarbij de :id een parameter is: een algemene plaatshouder in de URL waaraan een concrete waarde gegeven kan worden. Zo kan bijvoorbeeld /detail/1 of /detail/2 gebruikt worden, waarbij in beide gevallen dezelfde component wordt gerenderd, maar met andere data.  Om dit te laten werken, moet de applicatie de precieze waarde kunnen opvragen die de parameter heeft gekregen. Dit kan door middel van de useParams hook. Deze staat je toe de URL parameters op te vragen die gebruikt zijn om naar de huidige pagina te navigeren.  import { useParams, Outlet, createBrowserRouter, RouterProvider, Route, NavLink,Link } from &quot;react-router-dom&quot;; import &quot;./App.css&quot;; const Home = () =&gt; { return ( &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/detail/1&quot;&gt;Detail 1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/detail/2&quot;&gt;Detail 2&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/detail/3&quot;&gt;Detail 3&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ); } const Detail = () =&gt; { const { id } = useParams(); return ( &lt;div&gt;Detail {id}&lt;/div&gt; ); } const App = () =&gt; { const router = createBrowserRouter([ { path: &quot;/&quot;, element: &lt;Root/&gt;, children: [ { path: &quot;&quot;, element: &lt;Home/&gt; }, { path: &quot;detail/:id&quot;, element: &lt;Detail/&gt; } ] } ]); return ( &lt;div&gt; &lt;RouterProvider router={router} /&gt; &lt;/div&gt; ) } export default App;   Het object dat je terugkrijgt van useParams staat je toe een waarde op te zoeken voor om het even welke key. Er treedt dus geen compilatiefout op als je in TypeScript een parameter probeert te raadplegen die niet voorzien is. Je krijgt gewoon undefined terug.  useNavigate  De useNavigate hook is een hook die je toelaat te navigeren naar een andere pagina in je applicatie aan de hand van JavaScript code. Dit kan handig zijn als  const Home = () =&gt; { const navigate = useNavigate(); return ( &lt;div&gt; &lt;button onClick={() =&gt; navigate(&quot;/detail/1&quot;)}&gt;Detail 1&lt;/button&gt; &lt;button onClick={() =&gt; navigate(&quot;/detail/2&quot;)}&gt;Detail 2&lt;/button&gt; &lt;button onClick={() =&gt; navigate(&quot;/detail/3&quot;)}&gt;Detail 3&lt;/button&gt; &lt;/div&gt; ); } # Meer weten - https://reactrouter.com/en/6.4.3  ","version":"Next","tagName":"h3"},{"title":"Statische bestanden","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/tsx/static","content":"","keywords":"","version":"Next"},{"title":"Afbeeldingen in de public folder​","type":1,"pageTitle":"Statische bestanden","url":"/webframeworks-cursus/wf-course/react/tsx/static#afbeeldingen-in-de-public-folder","content":" Alles wat in de public folder staat wordt automatisch naar de root van de website gekopieerd. Je kan dus een afbeelding in de public folder zetten met de naam logo.png, en deze gebruiken door de src property te zetten op /llama.png. We zetten hier / voor omdat alle bestanden in de public folder naar de root van de website gekopieerd worden.  import React from &quot;react&quot;; const App = () =&gt; { return ( &lt;img src=&quot;/llama.png&quot; alt=&quot;llama image&quot; /&gt; ); }; export default App;   ","version":"Next","tagName":"h2"},{"title":"Afbeeldingen bij de source code​","type":1,"pageTitle":"Statische bestanden","url":"/webframeworks-cursus/wf-course/react/tsx/static#afbeeldingen-bij-de-source-code","content":" Vaak worden de afbeeldingen mee bij de source code gestoken. Dit is handig omdat dan je afbeeldingen bij je componenten zitten, en je dus niet moet zoeken naar de afbeeldingen.  ","version":"Next","tagName":"h2"},{"title":"Met het import keyword​","type":1,"pageTitle":"Statische bestanden","url":"/webframeworks-cursus/wf-course/react/tsx/static#met-het-import-keyword","content":" Je kan ook afbeeldingen mee in de src folder zetten. Je kan dan aan de hand van het import statement de afbeelding importeren. Je kan dan de src property zetten op de variabele die je hebt geïmporteerd.  import React from &quot;react&quot;; import logo from &quot;./assets/llama2.png&quot;; const App = () =&gt; { return ( &lt;img src={logo} alt=&quot;llama image&quot; /&gt; ); }; export default App;   tip In dit voorbeeld hebben we alle bestanden in een aparte folder assets gezet. Dit mag je zelf kiezen, maar het is wel een goede gewoonte om je assets in een aparte folder te zetten. Hoe je die noemt is niet belangrijk, maar het is wel belangrijk dat je het consequent doet.  ","version":"Next","tagName":"h3"},{"title":"Audio bestanden​","type":1,"pageTitle":"Statische bestanden","url":"/webframeworks-cursus/wf-course/react/tsx/static#audio-bestanden","content":" Je kan ook audio bestanden gebruiken in react. Je kan dit doen door de &lt;audio&gt; tag te gebruiken. Je kan de src property gebruiken om de audio bestand te kiezen. Je kan ook de controls property gebruiken om de audio bestanden te laten afspelen.  import horseSound from &quot;./assets/horse.mp3&quot;; const App = () =&gt; { return ( &lt;audio controls autoPlay&gt; &lt;source src={horseSound} type=&quot;audio/mpeg&quot; /&gt; &lt;/audio&gt; ); } export default App;   We kunnen hiervoor ook de import methode gebruiken of de bestanden in de public folder zetten zoals hierboven beschreven. ","version":"Next","tagName":"h2"},{"title":"TSX","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/tsx","content":"","keywords":"","version":"Next"},{"title":"Verschillende namen en werking attributen​","type":1,"pageTitle":"TSX","url":"/webframeworks-cursus/wf-course/react/tsx#verschillende-namen-en-werking-attributen","content":" Enkele attributen van tags hebben in TSX een andere naam of volgen andere afspraken in React dan in HTML. Dit komt bijvoorbeeld omdat deze attributen een naam hebben die niet gebruikt mag worden in TypeScript of omdat de werking van een bepaald attribuut in HTML duidelijke tekortkomingen vertoont.  We lijsten ze hier niet allemaal op. Deze verschillen zullen vermeld worden waar ze een probleem kunnen stellen. Het enige verschil dat we hier meegeven: het class attribuut van een HTML-element wordt het className attribuut van een TSX-element. Dit komt omdat class een woord met een speciale betekenis is in TypeScript / JavaScript.  Een volledige lijst met verschillen vind je hier in de documentatie van React.  ","version":"Next","tagName":"h3"},{"title":"Conditionele rendering​","type":1,"pageTitle":"TSX","url":"/webframeworks-cursus/wf-course/react/tsx#conditionele-rendering","content":" Conditionele rendering in React werkt op dezelfde manier als condities werken in TypeScript. Je kan hiervoor een if statement gebruiken of de conditionele operator (vraagteken operator) en afhankelijk hiervan UI elementen te tonen.  Met een if statement​  const App = () =&gt; { let random : number = Math.random(); if (random &gt; 0.5) { return &lt;p&gt;We hebben geluk gehad&lt;/p&gt; } else { return &lt;p&gt;We hebben pech gehad&lt;/p&gt; } };   JSX in een variabele​  Het is perfect mogelijk om JSX toe te kennen aan een variabele en deze dan op een later moment te renderen.  const App = () =&gt; { let random : number = Math.random(); let luckyText : JSX.Element; if (random &gt; 0.5) { luckyText = &lt;p&gt;We hebben geluk gehad&lt;/p&gt; } else { luckyText = &lt;p&gt;We hebben pech gehad&lt;/p&gt; } return &lt;div&gt;{luckyText}&lt;/div&gt; };   Inline If-Else met conditional ? operator​  Een andere manier om een If-Else conditie na te bootsen is met het gebruik van de conditional operator. Dit zal er als volgt uitzien:  const App = () =&gt; { let random : number = Math.random(); return ( &lt;p&gt;{random &gt; 0.5 ? &lt;p&gt;We hebben geluk gehad&lt;/p&gt; : &lt;p&gt;We hebben pech gehad&lt;/p&gt;}&lt;/p&gt; ); };   Inline If met logische &amp;&amp; operator​  Als je enkel iets wil tonen als een bepaalde conditie waar is kan je ook gebruik maken van de &amp;&amp; operator.  const App = () =&gt; { let random : number = Math.random(); return ( &lt;p&gt;{random &gt; 0.5 &amp;&amp; &lt;p&gt;We hebben geluk gehad&lt;/p&gt;}&lt;/p&gt; ); };   ","version":"Next","tagName":"h3"},{"title":"Geneste accolades​","type":1,"pageTitle":"TSX","url":"/webframeworks-cursus/wf-course/react/tsx#geneste-accolades","content":" Accolades zijn nodig om te wisselen van de HTML-achtige syntax naar de klassieke TypeScript syntax. Binnenin deze syntax kan weer naar de HTML-achtige syntax gewisseld worden, enzovoort. Dit wordt hier gedemonstreerd:  import React from &quot;react&quot;; const getLuckText = () =&gt; &quot;We hebben geluk gehad&quot;; const getBadLuckText = () =&gt; &quot;We hebben pech gehad&quot;; const App = () =&gt; { return ( &lt;&gt;{ Math.random() &gt; 0.5 ? &lt;p&gt;{getLuckText()}&lt;/p&gt; : &lt;p&gt;{getBadLuckText()}&lt;/p&gt; } &lt;/&gt; ); }; export default App;   ","version":"Next","tagName":"h3"},{"title":"Fragments​","type":1,"pageTitle":"TSX","url":"/webframeworks-cursus/wf-course/react/tsx#fragments","content":" Function components worden verwacht één TSX-expressie terug te geven. Nochtans wordt niet elke component naar exact één HTML-element omgezet in de uiteindelijk geproduceerde pagina. Anders gezegd: één component App kan niet rechtstreeks omgezet worden naar twee of meer HTML-elementen die siblings zijn in het Document Object Model. Volgende code is dus niet uitvoerbaar:  const App = () =&gt; { return ( &lt;h1&gt;Titel van mijn boek&lt;/h1&gt; &lt;h2&gt;Eerste hoofdstuk&lt;/h2&gt; &lt;h2&gt;Tweede hoofdstuk&lt;/h2&gt; ); }   Dit gaat niet, omdat er drie TSX-expressies op hetzelfde niveau staan. De h2-elementen zijn niet genest in het h1-element.  Hoger op deze pagina hebben we het probleem omzeild door elementen in een div te plaatsen. Dit soort element is heel algemeen en voegt vaak overbodige ballast toe aan een pagina. Daarom is het beter om het zo spaarzaam mogelijk te gebruiken. Hier is een eenvoudige oplossing voor: de drie expressies in een grotere expressie plaatsen die niet vertaald wordt naar HTML. Een dergelijke expressie heet een fragment. Er bestaat een langere notatie en een kortere notatie voor fragments. Met de langere notatie kan bovenstaande code als volgt herschreven worden:  const App = () =&gt; { return ( &lt;Fragment&gt; &lt;h1&gt;Titel van mijn boek&lt;/h1&gt; &lt;h2&gt;Eerste hoofdstuk&lt;/h2&gt; &lt;h2&gt;Tweede hoofdstuk&lt;/h2&gt; &lt;/Fragment&gt; ); }   In de korte notatie ziet een fragment er uit als een tag zonder naam:  import React from &quot;react&quot;; const App = () =&gt; { return ( &lt;&gt; &lt;h1&gt;Titel van mijn boek&lt;/h1&gt; &lt;h2&gt;Eerste hoofdstuk&lt;/h2&gt; &lt;h2&gt;Tweede hoofdstuk&lt;/h2&gt; &lt;/&gt; ); }; export default App;   Meestal wordt de korte notatie gebruikt. ","version":"Next","tagName":"h3"},{"title":"Handige Tools","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/tools","content":"Handige Tools","keywords":"","version":"Next"},{"title":"Extra voorbeelden","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/state/voorbeelden","content":"","keywords":"","version":"Next"},{"title":"Language selector​","type":1,"pageTitle":"Extra voorbeelden","url":"/webframeworks-cursus/wf-course/react/state/voorbeelden#language-selector","content":" import {useState} from &quot;react&quot;; interface Translation { [language: string]: string } interface Translations { key: string, translations: Translation } let translations : Translations[] = [ { key: &quot;welcome&quot;, translations: { &quot;NL&quot;: &quot;Welkom op de website.&quot;, &quot;EN&quot;: &quot;Welcome to the website.&quot;, &quot;FR&quot;: &quot;Bienvenue sur le site.&quot; } }, { key: &quot;language&quot;, translations: { &quot;NL&quot;: &quot;Deze website is volledig vertaald in het Nederlands.&quot;, &quot;EN&quot;: &quot;This website is fully translated into english.&quot;, &quot;FR&quot;: &quot;Ce site est entièrement traduit en francais.&quot; } } ] const getTranslation = (language: string, key: string) =&gt; { return translations.find(t =&gt; t.key === key)?.translations[language]; } const App = () =&gt; { const [language, setLanguage] = useState(&quot;NL&quot;); return ( &lt;div&gt; &lt;div&gt; &lt;button onClick={() =&gt; setLanguage(&quot;NL&quot;)}&gt;NL&lt;/button&gt; &lt;button onClick={() =&gt; setLanguage(&quot;EN&quot;)}&gt;EN&lt;/button&gt; &lt;button onClick={() =&gt; setLanguage(&quot;FR&quot;)}&gt;FR&lt;/button&gt; &lt;/div&gt; &lt;h1&gt;{getTranslation(language, &quot;welcome&quot;)}&lt;/h1&gt; &lt;p&gt;{getTranslation(language, &quot;language&quot;)}&lt;/p&gt; &lt;/div&gt; ) } export default App;   ","version":"Next","tagName":"h2"},{"title":"Zoeken, filteren en sorteren​","type":1,"pageTitle":"Extra voorbeelden","url":"/webframeworks-cursus/wf-course/react/state/voorbeelden#zoeken-filteren-en-sorteren","content":" import React, { useState } from &quot;react&quot;; interface Item { name: string; price: number; inStock: boolean; } const GoodsList = ({goods} : {goods: Item[]}) =&gt; { const [searchField, setSearchField] = useState(&quot;&quot;); const [stockOnly, setStockOnly] = useState(false); const [sortField, setSortField] = useState(&quot;name&quot;); let filteredGoods = goods.filter((item) =&gt; item.name.toUpperCase().startsWith(searchField.toUpperCase())); if (stockOnly) { filteredGoods = filteredGoods.filter((item) =&gt; item.inStock); } const sortedGoods = filteredGoods.sort((a, b) =&gt; { switch (sortField) { case &quot;price&quot;: return a.price - b.price; case &quot;inStock&quot;: return Number(a.inStock) - Number(b.inStock); case &quot;name&quot;: return a.name.localeCompare(b.name); default: return 0; } }); return ( &lt;div&gt; &lt;div&gt; &lt;input placeholder=&quot;search&quot; type=&quot;text&quot; value={searchField} onChange={(event) =&gt; setSearchField(event.target.value)} /&gt; &lt;input type=&quot;checkbox&quot; checked={stockOnly} onChange={(e) =&gt; setStockOnly(e.target.checked)}/&gt; Show only in stock &lt;/div&gt; &lt;div&gt; &lt;select onChange={(e) =&gt; setSortField(e.target.value)} value={sortField}&gt; &lt;option value=&quot;name&quot;&gt;Name&lt;/option&gt; &lt;option value=&quot;price&quot;&gt;Price&lt;/option&gt; &lt;option value=&quot;inStock&quot;&gt;In stock&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div style={{display: &quot;grid&quot;, gridTemplateColumns: &quot;300px 100px&quot;}}&gt; {sortedGoods.map((item) =&gt; ( &lt;React.Fragment key={item.name}&gt; &lt;span style={{color: item.inStock ? &quot;black&quot; : &quot;red&quot;}}&gt;{item.name}&lt;/span&gt; &lt;span&gt;€ {item.price}&lt;/span&gt; &lt;/React.Fragment&gt;))} &lt;/div&gt; &lt;/div&gt; ); } const App = () =&gt; { let goods : Item[] = [ { name: &quot;iPhone 12&quot;, price: 699, inStock: false }, { name: &quot;iPhone 12 Pro&quot;, price: 999, inStock: true }, { name: &quot;iPhone 12 Pro Max&quot;, price: 1099, inStock: true }, { name: &quot;Samsung Galaxy S20&quot;, price: 799, inStock: true }, { name: &quot;Samsung Galaxy S10&quot;, price: 699, inStock: false }, { name: &quot;Samsung Galaxy S20 Ultra&quot;, price: 999, inStock: true }, { name: &quot;Huawei P30&quot;, price: 499, inStock: true }, { name: &quot;Huawei P40&quot;, price: 599, inStock: true }, { name: &quot;Nokia 3310&quot;, price: 399, inStock: false } ] return &lt;GoodsList goods={goods}/&gt; } export default App;   ","version":"Next","tagName":"h2"},{"title":"Toevoegen in een lijst​","type":1,"pageTitle":"Extra voorbeelden","url":"/webframeworks-cursus/wf-course/react/state/voorbeelden#toevoegen-in-een-lijst","content":" import React, { useState } from &quot;react&quot;; interface Item { name: string; price: number; inStock: boolean; } const GoodsList = ({goods : propsGood} : {goods: Item[]}) =&gt; { const [goods, setGoods] = useState(propsGood); const [productName, setProductName] = useState(&quot;&quot;); const [price, setPrice] = useState(500); const [inStock, setInStock] = useState(false); const addProduct : React.FormEventHandler&lt;HTMLFormElement&gt; = (e) =&gt; { e.preventDefault(); setGoods([...goods, {name: productName, price: price, inStock: inStock}]); setProductName(&quot;&quot;); setPrice(0); setInStock(false); } return ( &lt;div&gt; &lt;div&gt; &lt;form onSubmit={addProduct} style={{display: &quot;grid&quot;, gridTemplateColumns: &quot;200px 200px&quot;}}&gt; &lt;label&gt;Product name: &lt;/label&gt;&lt;input placeholder=&quot;product name&quot; type=&quot;text&quot; value={productName} onChange={(event) =&gt; setProductName(event.target.value)} /&gt; &lt;label&gt;Price: &lt;/label&gt;&lt;input placeholder=&quot;price&quot; type=&quot;number&quot; value={price} onChange={(event) =&gt; setPrice(parseInt(event.target.value))} /&gt; &lt;label&gt;In stock? &lt;/label&gt;&lt;input type=&quot;checkbox&quot; checked={inStock} onChange={(event) =&gt; setInStock(event.target.checked)} /&gt; &lt;input type=&quot;submit&quot; value=&quot;Add product&quot; style={{gridColumnStart: 1, gridColumnEnd: &quot;span 2&quot;}}/&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style={{display: &quot;grid&quot;, gridTemplateColumns: &quot;300px 100px&quot;}}&gt; {goods.map((item) =&gt; ( &lt;React.Fragment key={item.name}&gt; &lt;span style={{color: item.inStock ? &quot;black&quot; : &quot;red&quot;}}&gt;{item.name}&lt;/span&gt; &lt;span&gt;€ {item.price}&lt;/span&gt; &lt;/React.Fragment&gt;))} &lt;/div&gt; &lt;/div&gt; ); } const App = () =&gt; { let goods : Item[] = [ { name: &quot;iPhone 12&quot;, price: 699, inStock: false }, { name: &quot;iPhone 12 Pro&quot;, price: 999, inStock: true }, { name: &quot;iPhone 12 Pro Max&quot;, price: 1099, inStock: true }, { name: &quot;Samsung Galaxy S20&quot;, price: 799, inStock: true }, { name: &quot;Samsung Galaxy S10&quot;, price: 699, inStock: false }, { name: &quot;Samsung Galaxy S20 Ultra&quot;, price: 999, inStock: true }, { name: &quot;Huawei P30&quot;, price: 499, inStock: true }, { name: &quot;Huawei P40&quot;, price: 599, inStock: true }, { name: &quot;Nokia 3310&quot;, price: 399, inStock: false } ] return &lt;GoodsList goods={goods}/&gt; } export default App;  ","version":"Next","tagName":"h2"},{"title":"React Developer Tools","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/tools/devtools","content":"","keywords":"","version":"Next"},{"title":"Installatie​","type":1,"pageTitle":"React Developer Tools","url":"/webframeworks-cursus/wf-course/tools/devtools#installatie","content":" Afhankelijk van de browser die je gebruikt kan je de extensie installeren via de volgende links:  ChromeFirefox  ","version":"Next","tagName":"h2"},{"title":"Gebruik​","type":1,"pageTitle":"React Developer Tools","url":"/webframeworks-cursus/wf-course/tools/devtools#gebruik","content":" Als je nu naar de browser gaat en je opent de developer tools, dan zie je een extra tabblad &quot;Components&quot; en &quot;Profiler&quot;. In het tabblad &quot;Components&quot; kan je de componenten van je applicatie inspecteren. In het tabblad &quot;Profiler&quot; kan je de performance van je applicatie analyseren.  ","version":"Next","tagName":"h2"},{"title":"Componenten inspecteren​","type":1,"pageTitle":"React Developer Tools","url":"/webframeworks-cursus/wf-course/tools/devtools#componenten-inspecteren","content":" Als je op het tabblad &quot;Components&quot; klikt, dan zie je een boomstructuur van alle componenten in je applicatie. Je kan de componenten openklappen en de props en state van de componenten bekijken. Je kan ook de props en state aanpassen en de wijzigingen worden onmiddellijk doorgevoerd in de browser.  ","version":"Next","tagName":"h2"},{"title":"Inspecteren van niet React elementen​","type":1,"pageTitle":"React Developer Tools","url":"/webframeworks-cursus/wf-course/tools/devtools#inspecteren-van-niet-react-elementen","content":" Soms is het handig om ook niet React elementen te kunnen inspecteren. Als je bijvoorbeeld wil nakijken welke key een bepaald element heeft gekregen bij het gebruik van een map functie. Daarom is er een optie voorzien in de settings van de extensie. Als je op het settings icoontje klikt in de extensie, dan kan je de optie &quot;Hide components where...&quot; afzetten. Als je nu terug naar de browser gaat en je opent de developer tools, dan zie je dat je nu ook niet React elementen kan inspecteren.    Het is wel aangeraden toch deze vlak terug af te zetten als je klaar bent met het inspecteren van niet React elementen. Anders wordt het snel zeer onoverzichtelijk. ","version":"Next","tagName":"h2"},{"title":"Devcontainers: One Click Dev Environments","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/tools/devcontainers","content":"","keywords":"","version":"Next"},{"title":"Dev Environment​","type":1,"pageTitle":"Devcontainers: One Click Dev Environments","url":"/webframeworks-cursus/wf-course/tools/devcontainers#dev-environment","content":" Een Dev Environment is simpelweg een systeem waar alle software, tools en hardware op geïnstalleerd zijn, zodat jij kunt programmeren aan een specifiek project. Met software en tools wordt echt alles bedoeld dat je gebruikt tijdens het programmeren:  Code Editors (bv. VS Code of Visual Studio)Plugins (bv. een Markdown extension in VS Code)Compilers (bv. de .NET compiler voor C#)Sandbox omgevingen (bv. NodeJS)...  Meestal heb je op één toestel meerdere Dev Environments geïnstalleerd. Het is nu eenmaal niet praktisch om rond te lopen met 5 laptops...  ","version":"Next","tagName":"h2"},{"title":"Dev Environment Problemen​","type":1,"pageTitle":"Devcontainers: One Click Dev Environments","url":"/webframeworks-cursus/wf-course/tools/devcontainers#dev-environment-problemen","content":" Een Dev Environment is dus vaak een complex systeem van allerlei software, tools en specifieke instellingen die samenwerken om een stuk software te ontwikkelen. Wat kan er allemaal misgaan?  Oh Nee, mijn Laptop is Kapot!​  Je laptop gaat stuk, en je koopt een nieuwe. Nu moet je ALLE software en tools opnieuw installeren. Niet alleen dat, maar je zult er ook op moeten letten dat je EXACT dezelfde versie van die software en tools terug installeert! Weet jij nog of je versie 18.17.1 of versie 17.9.2 had geïnstalleerd op je laptop?  Oh Nee, een Groepswerk!​  Je moet samenwerken met iemand anders. Het project werkt perfect op jouw Dev Environment, maar wilt om één of andere reden niet draaien op die van je teamgenoot. Tijd om ELKE tool en software die je gebruikt na te kijken op versie nummer!  Oh Nee, een Oud Project Werkt Niet Meer!​  Voor je nieuwste projecten heb je NodeJS geupdate naar de nieuwste versie. Oeps! Nu werken je oude projecten, die gebruik maakten van een oude versie van NodeJS, niet meer!  Deployment Hell​  Alles werkt perfect op jouw systeem, en ook op die van je teamgenoten. Maar tijdens het deployen naar de server, merk je dat je software niet werkt. Tijd om ELKE tool en software die je gebruikt (opnieuw) na te kijken op versie nummer!  ","version":"Next","tagName":"h3"},{"title":"Docker to the Rescue!​","type":1,"pageTitle":"Devcontainers: One Click Dev Environments","url":"/webframeworks-cursus/wf-course/tools/devcontainers#docker-to-the-rescue","content":" We kunnen een Docker Container zo samenstellen dat alle tools en instellingen daarin geïnstalleerd staan. Je installeert niets meer op je eigen systeem, alles zit netjes verpakt in een Docker Container! Zo'n Docker Container waarin je je Dev Environment opslaat voor één specifiek project, dàt heet een DevContainer.  ","version":"Next","tagName":"h2"},{"title":"Wat Heb je Nodig?​","type":1,"pageTitle":"Devcontainers: One Click Dev Environments","url":"/webframeworks-cursus/wf-course/tools/devcontainers#wat-heb-je-nodig","content":" Je hebt in feite slechts 2 programma's nodig op je computer:  Docker Desktop*Visual Studio Code  *Om Docker te laten werken moet je WSL geïnstalleerd hebben op je Windows computer. Dus in principe moet je 3 dingen installeren.  ","version":"Next","tagName":"h3"},{"title":"Hoe Maak je een DevContainer?​","type":1,"pageTitle":"Devcontainers: One Click Dev Environments","url":"/webframeworks-cursus/wf-course/tools/devcontainers#hoe-maak-je-een-devcontainer","content":" Ga naar github en maak een nieuwe repository (via classrooms invite).Open VS Code, en installeer het Remote Development extension pack. Dit geeft je alle tools die je nodig hebt om een DevContainer te maken en gebruiken.In VS Code, gebruik de toets-combinatie CTRL + SHIFT + P om het Command Palette venster te openen.In het command palette window kies je voor de optie: &quot;Dev Containers: Clone Repository in Container Volume...&quot;VS Code vraagt om de url naar een repository. Plak hier de HTTPS link die je in stap 1 kopieerde. (eventjes wachten...)Kies hier voor de geschikte DevContainer configuratie. In het geval van React kiezen we voor Node.js &amp; TypeScript. Kies ook voor de default versie van Node.Je kan in de volgende stap extra features aanduiden. Voor React hebben we niks nodig, dus klik gewoon op 'ok'. (eventjes wachten... De containers worden nu gedownload en opgestart. Zeker de eerste keer kan dit een tijdje duren!)  Proficiat, je hebt een volledig werkende DevContainer!  Enkele vreemde zaken om op te merken:  Ga in VS Code naar Terminal &gt; New Terminal en merk op dat het pad niet langer begint met C:. Dit komt omdat je niet langer in een Windows omgeving werkt, maar wel in een Linux omgeving!Node werkt, zelfs als je Node nooit geinstalleerd hebt op je systeem.Git werkt, zelfs als je Git nooit geinstalleerd hebt op je systeem.  Vergeet niet je werk te committen en pushen!  ","version":"Next","tagName":"h3"},{"title":"Trouble Shooting​","type":1,"pageTitle":"Devcontainers: One Click Dev Environments","url":"/webframeworks-cursus/wf-course/tools/devcontainers#trouble-shooting","content":" WSL versie is niet up-to-date​  Als je de DevContainer probeert te openen, maar je krijgt een foutmelding dat je WSL versie niet up-to-date is, dan moet je WSL updaten. Dit kan je doen door het volgende stappenplan te volgen:  Open Powershell als administrator (rechtermuisknop op het Powershell icoontje, en kies voor Run as Administrator)Voer de volgende commando's uit:  dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart wsl --set-default-version 2 wsl --update   Hierna kan je best je computer herstarten om zeker te zijn dat alles goed werkt. ","version":"Next","tagName":"h3"},{"title":"Vercel","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/tools/vercel","content":"","keywords":"","version":"Next"},{"title":"Wat is Vercel?​","type":1,"pageTitle":"Vercel","url":"/webframeworks-cursus/wf-course/tools/vercel#wat-is-vercel","content":" Vercel is een cloudplatform voor het hosten van websites en webapplicaties. Het is ontworpen om de ontwikkeling en implementatie van webprojecten te vereenvoudigen, vooral die gebouwd met moderne frameworks en technologieën zoals Next.js, React, Angular en Vue.js.  Vercel staat ook bekend om zijn hoge prestaties. Het biedt snelle laadtijden door gebruik te maken van wereldwijde CDN (Content Delivery Network) en slimme caching, wat essentieel is voor het bieden van een goede gebruikerservaring en SEO.  Omdat Next.js is ontwikkeld door hetzelfde team achter Vercel, is de integratie tussen beide bijzonder soepel en efficiënt.  ","version":"Next","tagName":"h2"},{"title":"Hoe deploy ik een Next.js applicatie op Vercel?​","type":1,"pageTitle":"Vercel","url":"/webframeworks-cursus/wf-course/tools/vercel#hoe-deploy-ik-een-nextjs-applicatie-op-vercel","content":" ","version":"Next","tagName":"h2"},{"title":"Stap 1: Maak een Vercel account aan​","type":1,"pageTitle":"Vercel","url":"/webframeworks-cursus/wf-course/tools/vercel#stap-1-maak-een-vercel-account-aan","content":" Ga naar https://vercel.com/signup en maak een account aan. Je kan je Github account gebruiken om in te loggen.  ","version":"Next","tagName":"h3"},{"title":"Stap 2: Installeer de Vercel CLI​","type":1,"pageTitle":"Vercel","url":"/webframeworks-cursus/wf-course/tools/vercel#stap-2-installeer-de-vercel-cli","content":" De Vercel CLI is een command line tool die je kan gebruiken om je applicatie te deployen. Je kan deze installeren met npm:  npm install -g vercel   ","version":"Next","tagName":"h3"},{"title":"Stap 3: Deploy je applicatie​","type":1,"pageTitle":"Vercel","url":"/webframeworks-cursus/wf-course/tools/vercel#stap-3-deploy-je-applicatie","content":" Om je applicatie te deployen, moet je eerst inloggen met de Vercel CLI. Dit kan je doen met het volgende commando:  vercel login   Je kan vervolgens kiezen hoe je wil inloggen. Je kan inloggen met je Github account of met je email adres.  Vercel CLI 32.5.5 ? Log in to Vercel ● Continue with GitHub ○ Continue with GitLab ○ Continue with Bitbucket ○ Continue with Email ○ Continue with SAML Single Sign-On   Vervolgens moet je de link volgen die je krijgt om in te loggen en moet je de verificatie code gebruiken die je krijgt om in te loggen in de CLI.  &gt; Please visit the following URL in your web browser: &gt; https://vercel.com/api/registration/login-with-github?mode=login&amp;next=https%3A%2F%2Fvercel.com%2Fnotifications%2Fcli-login-oob &gt; After login is complete, enter the verification code printed in your browser. ? Verification code:   ","version":"Next","tagName":"h3"},{"title":"Stap 4: Builden en deployen​","type":1,"pageTitle":"Vercel","url":"/webframeworks-cursus/wf-course/tools/vercel#stap-4-builden-en-deployen","content":" Als je gebruik maakt van een lokaal gehoste CMS, moet je eerst je applicatie builden en kan je dit niet doen op vercel zelf. Dit moet dus lokaal gebeuren want Vercel heeft geen toegang tot je lokale machine.  vercel build --prod   Je krijgt vervolgens een aantal vragen die je moet beantwoorden. Je kan de standaardwaarden gebruiken.  Als de build klaar is, kan je je applicatie deployen met het volgende commando:  vercel deploy --prebuilt --prod   Als dit gelukt is krijg je een link naar je applicatie. Je kan deze link gebruiken om je applicatie te bekijken.  ","version":"Next","tagName":"h3"},{"title":"Stap 5: Publiek zetten van je applicatie​","type":1,"pageTitle":"Vercel","url":"/webframeworks-cursus/wf-course/tools/vercel#stap-5-publiek-zetten-van-je-applicatie","content":" By default staan je applicaties op Vercel op privé. Je kan dit aanpassen in de settings van je applicatie in het onderdeel: &quot;Deployment protection&quot;. Vervolgens zet je &quot;Vercel Authentication&quot; uit. Dan pas is je applicatie publiek toegankelijk.   ","version":"Next","tagName":"h3"},{"title":"JSON Server","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/tools/jsonserver","content":"","keywords":"","version":"Next"},{"title":"Opzetten​","type":1,"pageTitle":"JSON Server","url":"/webframeworks-cursus/wf-course/tools/jsonserver#opzetten","content":" Eerst heb je een JSON-bestand nodig met daarin de data die wordt aangeboden door de API. Plak hiervoor volgende gegevens in een bestand, dat je db.json noemt:  { &quot;people&quot;: [ {&quot;id&quot;: 1, &quot;name&quot;: &quot;Jane Doe&quot;, &quot;age&quot;: 34}, {&quot;id&quot;: 2, &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 35} ], &quot;events&quot;: [ {&quot;id&quot;: 1, &quot;title&quot;: &quot;verjaardagsfeestje&quot;, &quot;date&quot;: &quot;2022-07-01&quot;} ], &quot;reservations&quot;: [ {&quot;id&quot;: 1, &quot;location&quot;: &quot;springkasteel&quot;, &quot;date&quot;: &quot;2022-07-01&quot;} ] }   Start ten slotte de JSON server op: open via de terminal de locatie waar het opgeslagen bestand staat en voer het volgende commando uit:  npx json-server --watch db.json.   npx zorgt ervoor dat je bepaalde tools niet globaal moet installeren op je machine en dat je altijd de laatste nieuwe versie hebt.json-server, zegt gewoon dat je de json-server tool wil gebruiken.Via --watch geef je aan dat het programma wijzigingen aan het bestand moet opmerken.Het laatste deel, db.json, is de naam van het bestand met daarin je gegevens. Het is dus ook toegelaten een andere naam dan db.json te gebruiken, op voorwaarde dat je dat consequent doet.  notitie JSON server start op poort 3000. Als deze al in gebruik is, kan je een andere poort gebruiken door --port mee te geven, gevolgd door een ander poortnummer, bijvoorbeeld 3001.  Je zou nu een bericht zoals het volgende moeten zien:    ","version":"Next","tagName":"h2"},{"title":"Gebruik​","type":1,"pageTitle":"JSON Server","url":"/webframeworks-cursus/wf-course/tools/jsonserver#gebruik","content":" Surf naar de URL die in de screenshot aangegeven is onder &quot;Home&quot;. Je zou ongeveer het volgende scherm moeten zien:    Dit betekent dat je gebruik kan maken van HTTP requests (en dus van fetch) om gegevens over personen, evenementen of reservaties aan te maken, op te vragen, te wijzigen of te wissen (CRUD).  Dit is het makkelijkst te demonstreren via een HTTP GET-request, omdat dat vanzelf verstuurd wordt wanneer we in de browser naar een bepaalde URL navigeren. Als we bijvoorbeeld naar localhost:3000/people surfen, sturen we een GET-request naar deze URL. Het antwoord is dan een array in JSON-formaat. In de browser ziet dit er ongeveer zo uit (maar de weergave kan anders zijn naargelang je browserversie):    Het is ook mogelijk gegevens over een specifieke persoon op te vragen door de ID mee te geven als onderdeel van de URL. De URL voor persoon 1 wordt dan: localhost:3000/people/1:    ","version":"Next","tagName":"h2"},{"title":"Custom ID velden​","type":1,"pageTitle":"JSON Server","url":"/webframeworks-cursus/wf-course/tools/jsonserver#custom-id-velden","content":" JSON server veronderstelt dat elk opgeslagen object beschikt over een ID. Als je data probeert op te slaan die niet over een property id beschikken, voegt JSON server zelf een property id toe met een automatisch gegenereerde waarde.  Dit is niet altijd wat je wil. Als je zelf ID's genereert, moet je opstarten met de extra optie --id gevolgd door de naam van de property die je wil gebruiken. Bijvoorbeeld: json-server --watch --id uuid db.json. ","version":"Next","tagName":"h2"},{"title":"TypeScript Revisited","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited","content":"TypeScript Revisited Voordat we kunnen beginnen met React.js is het belangrijk om een aantal concepten van TypeScript nog eens te herhalen. Arrays/Objecten kopiëren met spread operatorOptional chainingLazy EvaluationDestructuring van arrays en objectenArray Methoden MapFilterFind Datatypes DictionariesSet ImmutabilityCallbacksPromises/Async/Fetch Zonder deze concepten goed te begrijpen is React.js leren een onmogelijke taak, dus zorg er zeker voor dat je alles goed begrijpt!","keywords":"","version":"Next"},{"title":"Array Methoden","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-methoden","content":"","keywords":"","version":"Next"},{"title":"Map​","type":1,"pageTitle":"Array Methoden","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-methoden#map","content":" De map() functie maakt een nieuwe array bestaande uit de resultaten van de callback functie op elk element van die array. Deze functie is de meest gebruikte functie in React.js, dus zorg er voor dat je deze onder de knie hebt.  Wil je bijvoorbeeld een array van getallen omzetten naar een nieuwe array maar waar de elementen verdubbeld zijn, kunnen we dit op de volgende manier doen  let numbers: number[] = [1,2,3,4,5]; let newArray: number[] = numbers.map(number =&gt; number * 2); console.log(newArray);   Als we dit met een for lus zouden willen doen:  let numbers: number[] = [1,2,3,4,5]; let newArray: number[] = []; for (let number of numbers) { newArray.push(number*2); } console.log(newArray);   We verkiezen altijd in react.js voor de oplossing met de map functie.  ","version":"Next","tagName":"h3"},{"title":"Filter​","type":1,"pageTitle":"Array Methoden","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-methoden#filter","content":" De filter() functie wordt heel vaak gebruikt bij het verbergen van bepaalde objecten in lijsten. Soms wil je niet de hele lijst van objecten te zien krijgen, maar een klein deel ervan dat voldoet aan een bepaalde filter.  characters.filter(age =&gt; age.age &gt;= 30);   geeft alleen de characters terug waarvan de leeftijd groter of gelijk is aan 30.  interface Character { name: string; age: number; } let characters = [ { name: &quot;Jinx&quot;, age: 16 }, { name: &quot;Caitlyn&quot;, age: 24 }, { name: &quot;Jayce&quot;, age: 30 }, { name: &quot;Victor&quot;, age: 30 }, { name: &quot;Heimerdinger&quot;, age: 307 } ]; console.log(characters.filter((age) =&gt; age.age &gt;= 30));   ","version":"Next","tagName":"h3"},{"title":"Reduce​","type":1,"pageTitle":"Array Methoden","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-methoden#reduce","content":" De reduce() methode herleid een array naar een enkele waarde aan de hand van de meegegeven reducer functie. De return value van deze reducer functie wordt doorgegeven als argument aan de volgende reducer functie.  Dit lijkt een beetje complex, dus even een voorbeeld: Stel dat je een lijst hebt van een aantal getallen: 1,2,3,4 dan kan je deze lijst herleiden (reduceren) tot de som van dit getal. De functie die het volgende getal optelt bij het vorige noemen we dan de reducer.  let numbers : number[] = [1,2,3,4]; console.log(numbers.reduce((sum, current)=&gt;sum+current)); // 10   Een voorbeeld waarvoor we reduce zouden kunnen gebruiken is het volgende: Stel dat we een lijst van objecten hebben met een id, en we willen een nieuw element toevoegen. Dan moeten we eerst op zoek gaan naar de hoogste id in de lijst objecten. We kunnen dit doen aan de hand van reduce:  interface Book { id: number; name: string; } let books : Book[] = [ { id: 0, name: &quot;Game of thrones&quot; }, { id: 1, name: &quot;Hitchhikers guide to the galaxy&quot; }, { id: 2, name: &quot;Witcher&quot; }, { id: 5, name: &quot;The expanse&quot; } ]; // highlight-next-line console.log(books.reduce((maxId, current) =&gt; (current.id &gt; maxId ? current.id : maxId), 0)); // 5   Je merkt hier op dat we hier een parameter 0 meegeven aan de reduce. Dat doen we omdat we hier de lijst niet willen reduceren tot een book object maar naar een getal. Daarom moeten we de start waarde meegeven.  ","version":"Next","tagName":"h3"},{"title":"Find​","type":1,"pageTitle":"Array Methoden","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-methoden#find","content":" De find() methode geeft de waarde terug van het eerste element van de array dat voldoet aan de meegegeven callback functie. Als er geen waarde voldoet aan de callback functie geeft deze undefined terug.  console.log(characters.find((age) =&gt; age.age == 30)); // {name: &quot;Jayce&quot;, age: 30} console.log(characters.find((age) =&gt; age.age == 0)); // undefined   ","version":"Next","tagName":"h3"},{"title":"Slice​","type":1,"pageTitle":"Array Methoden","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-methoden#slice","content":" Array.slice() is een functie die gebruikt wordt om een deel van een array te kopiëren (extracten) in een nieuwe array. Syntax:   array.slice( begin [,end] );   Parameter: Deze methode aanvaard twee parameters  begin : de zero based index van waar de extractie moet startenend : de zero based index van waar de extractie moet eindigen  Deze functie geeft een nieuwe array terug met daarin een deel van de array. De originele array wordt hier NIET aangepast.  let numbers: number[] = [0,1,2,3,4,5]; console.log(numbers.slice(0,2)); // [0,1] console.log(numbers.slice(2,4)); // [2,3] console.log(numbers.slice(4,6)); // [4,5]  ","version":"Next","tagName":"h3"},{"title":"Arrays/Objecten kopieren","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/arrays-objecten-kopieren","content":"","keywords":"","version":"Next"},{"title":"Spread operator​","type":1,"pageTitle":"Arrays/Objecten kopieren","url":"/webframeworks-cursus/wf-course/typescript-revisited/arrays-objecten-kopieren#spread-operator","content":" Het is vaak nodig in deze cursus om kopieën te maken van arrays. Je zou misschien denken dat de volgende code een kopie van een array maakt  let array : number[] = [1,2,3,4]; let newArray : number[] = array;   maar niets is minder waar! In de code hierboven wordt gewoon de referentie naar array toegewezen aan de variabele newArray. array en newArray verwijzen gewoon naar dezelfde plaats in het geheugen. Het onderstaande voorbeeld toont dit aan:  let array : number[] = [1,2,3,4]; let newArray : number[] = array; newArray.push(5); console.log(array); // 1,2,3,4,5 console.log(newArray); // 1,2,3,4,5   Als je een kopie van een array moet maken dan ga je gebruik moeten maken van de spread syntax (drie puntjes)  let array : number[] = [1,2,3,4]; let newArray : number[] = [...array]; newArray.push(5); console.log(array); // 1,2,3,4 console.log(newArray); // 1,2,3,4,5   Beide verwijzen nu naar een aparte plaats in het geheugen.  ","version":"Next","tagName":"h3"},{"title":"Objecten kopiëren​","type":1,"pageTitle":"Arrays/Objecten kopieren","url":"/webframeworks-cursus/wf-course/typescript-revisited/arrays-objecten-kopieren#objecten-kopiëren","content":" Het bovenstaande geldt ook voor objecten:  let andie = { name: 'Andie Similon', age: 37 }; let clone = andie; clone.name = 'Clone Similon'; console.log(andie); // Clone Similon console.log(clone); // Clone Similon   let andie = { name: 'Andie Similon', age: 37 }; let clone = {...andie}; clone.name = 'Clone Similon'; console.log(andie); // Andie Similon console.log(clone); // Clone Similon   Het is wel belangrijk dat je weet dat je hiermee enkel objecten kan kopiëren met 1 niveau diep.  let address = { street: '123 fakestreet' }; let andie = { name: 'Andie Similon', age: 37, address: address }; let clone = { ...andie }; clone.name = 'Clone Similon'; clone.address.street = '234 fakestreet'; console.log(andie.address.street); // 234 fakestreet console.log(clone.address.street); // 234 fakestreet   Beide address velden wijzen naar hetzelfde object.  Het kopiëren van objecten van meerdere niveau's diep noemen ze vaak een 'deep copy' van het object. De beste manier om dit te doen is momenteel door eerst het object om te zetten naar een JSON-string en dan direct terug om te zetten naar een object:  let address = { street: '123 fakestreet' }; let andie = { name: 'Andie Similon', age: 37, address: address }; let clone = JSON.parse(JSON.stringify(andie)); clone.name = 'Clone Similon'; clone.address.street = '234 fakestreet'; console.log(andie.address.street); // 123 Fakestreet console.log(clone.address.street); // 234 Fakestreet  ","version":"Next","tagName":"h3"},{"title":"Collections","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/collections","content":"Collections","keywords":"","version":"Next"},{"title":"Callbacks/Function types","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/callbacks-function-types","content":"Callbacks/Function types Een callback is een functie (functie A) die wordt meegegeven als parameter van een andere functie (functie B). Deze functie (B) zal dan de meegegeven functie (A) uitvoeren. Dit ziet er in code als volgt uit: interface Callback { (): void } let functionA = (functionB: Callback) =&gt; { functionB(); } let functionB: Callback = () =&gt; { console.log(&quot;Function B executed&quot;) } functionA(functionB); Wil je geen interface aanmaken kan je ook gebruik maken van TypeScript types rechtstreeks in de functie signature. let functionA = (functionB: () =&gt; void) =&gt; { functionB(); } Een voorbeeld van zo'n callback functie kan je hieronder vinden let sum = (a: number, b: number, callback: (sum: number) =&gt; void) =&gt; { callback(a + b); }; let printNumber = (number: number) =&gt; { console.log(number); }; sum(1, 2, printNumber); ","keywords":"","version":"Next"},{"title":"Array/Object Destructuring","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-object-destructuring","content":"","keywords":"","version":"Next"},{"title":"Array Destructuring​","type":1,"pageTitle":"Array/Object Destructuring","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-object-destructuring#array-destructuring","content":" Zoals je weet kan je aan de hand van de array index bepaalde elementen aanspreken van een array:  // Een array die een voornaam en achternaam bevat let arr : string[] = ['Andie', 'Similon']; let firstName = arr[0]; let lastName = arr[1]; console.log(firstName); // Andie console.log(lastName); // Similon   Dit kan je ook schrijven als:  // Een array die een voornaam en achternaam bevat let arr : string[] = ['Andie', 'Similon']; let [firstName, lastName] = arr; console.log(firstName); // Andie console.log(lastName); // Similon   Dit concept noemen we Array Destructuring  Wil je bepaalde elementen overslagen dan kan je dit doen op de volgende manier:  let arr : string[] = [&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;of the Roman Republic&quot;]; let [firstName, , title] = arr; console.log(title); // Consul   Wil je bijvoorbeeld alleen de eerste twee waarden in een variabele en de rest in een nieuwe array kan je dit doen aan de hand van de ... notatie:  let arr : string[] = ['Julius', 'Caesar', 'Consul', 'of the Roman Republic']; let [firstName, lastName, ...rest] = arr; console.log(firstName); // Julius console.log(lastName); // Caesar console.log(rest); // [&quot;Consul&quot;, &quot;of the Roman Republic&quot;];   De rest variabele bevat dan de array van de laatste twee elementen.  ","version":"Next","tagName":"h3"},{"title":"Object Destructuring​","type":1,"pageTitle":"Array/Object Destructuring","url":"/webframeworks-cursus/wf-course/typescript-revisited/array-object-destructuring#object-destructuring","content":" Hetzelfde concept kan je ook gebruiken bij objecten. In plaats van  interface Options { title: string; width?: number; height?: number; } let options : Options = { title: &quot;Menu&quot;, width: 100, height: 200 }; let title = options.title; let width = options.width; let height = options.height;   te doen kan je dit veel compacter schrijven aan de hand van object destructuring:  let options : Options = { title: &quot;Menu&quot;, width: 100, height: 200 }; let {title,width,height} = options;   de volgorde maakt hier ook niet uit zolang de namen maar overeenkomen met de keys van het object  let {width,title,height} = options;   mag dus ook.  Rest operator​  Uiteraard moet je hier niet alle keys opgeven en kan je ook maar een deel van de keys opgeven en de rest negeren:  let {title} = options;   Je kan hier net zoals bij arrays ook gebruik maken van de ... notatie (of rest operator)  let options : Options = { title: &quot;Menu&quot;, height: 200, width: 100 }; // title = property named title // rest = object with the rest of properties let {title, ...rest} = options; // now title=&quot;Menu&quot;, rest={height: 200, width: 100} alert(rest.height); // 200 alert(rest.width); // 100   Hernoemen van keys​  Willen we hier niet dezelfde namen gebruiken als de keys van het object is het ook mogelijk om deze een andere naam te geven:  let options : Options = { title: &quot;Menu&quot;, width: 100, height: 200 }; // { sourceProperty: targetVariable } let {width: w, height: h, title} = options; // width -&gt; w // height -&gt; h // title -&gt; title console.log(title); // Menu console.log(w); // 100 console.log(h); // 200   Default waarden​  Als je naar de interface van Options kijkt dan zie je dat de width en de height optioneel zijn. Als je deze leeg laat dan zijn width en height undefined bij het destructuren:  let options: Options = { title: 'Menu', }; let { title, width, height } = options; console.log(width); // undefined console.log(height); // undefined   wil je dit voorkomen kan je dit doen aan de hand van default waarden op te geven  let options: Options = { title: 'Menu', }; let { title, width = 100 , height = 200 } = options; console.log(width); // 100 console.log(height); // 200   Destructuring in functie parameters​  Je kan ook rechtstreeks in de functie parameters het object destructuren. Stel dat je de volgende functie hebt:  let options : Options = { title: &quot;Menu&quot;, width: 100, height: 200 }; const showOptions = (options: Options) =&gt; { console.log(options.title); console.log(options.width); console.log(options.height) } showOptions(options);   Je ziet hier dat we telkens de dot notatie moeten gebruiken voor title, width en height uit het options object moeten halen. Je zou uiteraard dit al kunnen vereenvoudigen door de showOptions functie als volgt te schrijven:  const showOptions = (options: Options) =&gt; { let {title,width, height} = options; console.log(title); console.log(width); console.log(height); } showOptions(options);   maar je kan dit zelfs nog korter door rechtstreeks in de functie parameters de destructuring operator te gebruiken:  const showOptions = ({title, width, height}: Options) =&gt; { console.log(title); console.log(width); console.log(height) }   Kort en bondig! Je kan dit zelfs combineren met default waarden  const showOptions = ({title, width = 200, height = 100}: Options) =&gt; { console.log(title); console.log(width); console.log(height) }   als width of height dan niet zijn ingegeven dan zullen hier de default waarden gebruikt worden.  Function parameters opschonen​  Het werken met object destructuring in functie parameters kan een manier zijn om functies met veel parameters te vereenvoudigen  const f = (a:number, b: number, c: number, d: string, e: number, f: number, g: boolean) =&gt; { // do something } f(0,2,4, &quot;test&quot;,.... Euh.... ik weet het niet meer!)   dit kan je ook herschrijven door alle parameters in een apart object in te pakken  interface Params { a:number, b: number, c: number, d: string, e: number, f: number, g: boolean } const f = ({a,b,c,d,e,f,g}: Params) =&gt; { // do something } f({a:0,b:2,c:4,d:&quot;test&quot;,e:6,f:8,g:true});   Zo zie je exact welke parameter bij welke naam hoort. ","version":"Next","tagName":"h3"},{"title":"Dictionary","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/collections/dictionary","content":"Dictionary Soms weet je niet op voorhand welke keys en values een bepaald object gaat bevatten. Dit is bijvoorbeeld het geval bij dictionaries. Een dictionary is een ongeordende data structuur die een verzameling elementen bevat. Om een element te vinden, moet je de &quot;key&quot; sleutel van een element kennen. Hieronder een voorbeeld in JavaScript waar we het paswoord van een gebruiker willen opslagen in een dictionary let passwords = {}; passwords['Andie'] = '1337h4x0r'; // hetzelfde als passwords.Andie passwords['Sven'] = 'H4ckerman'; // hetzelfde als passwords.Sven Als je dit gaat uitvoeren in TypeScript loop je direct tegen een probleem aan: er is geen interface voorzien voor dit object. Het is ook niet mogelijk om elke mogelijke key te voorspellen die deze dictionary gaat bevatten, dus je kan hier ook geen interface voor schrijven die je normaal gewoon bent. Als we zo'n dictionary willen gebruiken dan moeten we hiervoor een speciale interface maken interface PasswordDictionary { [key: string]: string } let passwords : PasswordDictionary = {}; passwords[&quot;Andie&quot;] = &quot;1337h4x0r&quot;; // hetzelfde als passwords.Andie passwords[&quot;Sven&quot;] = &quot;H4ckerman&quot;; // hetzelfde als passwords.Sven [key: string] zegt dat de key van de dictionary een string is. Dit noemen we een dynamic object key.: string geeft aan dat de values van de dictionary ook een string is. Deze types kunnen uiteraard anders zijn in een andere use case.","keywords":"","version":"Next"},{"title":"State","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/react/state","content":"","keywords":"","version":"Next"},{"title":"useState hook​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#usestate-hook","content":" We gaan het gebruik van state eens demonstreren aan de hand van een voorbeeld. We gaan hiervoor terug naar ons InputView voorbeeld. Stel dat we elke keer de gebruiker iets intypt in de input box, dat we deze text willen laten tonen ergens anders in de applicatie. Dit is dus informatie die aangepast wordt over de looptijd van de applicatie.  const InputView = () =&gt; { const handleChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { console.log(event.target.value); } return ( &lt;input type=&quot;text&quot; id=&quot;name&quot; onChange={handleChange} /&gt; ) }   We zouden foutief kunnen veronderstellen dat we dit probleem kunnen oplossen door een variabele te maken die de ingetypte tekst opslaat. Een verstaanbare poging is deze:  // DEZE CODE IS FOUT const InputView = () =&gt; { let name = &quot;&quot;; const handleChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { event = event.target.value; } return ( &lt;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; onChange={handleChange} /&gt; &lt;p&gt; The name you typed is {name} &lt;/p&gt; &lt;/&gt; ); }   Wijzigingen in het input veld hebben geen effect op de rest van de pagina. Elke render (en er vindt er niet eens een plaats wanneer de handler de waarde wijzigt) runt de code voor de component opnieuw. Er wordt dus telkens een nieuwe variabele name met beginwaarde &quot;&quot; aangemaakt.  In plaats van een gewone variabele is een state variabele nodig. Bij een wijziging hiervan wordt de component hertekend en de waarde wordt bijgehouden over uitvoeringen heen. Deze variabele kan aangemaakt worden door middel van de useState hook.  const [name, setName] = useState&lt;string&gt;('');   De useState functie heeft als argument een initiële state. Dit is de start waarde die de state zal krijgen als de component voor de eerste keer gerenderd wordt. De functie geeft een array terug met twee elementen in: het eerste element is de huidige state en het tweede element is een functie waarmee je de state kan en moet aanpassen. We geven aan welk type onze state zal bevatten door &lt;string&gt; mee te geven aan de useState functie.  import { useState } from &quot;react&quot;; const InputView = () =&gt; { const [name, setName] = useState&lt;string&gt;(''); const handleChange: React.ChangeEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { setName(event.target.value); } return ( &lt;&gt; &lt;input type=&quot;text&quot; id=&quot;name&quot; onChange={handleChange} value={name}/&gt; &lt;p&gt; The name you typed is {name} &lt;/p&gt; &lt;/&gt; ); }   Het value attribuut wordt ingesteld op de huidige waarde van de state. Zo zorgen we ervoor dat het inputveld altijd up-to-date is met de huidige waarde van de state. Dit noemen ze in react controlled components.  info Je mag meerdere keren useState gebruiken in 1 component. Bijvoorbeeld als je meerdere input velden hebt in je formulier zal je ook meerdere states hebben.  ","version":"Next","tagName":"h2"},{"title":"setState met callback​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#setstate-met-callback","content":" Soms is de nieuwe waarde van een state afhankelijk van de vorige waarde van de state. In dit geval moeten we de setState aanroepen met een callback functie als argument.  const App = () =&gt; { const [count, setCount] = useState(0); return ( &lt;&gt; Count: {count} &lt;button onClick={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt; &lt;button onClick={() =&gt; { setCount(count + 1); setCount(count + 1); // count is nog niet geupdated. } }&gt;+&lt;/button&gt; &lt;/&gt; ); }   In het bovenstaande voorbeeld zou je denken dat de count altijd met twee omhoog gaat. Maar dat is niet het geval. Als de tweede setCount wordt aangeroepen is de count state nog niet aangepast.  Wil je dit doen dan moet je dit op de volgende manier doen:  const App = () =&gt; { const [count, setCount] = useState(0); return ( &lt;&gt; Count: {count} &lt;button onClick={() =&gt; setCount(0)}&gt;Reset&lt;/button&gt; &lt;button onClick={() =&gt; { setCount(prevCount =&gt; prevCount + 1); setCount(prevCount =&gt; prevCount + 1); } }&gt;+&lt;/button&gt; &lt;/&gt; ); }   ","version":"Next","tagName":"h2"},{"title":"Regels van useState​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#regels-van-usestate","content":" Je mag geen useState hook gebruiken in:  loopsconditiesgeneste functies  Je moet altijd de useState hook gebruiken bovenaan je React component (functie).  Als je deze regels volgt dan ben je altijd zeker dat de useState hooks opgeroepen worden in dezelfde volgorde elke keer het component gerendered wordt.  setState mag uiteraard wel overal gebruikt worden in het component op eender welke plaats.  waarschuwing Er zullen meestal geen foutmeldingen ontstaan als je dit toch doet. Maar hierdoor kunnen heel moeilijk te debuggen bugs door kunnen onstaan. Dus let er op dat je deze regels zelf goed volgt!  Hier is een voorbeeld waar we de regels van de useState hook niet respecteren:  import { useState } from &quot;react&quot;; interface UserInfoProps { askAge: boolean; } const UserInfo = ({ askAge }: UserInfoProps) =&gt; { const [name, setName] = useState(&quot;&quot;); if (askAge) { const [age, setAge] = useState(0); // 1. Mag niet in een IF staan // 2. Moet altijd bovenaan de functie staan } return ( &lt;fieldset&gt; &lt;legend&gt;User Info&lt;/legend&gt; &lt;label htmlFor=&quot;name&quot;&gt;Name:&lt;/label&gt; &lt;input name=&quot;name&quot; type=&quot;text&quot; value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt; &lt;br /&gt; {askAge &amp;&amp; ( &lt;&gt; &lt;label htmlFor=&quot;name&quot;&gt;Age:&lt;/label&gt; &lt;input type=&quot;text&quot; value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt; &lt;/&gt; )} &lt;/fieldset&gt; ); }; const App = () =&gt; { const [askAge, setAskAge] = useState(false); return (&lt;&gt; &lt;label&gt;Ask age?&lt;/label&gt; &lt;input type=&quot;checkbox&quot; checked={askAge} onChange={(e) =&gt; setAskAge(e.target.checked)}/&gt; &lt;UserInfo askAge={askAge} /&gt; &lt;/&gt;); }; export default App;   De oplossing hier is de useState hook uit de if statement te zetten en bovenaan de functie.  ","version":"Next","tagName":"h2"},{"title":"Hoe state herkennen?​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#hoe-state-herkennen","content":" Bij elk component moet je de volgende vragen stellen:  Werd de data van buitenaf gegeven? Dan is het een prop.Blijft de date hetzelfde doorheen de levenscyclus van het component? Dan is het waarschijnlijk geen state.Is de data afgeleid van andere data in je component? Dan is het waarschijnlijk geen state.  We kunnen deze analyse eens uitvoeren op het volgende component:​   Show only in stock iPhone 12€ 699iPhone 12 Pro€ 999iPhone 12 Pro Max€ 1099Samsung Galaxy S20€ 799Samsung Galaxy S10€ 699Samsung Galaxy S20 Ultra€ 999Huawei P30€ 499Huawei P40€ 599Nokia 3310€ 399  We kunnen hier de volgende data herkennen:​  De originele lijst van productenDe tekst die in de zoekbalk is ingegevenDe waarde van de checkboxDe lijst van producten die gefilterd is op de zoektekst  Als we deze data analyseren, kunnen we de volgende conclusies trekken:​  De originele lijst van producten wordt niet aangepast. Er worden bijvoorbeeld geen producten toegevoegd of verwijderd. Dit is dus geen state.De tekst die in de zoekbalk is ingegeven, wordt aangepast door de gebruiker. Dit is dus state.De waarde van de checkbox wordt aangepast door de gebruiker. Dit is dus state.De gefilterde lijst van producten is afgeleid van de originele lijst en de tekst die in de zoekbalk is ingegeven. Dit is dus geen state.  info De uitwerking van dit voorbeeld kan je vinden op Voorbeelden  ","version":"Next","tagName":"h2"},{"title":"Array als state​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#array-als-state","content":" Een array als state definieren gebeurd op identiek dezelfde manier als een state met andere data types:  const App = () =&gt; { const [numbers, setNumbers] = useState&lt;number[]&gt;([0,1,2,3,4]); return ( &lt;&gt; &lt;table&gt; &lt;tbody&gt; {numbers.map((number, index) =&gt; &lt;tr key={index}&gt;&lt;td&gt;{number}&lt;/td&gt;&lt;/tr&gt;)} &lt;/tbody&gt; &lt;/table&gt; &lt;/&gt; ); };   Tot nu toe is er nog niets interactief aan de hand en hadden we de state even goed als een variabele kunnen declareren.  We voegen een invoerveld toe zoals we dit in het vorige deel hebben gedaan waarmee we een getal kunnen invoeren.  &lt;input type=&quot;number&quot; onChange={(event) =&gt; setNumber(parseInt(event.target.value))}/&gt;   en we maken hier ook ineens een controller component van:  const [number, setNumber] = useState&lt;number&gt;(0);   Nu willen we een button toevoegen die dit getal toevoegt aan de lijst van getallen als we op de knop duwen.  We zullen eerst laten zien hoe we dit NIET moeten doen:  // DEZE CODE IS FOUT const App = () =&gt; { const [numbers, setNumbers] = useState&lt;number[]&gt;([0,1,2,3,4]); const [number, setNumber] = useState&lt;number&gt;(0); const addClicked : React.MouseEventHandler&lt;HTMLButtonElement&gt; = () =&gt; { numbers.push(number); } return ( &lt;&gt; &lt;input type=&quot;number&quot; onChange={(event) =&gt; setNumber(parseInt(event.target.value))} value={number}/&gt; &lt;button onClick={addClicked}&gt;Add&lt;/button&gt; &lt;table&gt; &lt;tbody&gt; {numbers.map((number, index) =&gt; &lt;tr key={index}&gt;&lt;td&gt;{number}&lt;/td&gt;&lt;/tr&gt;)} &lt;/tbody&gt; &lt;/table&gt; &lt;/&gt; ); };   Als je deze code uitprobeert zie je dat er niets gebeurt. Pas nadat je terug op de knop duwt zal je element worden toegevoegd. Dat is omdat je niet de setNumber functie gebruikt om de state te zetten dus React weet niet dat het component opnieuw moet worden gerendered.  De volgende foute (maar begrijpelijke) veronderstelling zou zijn om gewoon hierna de setNumber functie aan te roepen, maar dit werkt ook niet:  // OOK FOUT! const addClicked : React.MouseEventHandler&lt;HTMLButtonElement&gt; = () =&gt; { numbers.push(number); setNumbers(numbers); }   Dit komt omdat je alle state objecten moet behandelen als readonly. Je mag dus nooit iets rechstreeks aanpassen aan het object.  ","version":"Next","tagName":"h2"},{"title":"Toevoegen aan array​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#toevoegen-aan-array","content":" Voor een array moeten we bij elke wijziging een kopie maken van de array en daar het element in toevoegen. Enkel dan kan React weten dat de array opnieuw gerendered moet worden.  Een kopie van een array doe je aan de hand van de spread syntax:  const App = () =&gt; { const [numbers, setNumbers] = useState&lt;number[]&gt;([0,1,2,3,4]); const [number, setNumber] = useState&lt;number&gt;(0); const addClicked : React.MouseEventHandler&lt;HTMLButtonElement&gt; = () =&gt; { setNumbers([...numbers, number]); } return ( &lt;&gt; &lt;input type=&quot;number&quot; onChange={(event) =&gt; setNumber(parseInt(event.target.value))} value={number}/&gt; &lt;button onClick={addClicked}&gt;Add&lt;/button&gt; &lt;table&gt; &lt;tbody&gt; {numbers.map((number, index) =&gt; &lt;tr key={index}&gt;&lt;td&gt;{number}&lt;/td&gt;&lt;/tr&gt;)} &lt;/tbody&gt; &lt;/table&gt; &lt;/&gt; ); };   ","version":"Next","tagName":"h3"},{"title":"Verwijderen van array​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#verwijderen-van-array","content":" Het verwijderen van elementen kan je doen aan de hand van een filter. We kunnen hier een removeNumber functie aanmaken die een i (de index) als argument aanvaard. Dit werkt omdat filter altijd een nieuwe array teruggeeft.  const App = () =&gt; { const [numbers, setNumbers] = useState&lt;number[]&gt;([0,1,2,3,4]); const removeNumber = (i : number) =&gt; { let numbersCpy = numbers.filter((number, index) =&gt; index !== i); setNumbers(numbersCpy); } return ( &lt;&gt; &lt;table&gt; &lt;tbody&gt; {numbers.map((number, index) =&gt; (&lt;tr key={index}&gt; &lt;td&gt;{number}&lt;/td&gt; &lt;td&gt;&lt;button onClick={() =&gt; { removeNumber(index); }}&gt;X&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt;) )} &lt;/tbody&gt; &lt;/table&gt; &lt;/&gt; ); };   ","version":"Next","tagName":"h3"},{"title":"Wijzigen in array​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#wijzigen-in-array","content":" Wil je een element wijzigen dan kan je dit doen door een kopie te maken van de array en het element te vervangen door een nieuw element. We kunnen hiervoor de map functie gebruiken. We mappen elk element van de array naar een nieuw element. Als het element dat we willen wijzigen is dan maken we een nieuw element aan, anders laten we het element ongewijzigd.  const App = () =&gt; { const [numbers, setNumbers] = useState&lt;number[]&gt;([0,1,2,3,4]); const modifyNumber = (i : number) =&gt; { let promptResult = prompt(&quot;Enter new number&quot;); if (promptResult) { let newNumber = parseInt(promptResult); let numbersCpy = numbers.map((oldNumber, index) =&gt; (index === i) ? newNumber : oldNumber); setNumbers(numbersCpy); } } return ( &lt;&gt; &lt;table&gt; &lt;tbody&gt; {numbers.map((number, index) =&gt; (&lt;tr key={index}&gt; &lt;td&gt;{number}&lt;/td&gt; &lt;td&gt;&lt;button onClick={() =&gt; { modifyNumber(index); }}&gt;Modify&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt;) )} &lt;/tbody&gt; &lt;/table&gt; &lt;/&gt; ); };   ","version":"Next","tagName":"h3"},{"title":"Object als state​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#object-als-state","content":" ","version":"Next","tagName":"h2"},{"title":"Object​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#object","content":" Een object kan je ook gebruiken als state. Je moet hier net zoals bij een array de spread syntax gebruiken om een kopie te maken van het object. Je kan dan de gewenste eigenschap aanpassen.  const App = () =&gt; { const [person, setPerson] = useState&lt;Person&gt;({name: &quot;John&quot;, age: 42}); const changeName = () =&gt; { setPerson({...person, name: &quot;Jane&quot;}); } return ( &lt;&gt; &lt;p&gt;{person.name} is {person.age} years old&lt;/p&gt; &lt;button onClick={changeName}&gt;Change name&lt;/button&gt; &lt;/&gt; ); }; export default App;   ","version":"Next","tagName":"h3"},{"title":"Dictionary​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#dictionary","content":" In het volgende code voorbeeld plaatsen we een object in een state zodat we dynamisch de keys en values van dit object kunnen aanpassen. Omdat het een object is met een niet op voorhand gedefinieerde interface moeten we een speciale interface gebruiken waar we gewoon aangeven welk type de key heeft en welk type de value (zie dictionary). Dit object mag net zoals een array niet rechtstreeks worden aangepast maar er moet een kopie voorzien worden.  interface Dictionary { [key: string]: string } const App = () =&gt; { const [dictionary, setDictionary] = useState&lt;Dictionary&gt;({}) const [key,setKey] = useState(&quot;&quot;); const [value,setValue] = useState(&quot;&quot;); const buttonClicked : React.MouseEventHandler&lt;HTMLButtonElement&gt; = () =&gt; { setDictionary({...dictionary, [key]:value}); } return ( &lt;&gt; &lt;div&gt; &lt;input placeholder=&quot;key&quot; type=&quot;text&quot; value={key} onChange={(event) =&gt; setKey(event.target.value)}/&gt; &lt;input placeholder=&quot;value&quot; type=&quot;text&quot; value={value} onChange={(event) =&gt; setValue(event.target.value)}/&gt; &lt;button onClick={buttonClicked}&gt;Set&lt;/button&gt; &lt;br/&gt; {JSON.stringify(dictionary)} &lt;/div&gt; &lt;/&gt; ); };   ","version":"Next","tagName":"h3"},{"title":"Voorbeelden​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#voorbeelden","content":" ","version":"Next","tagName":"h2"},{"title":"Select​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#select","content":" We beginnen van het Select voorbeeld dat we hebben gemaakt in het onderdeel over event handling. We gaan hier nu een controlled component van maken. Dit betekent dat we een state moeten aanmaken om de geselecteerde waarde van dit component bij te houden:  const [selectedBrand, setSelectedBrand] = useState(&quot;&quot;);   daarna zorg je dat de onChange prop een functie bevat die de state aanpast als het veld aangepast is. Ook zet je de value prop op de waarde van de state. Zo blijft die altijd up-to-date.  const App = () =&gt; { const [selectedBrand, setSelectedBrand] = useState(&quot;&quot;); return ( &lt;&gt; &lt;label htmlFor=&quot;cars&quot;&gt;Choose a car:&lt;/label&gt; &lt;select id=&quot;cars&quot; name=&quot;cars&quot; onChange={(event) =&gt; setSelectedBrand(event.target.value)} value={selectedBrand}&gt; &lt;option disabled value=&quot;&quot;&gt;Select an option&lt;/option&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;p&gt;You selected {selectedBrand}&lt;/p&gt; &lt;/&gt; ) }   ","version":"Next","tagName":"h3"},{"title":"Checkbox​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#checkbox","content":" Iets gelijkaardigs kunnen we nu doen met een Checkbox:  const App = () =&gt; { const [light, setLight] = useState(true); const backgroundStyle = {backgroundColor: light ? &quot;white&quot; : &quot;black&quot;}; return ( &lt;div style={{...containerStyle,...backgroundStyle}}&gt; &lt;input type=&quot;checkbox&quot; onChange={(event) =&gt; setLight(event.target.checked)} checked={light} /&gt; &lt;div style={centerBulb} onClick={() =&gt; {alert(`This light is ${light ? &quot;on&quot; : &quot;off&quot;}`)}}&gt; {light ? &lt;img src={require(&quot;./assets/lightbulb_on.png&quot;)}/&gt; : &lt;img src={require(&quot;./assets/lightbulb_off.png&quot;)}/&gt;} &lt;/div&gt; &lt;/div&gt; ) }   Je ziet hierboven dat je de waarde van de state op verschillende plaatsen kan aanspreken:  In een event handler van een ander element. Dit kan omdat de state ook in de scope van deze handler is.In plaats van de value prop gebruiken we hier de checked prop om de checked status te zetten van de checkbox.In de TSX zelf: we gebruiken de conditional operator (?) hier om de juiste image te tonen afhankelijk van de waarde van de state.  ","version":"Next","tagName":"h3"},{"title":"Radio button​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#radio-button","content":" Ook een reeks radio buttons heeft een achterliggende state nodig. We hebben per radio button een change listener nodig en hier maken we ook gebruik van de checked property.  import { useState } from &quot;react&quot;; const App = () =&gt; { const [favoriteLanguage, setFavoriteLanguage] = useState&lt;string&gt;(&quot;&quot;); return ( &lt;div className=&quot;App&quot;&gt; Please enter your favorite programming language: &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;fav_language&quot; value=&quot;TypeScript&quot; checked={favoriteLanguage === &quot;TypeScript&quot;} onChange={(event) =&gt; setFavoriteLanguage(event.target.value)}/&gt; &lt;label htmlFor=&quot;typescript&quot;&gt;TypeScript&lt;/label&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;fav_language&quot; value=&quot;C#&quot; checked={favoriteLanguage === &quot;C#&quot;} onChange={(event) =&gt; setFavoriteLanguage(event.target.value)}/&gt; &lt;label htmlFor=&quot;C#&quot;&gt;C#&lt;/label&gt; &lt;br /&gt; &lt;input type=&quot;radio&quot; name=&quot;fav_language&quot; value=&quot;PHP&quot; checked={favoriteLanguage === &quot;PHP&quot;} onChange={(event) =&gt; setFavoriteLanguage(event.target.value)}/&gt; &lt;label htmlFor=&quot;PHP&quot;&gt;PHP&lt;/label&gt; &lt;br/&gt; &lt;button onClick={() =&gt; { alert(`You selected ${favoriteLanguage}`)}}&gt;Click Me&lt;/button&gt; &lt;/div&gt; ); }   ","version":"Next","tagName":"h3"},{"title":"Select Multiple​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#select-multiple","content":" In het voorgaande voorbeeld kon je maar 1 item selecteren in de lijst. Als je wil werken met een multiselect is een state met een string hier niet voldoende voor. We moeten een array bijhouden van geselecteerde waarden.  const [selectedBrand, setSelectedBrand] = useState&lt;string[]&gt;([]);   Dat gaan we ook in een state doen. De logica hierachter is wel iets complexer.  const App = () =&gt; { const [selectedBrands, setSelectedBrands] = useState&lt;string[]&gt;([]); const brandChange : React.ChangeEventHandler&lt;HTMLSelectElement&gt; = (event) =&gt; { setSelectedBrands(Array.from(event.target.selectedOptions, option =&gt; option.value)); } return ( &lt;&gt; &lt;label htmlFor=&quot;cars&quot;&gt;Choose your favorite car brands:&lt;/label&gt; &lt;br/&gt; &lt;select id=&quot;cars&quot; name=&quot;cars&quot; onChange={brandChange} value={selectedBrands} multiple&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;/&gt; ) }   Je merkt hier het volgende stuk code op:  setSelectedBrands(Array.from(event.target.selectedOptions, option =&gt; option.value));   Dit zorgt ervoor dat we de selectedOptions omzetten naar een array en dan elk element mappen naar zijn waarde. Zo krijgen we een array van strings van de waarden. Vervolgens gebruiken we de setter van de state om de state te updaten naar de nieuwe lijst.  Je zou dit ook kunnen doen met een for loop:  const App = () =&gt; { const [selectedBrands, setSelectedBrands] = useState&lt;string[]&gt;([]); const brandChange : React.ChangeEventHandler&lt;HTMLSelectElement&gt; = (event) =&gt; { let selectedBrands: string[] = []; for (let option of event.target.selectedOptions) { selectedBrands.push(option.value); } setSelectedBrands(selectedBrands); } return ( &lt;&gt; &lt;label htmlFor=&quot;cars&quot;&gt;Choose your favorite car brands:&lt;/label&gt; &lt;br/&gt; &lt;select id=&quot;cars&quot; name=&quot;cars&quot; onChange={brandChange} value={selectedBrands} multiple&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;fiat&quot;&gt;Fiat&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;/&gt; ) }   ","version":"Next","tagName":"h3"},{"title":"Checkbox multiple​","type":1,"pageTitle":"State","url":"/webframeworks-cursus/wf-course/react/state#checkbox-multiple","content":" In het voorgaande voorbeeld hebben we gebruik gemaakt van 1 checkbox. In het onderstaande voorbeeld maken we een groep van checkboxes die aan elkaar gelinked zijn.  import { useState } from &quot;react&quot;; export default function App() { const [favoriteLanguages, setFavoriteLanguages] = useState&lt;string[]&gt;([]); const handleFavoriteLanguageChange : React.ChangeEventHandler&lt;HTMLInputElement&gt; = (event) =&gt; { if (event.target.checked) { // Add to the favorite list setFavoriteLanguages([...favoriteLanguages, event.target.value]); } else { // Remove from the favorite list setFavoriteLanguages(favoriteLanguages.filter((lang) =&gt; lang !== event.target.value)); } } return ( &lt;div className=&quot;App&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;Select the programming languages you like&lt;/legend&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fav_language&quot; value=&quot;TypeScript&quot; checked={favoriteLanguages.includes(&quot;TypeScript&quot;)} onChange={handleFavoriteLanguageChange}/&gt; &lt;label htmlFor=&quot;typescript&quot;&gt;TypeScript&lt;/label&gt; &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fav_language&quot; value=&quot;C#&quot; checked={favoriteLanguages.includes(&quot;C#&quot;)} onChange={handleFavoriteLanguageChange}/&gt; &lt;label htmlFor=&quot;C#&quot;&gt;C#&lt;/label&gt; &lt;br /&gt; &lt;input type=&quot;checkbox&quot; name=&quot;fav_language&quot; value=&quot;PHP&quot; checked={favoriteLanguages.includes(&quot;PHP&quot;)} onChange={handleFavoriteLanguageChange}/&gt; &lt;label htmlFor=&quot;PHP&quot;&gt;PHP&lt;/label&gt; &lt;br/&gt; &lt;/fieldset&gt; You selected: &lt;ul&gt; {favoriteLanguages.map((lang) =&gt; &lt;li&gt;{lang}&lt;/li&gt;)} &lt;/ul&gt; &lt;/div&gt; ); }   We hebben hier een aparte handler gemaakt voor de onChange listener. Die kijkt na of het element geselecteerd is, zo ja dan voegt hij het element toe aan de lijst en updated de state, anders wordt het element verwijderd uit de lijst. ","version":"Next","tagName":"h3"},{"title":"Modules","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/modules","content":"","keywords":"","version":"Next"},{"title":"Hoe modules gebruiken in TypeScript?​","type":1,"pageTitle":"Modules","url":"/webframeworks-cursus/wf-course/typescript-revisited/modules#hoe-modules-gebruiken-in-typescript","content":" Een module is een bestand dat variabelen, functies, interfaces of klassen bevat. Je kan sommige van deze publiekelijk beschikbaar maken zodat deze zichtbaar zijn vanuit andere modules. Dit doe je door deze te exporteren. Objecten die niet ge-exporteerd zijn zijn private.  ","version":"Next","tagName":"h2"},{"title":"Export​","type":1,"pageTitle":"Modules","url":"/webframeworks-cursus/wf-course/typescript-revisited/modules#export","content":" Om te laten zien hoe modules werken zullen we een heel simpele Math module maken. We maken hiervoor een bestand math.ts  // public door het export keyword. export const add = (a: number, b: number): number =&gt; { log(`${a} + ${b}`); return a + b; } // private. export const log = (message: string): void =&gt; { console.log(message); } // Mogelijk om 1 object als 'default' te exporteren. export default add;   ","version":"Next","tagName":"h3"},{"title":"Import​","type":1,"pageTitle":"Modules","url":"/webframeworks-cursus/wf-course/typescript-revisited/modules#import","content":" Het import keyword laat het toe om ge-exporteerde functies van een andere module te gebruiken. In dit geval willen we de add functie gebruiken van de Math module.  // We willen de add functie gebruiken van de math module import { add } from &quot;./math&quot;; console.log(add(1, 2));   Als we alle ge-exporteerde functies willen gebruiken van een module kunnen we de * syntax gebruiken.  // De math module als namespace importeren import * as Math from &quot;./math&quot;; // We gebruiken de add methode in de namespace math console.log(Math.add(1, 2));   Willen we enkel de default export gebruiken dan laten we de accolades weg.  // De math module als namespace importeren import add from &quot;./math&quot;; // We gebruiken de add methode in de namespace math console.log(add(1, 2));   ","version":"Next","tagName":"h3"},{"title":"Interfaces exporteren​","type":1,"pageTitle":"Modules","url":"/webframeworks-cursus/wf-course/typescript-revisited/modules#interfaces-exporteren","content":" Vaak plaats je alle interfaces die met een bepaald model te maken hebben in een apart bestand. Je kan deze ook gewoon exporteren en importeren zoals je dat deed hiervoor.  export interface Student { name: string; age: number } export interface Course { name: string; description: string; credits: number; }   en dan kan je deze importeren via het import keyword:  import { Student, Course } from &quot;./interfaces&quot;  ","version":"Next","tagName":"h3"},{"title":"Sets","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/collections/sets","content":"Sets Soms wil je voorkomen dat bepaalde waarden meerdere keren voorkomen in een lijst. Je zou hiervoor elke keer kunnen nakijken of een bepaalde waarde al in de array zit zoals hieronder: let users: string[] = []; let pushIfNotExists = (username: string) =&gt; { if (!users.includes(username)) { users.push(username); } }; pushIfNotExists(&quot;Andie&quot;); pushIfNotExists(&quot;Sven&quot;); pushIfNotExists(&quot;Andie&quot;); console.log(users); // [&quot;Andie&quot;,&quot;Sven&quot;] Dit is uiteraard een beetje veel code en ook zeer inefficiënt! We willen hier gebruik maken van een Set. Een set is een soort lijst die alleen maar unieke waarden kan bevatten. let users: Set&lt;string&gt; = new Set(); users.add(&quot;Andie&quot;); users.add(&quot;Sven&quot;); users.add(&quot;Andie&quot;); console.log(Array.from(users)); Wil je deze lijst gebruiken zoals een array moet je deze wel nog terug omzetten naar een Array aan de hand van de Array.from functie. Een concreet voorbeeld waar het gebruik van een Set interessant kan zijn is het volgende. interface Animal { name: string; category: string; } let animals : Animal[] = [ { name:&quot;Lion&quot;, category: &quot;carnivore&quot; }, { name:&quot;dog&quot;, category:&quot;pet&quot; }, { name:&quot;cat&quot;, category:&quot;pet&quot; }, { name:&quot;wolf&quot;, category:&quot;carnivore&quot; } ]; Stel dat we van deze dieren een lijst willen hebben van alle categorieën. We kunnen dit doen aan de hand van de map functie animals.map(animal =&gt; animal.category); // [&quot;carnivore&quot;,&quot;pet&quot;,&quot;pet&quot;,&quot;carnivore&quot;] Je ziet hierboven dat deze lijst dubbele waarden bevat. Willen we er nu voor zorgen dat alle dubbele waarden uit deze lijst worden gehaald kunnen we gebruik maken van een handig truukje met Set. We gebruiken de Set constructor om deze array om te zetten naar een Set en vervolgens zetten we deze terug om naar een Array aan de hand van de Array.from functie Array.from(new Set(animals.map((animal) =&gt; animal.category))); // [&quot;carnivore&quot;,&quot;pet&quot;] Het volledige voorbeeld: interface Animal { name: string; category: string; } let animals: Animal[] = [ { name: &quot;Lion&quot;, category: &quot;carnivore&quot; }, { name: &quot;dog&quot;, category: &quot;pet&quot; }, { name: &quot;cat&quot;, category: &quot;pet&quot; }, { name: &quot;wolf&quot;, category: &quot;carnivore&quot; } ]; console.log(Array.from(new Set(animals.map((animal) =&gt; animal.category)))); ","keywords":"","version":"Next"},{"title":"Immutability","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/immutability","content":"","keywords":"","version":"Next"},{"title":"Readonly​","type":1,"pageTitle":"Immutability","url":"/webframeworks-cursus/wf-course/typescript-revisited/immutability#readonly","content":" Wil je dat een bepaalde variabele niet aanpasbaar is, en dus immutable dan moet je hetreadonly keyword gebruiken:  interface User { readonly name: string; readonly age: number; } let user : User = { name: &quot;John&quot;, age: 30 }; user.age = 40; // Cannot assign to 'age' because it is a read-only property.   Je kan ook een array readonly maken zodat er na de creatie ervan geen nieuwe elementen meer kunnen toegevoegd worden:  let numbers : readonly number[] = [1,2,3]; numbers.push(4); // Property 'push' does not exist on type 'readonly number[]'.   ","version":"Next","tagName":"h3"},{"title":"Element toevoegen aan een array​","type":1,"pageTitle":"Immutability","url":"/webframeworks-cursus/wf-course/typescript-revisited/immutability#element-toevoegen-aan-een-array","content":" Je hebt tot nu toe altijd geleerd om elementen toe te voegen aan een array via de push array methode.  let numbers : readonly number[] = [1,2,3]; numbers.push(4);   Zoals je hierboven hebt gezien zal dit niet gaan met een readonly number[] data type.  Willen we toch dingen toevoegen aan zo'n array dan moeten we een kopie maken van deze array met daarachter het nieuwe element aan toegevoegd.  Achteraan de array toevoegen:​  let numbers: readonly number[] = [1,2,3]; numbers = [...numbers,4]; console.log(numbers);   Vooraan de array toevoegen:​  let numbers: readonly number[] = [1,2,3]; numbers = [4,...numbers]; console.log(numbers);   Op een bepaalde index toevoegen:​  Hiervoor heb je de array functie slice nodig.  Willen we een element op index 2 toevoegen (op de 3de plaats) dan doen we dit op de volgende manier:  let numbers: readonly string[] = [&quot;een&quot;,&quot;twee&quot;,&quot;vier&quot;]; numbers = [...numbers.slice(0, 2), &quot;drie&quot;, ...numbers.slice(2)]; console.log(numbers); // [&quot;een&quot;,&quot;twee&quot;,&quot;drie&quot;,&quot;vier&quot;]   Je zou dit kunnen veralgemenen in een zelfgeschreven functie  const addElementAtIndex = (array: readonly string[], index: number, element: string) =&gt; { return [...numbers.slice(0, index), element, ...numbers.slice(index)]; } let numbers: readonly string[] = [&quot;een&quot;, &quot;twee&quot;, &quot;vier&quot;]; console.log(addElementAtIndex(numbers, 2, &quot;drie&quot;)); // [&quot;een&quot;,&quot;twee&quot;,&quot;drie&quot;,&quot;vier&quot;] console.log(addElementAtIndex(numbers, 0, &quot;nul&quot;)); // [&quot;een&quot;,&quot;twee&quot;,&quot;drie&quot;,&quot;vier&quot;]   ","version":"Next","tagName":"h3"},{"title":"Element verwijderen van een array​","type":1,"pageTitle":"Immutability","url":"/webframeworks-cursus/wf-course/typescript-revisited/immutability#element-verwijderen-van-een-array","content":" Hetzelfde geldt voor het verwijderen van elementen van een immutable array. Je zou aan de hand van splice (niet te vergissen met slice) het element kunnen verwijderen. Maar dit gaat niet met een immutable array.  let numbers: readonly string[] = [ &quot;nul&quot;, &quot;een&quot;, &quot;twee&quot; ]; numbers.splice(0, 1); // Property 'splice' does not exist on type 'readonly string[]'   Om een nieuwe array aan te maken waar dit element niet in voorkomt kan je dit op twee manieren doen:  Verwijderen met slice​  Je neemt het eerste deel van de array dat je wil behouden gevolgd door het deel dat net achter het element komt dat je wil verwijderen. Wil je bijvoorbeeld het element op index 2 verwijderen kan je dat als volgt doen  let numbers: readonly string[] = [ &quot;nul&quot;, &quot;een&quot;, &quot;twee&quot;,&quot;drie&quot; ]; numbers = [...numbers.slice(0,2), ...numbers.slice(3)]; console.log(numbers); // [&quot;nul&quot;,&quot;een&quot;,&quot;drie&quot;]   of in een functie gegoten:  const removeElementAtIndex = (array: readonly string[], index: number) =&gt; [...numbers.slice(0,index), ...numbers.slice(index+1)];   Verwijderen met filter  Je gebruikt de filter methode van de array om alle elementen te filteren waarvan de index niet overeenkomt met de index die je wil verwijderen. Willen we het element op index 2 verwijderen doen we dit als volgt:  let numbers: readonly string[] = [ &quot;nul&quot;, &quot;een&quot;, &quot;twee&quot;,&quot;drie&quot; ]; numbers = numbers.filter((number,index) =&gt; index !== 2) console.log(numbers);   of weer in een aparte functie:  const removeElementAtIndex = (array: readonly string[], index: number) =&gt; arrays.filter((number,i) =&gt; i !== index)   ","version":"Next","tagName":"h3"},{"title":"Element aanpassen in een array​","type":1,"pageTitle":"Immutability","url":"/webframeworks-cursus/wf-course/typescript-revisited/immutability#element-aanpassen-in-een-array","content":" Je hebt het ondertussen door. Als een array immutable is kunnen we niet zomaar de index notatie gebruiken om de array aan te passen:  let numbers: readonly string[] = [ &quot;zes&quot;, &quot;een&quot;, &quot;twee&quot;,&quot;drie&quot; ]; numbers[0] = &quot;nul&quot;; // Index signature in type 'readonly string[]' only permits reading.ts(2542)   We kunnen dit oplossen aan de hand van de map functie. Willen we het element op index 0 aanpassen naar &quot;nul&quot; dan kunnen we dit op het volgende manier doen.  let numbers: readonly string[] = [ &quot;zes&quot;, &quot;een&quot;, &quot;twee&quot;,&quot;drie&quot; ]; numbers = numbers.map((val,i) =&gt; (i == 0) ? &quot;nul&quot; : val); console.log(numbers);   of weer in een aparte functie:  const updateElementAtIndex = (array: readonly string[],index: number, newValue: string) =&gt; array.map((val, i) =&gt; (i == index ? newValue : val));  ","version":"Next","tagName":"h3"},{"title":"Omgaan met null/undefined","type":0,"sectionRef":"#","url":"/webframeworks-cursus/wf-course/typescript-revisited/optional-chaining","content":"","keywords":"","version":"Next"},{"title":"Optional​","type":1,"pageTitle":"Omgaan met null/undefined","url":"/webframeworks-cursus/wf-course/typescript-revisited/optional-chaining#optional","content":" Soms heb je objecten waarbij niet alle properties een waarde hebben. In TypeScript moet je dit aangeven in de interface van dat object. Stel dat we een Options interface hebben die gebruikt wordt om een scherm in te stellen.  interface Options { title: string; width: number; height: number; }   Als je nu  let options : Options = { title: 'Hello World' }; // Type '{ title: string; }' is missing the following properties from type 'Options': width, height(2739)   doet dan krijg je een error in typescript want width en height zijn hier niet opgegeven.  Wil je dit toch toelaten dan moet je dit aangeven in de interface van Options aan de hand van de ? operator. Dit geeft aan dat een property optional is.  interface Options { title: string; width?: number; height?: number; }   ","version":"Next","tagName":"h3"},{"title":"Optional chaining​","type":1,"pageTitle":"Omgaan met null/undefined","url":"/webframeworks-cursus/wf-course/typescript-revisited/optional-chaining#optional-chaining","content":" Stel dat we de interface iets aanpassen en de width en de height in een apart object plaatsen. Dan krijgen we de volgende situatie  interface Size { width: number; height: number; } interface Options { title: string; size: Size } let options: Options = { title: 'Hello World', size: { width: 100, height: 100 } }; console.log(options.size.width); // 100   Als we nu size optioneel maken zoals hiervoor geraken we in de problemen. Onze compiler zal ons dan de volgende foutmelding geven:  interface Size { width: number; height: number; } interface Options { title: string; size?: Size } let options: Options = { title: 'Hello World', size: { width: 100, height: 100 } }; console.log(options.size.width); // Object is possibly 'undefined'   Omdat we size optioneel hebben gemaakt bestaat er een kans dat size undefined zou zijn. Dus de typescript compiler waarschuwt ons hiervoor. Hier kunnen we een aantal dingen aan doen. Je zou expliciet kunnen kijken of options.size gelijk is aan undefined aan de hand van een if statement:  let options: Options = { title: 'Hello World' }; if (options.size != undefined) { console.log(options.size.height); }   of je kan hier optional chaining gebruiken. Je gebruikt hier .? in plaats van de . operator:  console.log(options.size?.height); // undefined   en dan krijg je ook geen errors meer te zien. Als je optional chaining gebruikt dan zal de hele expressie als undefined gezien worden als een van de elementen undefined is. In dit geval is size undefined, dus dan zal de height hiervan ook undefined zijn.  ","version":"Next","tagName":"h3"},{"title":"?? Operator (Nullish Coalescing)​","type":1,"pageTitle":"Omgaan met null/undefined","url":"/webframeworks-cursus/wf-course/typescript-revisited/optional-chaining#-operator-nullish-coalescing","content":" Soms wil je een default waarde gebruiken als een property undefined is. Je kan dit doen met de ?? operator:  console.log(options.size?.height ?? 180); // 180   In dit geval wordt de height 180 als de height undefined is.  ","version":"Next","tagName":"h3"},{"title":"&& operator​","type":1,"pageTitle":"Omgaan met null/undefined","url":"/webframeworks-cursus/wf-course/typescript-revisited/optional-chaining#-operator","content":" De &amp;&amp; operator wordt gebruikt om een expressie te evalueren als de linkerkant true is. Als de linkerkant niet waar is dan zal de rechterkant niet geëvalueerd worden.  const hasLight = false; const turnOffLight = () =&gt; { console.log('Light is turned off'); }; hasLight &amp;&amp; turnOffLight();   In dit geval zal de turnOffLight functie niet aangeroepen worden omdat de hasLight false is.  Dit werkt ook met null en undefined:  const light = undefined; const turnOffLight = () =&gt; { console.log('Light is turned off'); }; light &amp;&amp; turnOffLight();   Er zijn veel waarden in JavaScript die als false/true gezien worden. Deze noemen we gewoonlijke truethy en falsy.  https://developer.mozilla.org/en-US/docs/Glossary/Falsyhttps://developer.mozilla.org/en-US/docs/Glossary/Truthy  ","version":"Next","tagName":"h3"},{"title":".! operator (Non-null assertion)​","type":1,"pageTitle":"Omgaan met null/undefined","url":"/webframeworks-cursus/wf-course/typescript-revisited/optional-chaining#-operator-non-null-assertion","content":" Heel zelden kom je in situaties terecht dat TypeScript denkt dat een bepaald veld undefined of null kan zijn. Als je zeker bent dat een bepaald veld nooit undefined kan zijn dan kan je ook de ! operator gebruiken om een &quot;Object is possibly undefined&quot; error te vermijden.  Bij de onderstaande code is de TypeScript compilator niet in staat zelf te bepalen of text undefined is of niet. Daarom moet je achter text een uitroepteken zetten om deze error te vermijden.  const duplicate = (text?: string) =&gt; { let fixString = () =&gt; { if (text === null || text === undefined) { text = &quot;&quot;; } }; fixString(); return text!.concat(text!); } console.log(duplicate(&quot;hello&quot;));   waarschuwing Gebruik dit alleen als je zeker bent dat het veld nooit undefined kan zijn. Anders kan je beter de .? operator gebruiken. Of zet je een default waarde aan de hand van de ?? operator. ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}