"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[3313],{28453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>s});var o=t(96540);const r={},i=o.createContext(r);function l(e){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),o.createElement(i.Provider,{value:n},e.children)}},53345:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"wf-course/react/child-parent/callbacks","title":"Child-Parent communicatie","description":"Tot nu toe hebben we altijd gezien dat je data kan doorgeven aan een component via properties (props). Dit is een manier om data van een parent component naar een child component door te geven.","source":"@site/docs/wf-course/react/child-parent/callbacks.md","sourceDirName":"wf-course/react/child-parent","slug":"/wf-course/react/child-parent/callbacks","permalink":"/webframeworks-cursus/wf-course/react/child-parent/callbacks","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15},"sidebar":"wfCourse","previous":{"title":"Communicatie tussen componenten","permalink":"/webframeworks-cursus/wf-course/react/child-parent/"},"next":{"title":"Context","permalink":"/webframeworks-cursus/wf-course/react/child-parent/context"}}');var r=t(74848),i=t(28453);const l={sidebar_position:15},s="Child-Parent communicatie",a={},d=[{value:"Welke aanpak verkiezen?",id:"welke-aanpak-verkiezen",level:2},{value:"Voorbeelden",id:"voorbeelden",level:2},{value:"Todo App met InputView",id:"todo-app-met-inputview",level:3},{value:"Todo App met delete functie",id:"todo-app-met-delete-functie",level:3},{value:"Checkbox lijst",id:"checkbox-lijst",level:3},{value:"Filter lijst",id:"filter-lijst",level:3},{value:"Lijst met een selectievakje",id:"lijst-met-een-selectievakje",level:3},{value:"Formulier met validatie",id:"formulier-met-validatie",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"child-parent-communicatie",children:"Child-Parent communicatie"})}),"\n",(0,r.jsx)(n.p,{children:"Tot nu toe hebben we altijd gezien dat je data kan doorgeven aan een component via properties (props). Dit is een manier om data van een parent component naar een child component door te geven."}),"\n",(0,r.jsxs)(n.p,{children:["Zo hadden we bijvoorbeeld een ",(0,r.jsx)(n.code,{children:"Square"})," component die een property ",(0,r.jsx)(n.code,{children:"color"})," had. Deze property werd doorgegeven vanuit de parent component ",(0,r.jsx)(n.code,{children:"App"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'interface SquareProps {\n    color: string\n}\n\nconst Square = ({color}: SquareProps) => {\n    return <div style={{width: 100, height: 100, backgroundColor: color}}></div>\n}\n\nconst App = () => {\n    return (\n        <>\n            <Square color="red"/>\n            <Square color="green"/>\n            <Square color="blue"/>\n        </>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Dit is een voorbeeld van parent-to-child communicatie. Stel je voor dat we de ",(0,r.jsx)(n.code,{children:"Square"})," component willen aanpassen als we op het vierkant klikken dan en deze dan een border krijgt. Dit kan je op de volgende manier doen:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface SquareProps {\n    color: string\n}\n\nconst Square = ({color}: SquareProps) => {\n    const [clicked, setClicked] = useState(false);\n    let borderStyle = clicked ? {border: "5px solid black"} : {};\n    return (\n        <div style={{width: 100, height: 100, backgroundColor: color, ...borderStyle}} onClick={() => setClicked(!clicked)}/>\n    );\n}\n\n//hide-start\nconst App = () => {\n    return (\n        <>\n            <Square color="red"/>\n            <Square color="green"/>\n            <Square color="blue"/>\n        </>\n    );\n}\n\nexport default App;\n//hide-end\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Elk component staat dus volledig op zichzelf en kan zijn eigen state bijhouden. Maar wat als we willen dat er maar \xe9\xe9n vierkant tegelijk geselecteerd kan zijn? Dus als we op een vierkant klikken, dan moet het andere vierkant zijn selectie verliezen. Dit kunnen we niet doen met de huidige opzet omdat elk component zijn eigen state bijhoudt. We moeten dus de state van welk vierkant geselecteerd is, bijhouden in de parent component ",(0,r.jsx)(n.code,{children:"App"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface SquareProps {\n    color: string,\n    selected: boolean,\n    onClick: () => void\n}\n\nconst Square = ({color, selected, onClick}: SquareProps) => {\n    let borderStyle = selected ? {border: "5px solid black"} : {};\n    return (\n        <div style={{width: 100, height: 100, backgroundColor: color, ...borderStyle}} onClick={onClick}/>\n    );\n}\n\nconst App = () => {\n    const [selectedColor, setSelectedColor] = useState<string | null>(null);\n\n    return (\n        <>\n            <Square color="red" selected={selectedColor === "red"} onClick={() => setSelectedColor("red")}/>\n            <Square color="green" selected={selectedColor === "green"} onClick={() => setSelectedColor("green")}/>\n            <Square color="blue" selected={selectedColor === "blue"} onClick={() => setSelectedColor("blue")}/>\n        </>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.p,{children:"Je ziet in het voorbeeld hierboven dat je dus perfect ook een functie kan doorgeven als property. Deze functie kan dan gebruikt worden om te communiceren van het child component naar het parent component. Dit concept noemen we callback functies of event handlers."}),"\n",(0,r.jsx)(n.p,{children:"Je ziet dat we hier een vereenvoudigde versie van de onClick handler hebben gemaakt en hier niet de event parameter gebruiken. Als we deze toch nodig hebben in de parent component dan kunnen we deze ook doorgeven:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\ninterface SquareProps {\n    color: string,\n    selected: boolean,\n    onClick: React.MouseEventHandler<HTMLDivElement>\n}\n\nconst Square = ({color, selected, onClick}: SquareProps) => {\n    let borderStyle = selected ? {border: "5px solid black"} : {};\n    return (\n        <div style={{width: 100, height: 100, backgroundColor: color, ...borderStyle}} onClick={onClick}/>\n    );\n}\n\nconst App = () => {\n    const [selectedColor, setSelectedColor] = useState<string | null>(null);\n\n    return (\n        <>\n            <Square color="red" selected={selectedColor === "red"} onClick={(e) => { console.log(e.currentTarget); setSelectedColor("red") }}/>\n            <Square color="green" selected={selectedColor === "green"} onClick={(e) => { console.log(e.currentTarget); setSelectedColor("green") }}/>\n            <Square color="blue" selected={selectedColor === "blue"} onClick={(e) => { console.log(e.currentTarget); setSelectedColor("blue") }}/>\n        </>\n    );\n}\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,r.jsx)(n.p,{children:"Het is ook mogelijk om de hele state en de state setter door te geven naar het child component. Maar dit is niet aan te raden omdat je dan de encapsulatie van het component doorbreekt. Het is beter om alleen de nodige properties en functies door te geven. Gebruik dit alleen als je echt geen andere optie hebt."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface SquareProps {\n    color: string,\n    selectedColor: string | null,\n    setSelectedColor: React.Dispatch<React.SetStateAction<string | null>>\n}\n\nconst Square = ({color, selectedColor, setSelectedColor}: SquareProps) => {\n    let borderStyle = selectedColor === color ? {border: "5px solid black"} : {};\n    return (\n        <div style={{width: 100, height: 100, backgroundColor: color, ...borderStyle}} onClick={() => setSelectedColor(color)}/>\n    );\n}\n\nconst App = () => {\n    const [selectedColor, setSelectedColor] = useState<string | null>(null);\n\n    return (\n        <>\n            <Square color="red" selectedColor={selectedColor} setSelectedColor={setSelectedColor}/>\n            <Square color="green" selectedColor={selectedColor} setSelectedColor={setSelectedColor}/>\n            <Square color="blue" selectedColor={selectedColor} setSelectedColor={setSelectedColor}/>\n        </>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.h2,{id:"welke-aanpak-verkiezen",children:"Welke aanpak verkiezen?"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Voorkeur"}),": geef enkel de nodige properties en callback functies door"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Child blijft eenvoudig en goed ge\xefsoleerd"}),"\n",(0,r.jsx)(n.li,{children:"Parent behoudt controle over de state"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["\u27a1\ufe0f ",(0,r.jsx)(n.strong,{children:"Optioneel"}),": geef de event handler rechtstreeks door (met de ",(0,r.jsx)(n.code,{children:"event"})," als parameter)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Handig als de parent informatie uit het event zelf nodig heeft (bv. ",(0,r.jsx)(n.code,{children:"e.currentTarget"}),")"]}),"\n",(0,r.jsx)(n.li,{children:"Iets meer koppeling tussen parent en child, maar nog steeds overzichtelijk"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["\u26a0\ufe0f ",(0,r.jsx)(n.strong,{children:"Af te raden"}),": geef de volledige state en setter door"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Doorbreekt de encapsulatie"}),"\n",(0,r.jsx)(n.li,{children:"Child wordt te afhankelijk van de interne logica van de parent"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"voorbeelden",children:"Voorbeelden"}),"\n",(0,r.jsx)(n.h3,{id:"todo-app-met-inputview",children:"Todo App met InputView"}),"\n",(0,r.jsxs)(n.p,{children:["We gaan een eenvoudige Todo app bouwen waar we de invoer in een aparte ",(0,r.jsx)(n.code,{children:"InputView"})," component plaatsen. De ",(0,r.jsx)(n.code,{children:"InputView"})," zal een callback functie krijgen om de nieuwe todo toe te voegen aan de lijst in de parent component ",(0,r.jsx)(n.code,{children:"App"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface InputViewProps {\n    onAddTodo: (todo: string) => void\n}\n\nconst InputView = ({onAddTodo}: InputViewProps) => {\n    const [inputValue, setInputValue] = useState("");\n\n    const handleAdd = () => {\n        if (inputValue.trim() !== "") {\n            onAddTodo(inputValue);\n            setInputValue("");\n        }\n    };\n\n    return (\n        <div>\n            <input type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)}/>\n            <button onClick={handleAdd}>Add Todo</button>\n        </div>\n    );\n}\n\nconst App = () => {\n    const [todos, setTodos] = useState<string[]>([]);\n\n    const addTodo = (todo: string) => {\n        setTodos([...todos, todo]);\n    };\n\n    return (\n        <div>\n            <h1>Todo List</h1>\n            <InputView onAddTodo={addTodo}/>\n            <ul>\n                {todos.map((todo, index) => (\n                    <li key={index}>{todo}</li>\n                ))}\n            </ul>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.h3,{id:"todo-app-met-delete-functie",children:"Todo App met delete functie"}),"\n",(0,r.jsxs)(n.p,{children:["Je kan deze zelfs nog uitbreiden met een ",(0,r.jsx)(n.code,{children:"TodoItem"})," component met een verwijder functie:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface InputViewProps {\n    onAddTodo: (todo: string) => void\n}\n\nconst InputView = ({onAddTodo}: InputViewProps) => {\n    const [inputValue, setInputValue] = useState("");\n\n    const handleAdd = () => {\n        if (inputValue.trim() !== "") {\n            onAddTodo(inputValue);\n            setInputValue("");\n        }\n    };\n\n    return (\n        <div>\n            <input type="text" value={inputValue} onChange={(e) => setInputValue(e.target.value)}/>\n            <button onClick={handleAdd}>Add Todo</button>\n        </div>\n    );\n}\n\ninterface TodoItemProps {\n    onDelete: () => void,\n    todo: string\n}\n\nconst TodoItem = ({onDelete, todo}: TodoItemProps) => {\n    return (\n        <li>\n            {todo} <button onClick={onDelete}>Delete</button>\n        </li>\n    );\n}\n\nconst App = () => {\n    const [todos, setTodos] = useState<string[]>([]);\n\n    const addTodo = (todo: string) => {\n        setTodos([...todos, todo]);\n    };\n\n    const deleteTodo = (index: number) => {\n        setTodos(todos.filter((_, i) => i !== index));\n    };\n\n    return (\n        <div>\n            <h1>Todo List</h1>\n            <InputView onAddTodo={addTodo}/>\n            <ul>\n                {todos.map((todo, index) => (\n                    <TodoItem key={index} todo={todo} onDelete={() => deleteTodo(index)}/>\n                ))}\n            </ul>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.h3,{id:"checkbox-lijst",children:"Checkbox lijst"}),"\n",(0,r.jsx)(n.p,{children:"We kunnen ook een lijst van checkboxen maken waarbij we de geselecteerde items in de parent component bijhouden:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface CheckboxProps {\n    label: string,\n    checked: boolean,\n    onChange: (checked: boolean) => void\n}\n\nconst Checkbox = ({label, checked, onChange}: CheckboxProps) => {\n    return (\n        <div>\n            <input type="checkbox" checked={checked} onChange={(e) => onChange(e.target.checked)}/>\n            <label>{label}</label>\n        </div>\n    );\n}\n\nconst App = () => {\n    const [selectedItems, setSelectedItems] = useState<string[]>([]);\n\n    const handleCheckboxChange = (item: string, isChecked: boolean) => {\n        if (isChecked) {\n            setSelectedItems([...selectedItems, item]);\n        } else {\n            setSelectedItems(selectedItems.filter(i => i !== item));\n        }\n    };\n\n    const items = ["Item 1", "Item 2", "Item 3"];\n\n    return (\n        <div>\n            <h1>Checkbox List</h1>\n            {items.map(item => (\n                <Checkbox\n                    key={item}\n                    label={item}\n                    checked={selectedItems.includes(item)}\n                    onChange={(isChecked) => handleCheckboxChange(item, isChecked)}\n                />\n            ))}\n            <div>\n                <h2>Selected Items:</h2>\n                <ul>\n                    {selectedItems.map(item => (\n                        <li key={item}>{item}</li>\n                    ))}\n                </ul>\n            </div>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.h3,{id:"filter-lijst",children:"Filter lijst"}),"\n",(0,r.jsx)(n.p,{children:"We kunnen ook een filter lijst maken waarbij we de filter tekst in de parent component bijhouden:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface FilterInputProps {\n    filterText: string,\n    onFilterChange: (text: string) => void\n}\n\nconst FilterInput = ({filterText, onFilterChange}: FilterInputProps) => {\n    return (\n        <div>\n            <input\n                type="text"\n                value={filterText}\n                onChange={(e) => onFilterChange(e.target.value)}\n                placeholder="Filter items..."\n            />\n        </div>\n    );\n}\n\nconst App = () => {\n    const [filterText, setFilterText] = useState("");\n\n    const items = ["Apple", "Banana", "Orange", "Grapes", "Mango"];\n\n    const filteredItems = items.filter(item =>\n        item.toLowerCase().includes(filterText.toLowerCase())\n    );\n\n    return (\n        <div>\n            <h1>Filter List</h1>\n            <FilterInput filterText={filterText} onFilterChange={setFilterText}/>\n            <ul>\n                {filteredItems.map(item => (\n                    <li key={item}>{item}</li>\n                ))}\n            </ul>\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.h3,{id:"lijst-met-een-selectievakje",children:"Lijst met een selectievakje"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface ShoppingItem {\n    name: ShoppingItem,\n    quantity: number\n}\n\ninterface SelectableItemProps {\n    item: string,\n    isSelected: boolean,\n    onSelect: (item: string) => void\n}\n\nconst SelectableItem = ({item, isSelected, onSelect}: SelectableItemProps) => {\n    return (\n        <div\n            style={{\n                padding: "10px",\n                margin: "5px",\n                border: isSelected ? "2px solid blue" : "1px solid gray",\n                cursor: "pointer"\n            }}\n            onClick={() => onSelect(item)}\n        >\n            {item}\n        </div>\n    );\n}\n\nconst App = () => {\n    const [selectedItem, setSelectedItem] = useState<string | null>(null);\n\n    const items = ["Item A", "Item B", "Item C", "Item D"];\n\n    return (\n        <div>\n            <h1>Selectable List</h1>\n            {items.map(item => (\n                <SelectableItem\n                    key={item}\n                    item={item}\n                    isSelected={selectedItem === item}\n                    onSelect={setSelectedItem}\n                />\n            ))}\n            {selectedItem && <div>Selected: {selectedItem}</div>}\n        </div>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsx)(n.h3,{id:"formulier-met-validatie",children:"Formulier met validatie"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import {useState} from "react";\n\ninterface FormProps {\n    onSubmit: (data: { name: string; email: string }) => void\n}\n\ninterface FormErrors {\n    name?: string;\n    email?: string;\n}\n\nconst Form = ({onSubmit}: FormProps) => {\n    const [name, setName] = useState("");\n    const [email, setEmail] = useState("");\n    const [errors, setErrors] = useState<{ name?: string; email?: string }>({});\n\n    const validate = () => {\n        const newErrors: FormErrors = {};\n        if (name.trim() === "") {\n            newErrors.name = "Name is required";\n        }\n        if (email.trim() === "") {\n            newErrors.email = "Email is required";\n        } else if (!/\\S+@\\S+\\.\\S+/.test(email)) {\n            newErrors.email = "Email is invalid";\n        }\n        setErrors(newErrors);\n        return Object.keys(newErrors).length === 0;\n    };\n\n    const handleSubmit = (e: React.FormEvent) => {\n        e.preventDefault();\n        if (validate()) {\n            onSubmit({name, email});\n            setName("");\n            setEmail("");\n            setErrors({});\n        }\n    };\n\n    return (\n        <form onSubmit={handleSubmit}>\n            <div>\n                <label>Name:</label>\n                <input type="text" value={name} onChange={(e) => setName(e.target.value)}/>\n                {errors.name && <span style={{color: "red"}}>{errors.name}</span>}\n            </div>\n            <div>\n                <label>Email:</label>\n                <input type="text" value={email} onChange={(e) => setEmail(e.target.value)}/>\n                {errors.email && <span style={{color: "red"}}>{errors.email}</span>}\n            </div>\n            <button type="submit">Submit</button>\n        </form>\n    );\n}\n\nconst App = () => {\n    const [submissions, setSubmissions] = useState<{ name: string; email: string }[]>([]);\n\n    const handleFormSubmit = (data: { name: string; email: string }) => {\n        setSubmissions([...submissions, data]);\n    };\n\n    return (\n        <div>\n            <h1>Form with Validation</h1>\n            <Form onSubmit={handleFormSubmit}/>\n            <h2>Submissions:</h2>\n            <ul>\n                {submissions.map((submission, index) => (\n                    <li key={index}>{submission.name} - {submission.email}</li>\n                ))}\n            </ul>\n        </div>\n    );\n}\n\nexport default App;\n'})})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);