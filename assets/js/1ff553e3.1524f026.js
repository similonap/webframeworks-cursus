"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[5221],{28453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>i});var r=t(96540);const o={},a=r.createContext(o);function d(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),r.createElement(a.Provider,{value:n},e.children)}},70090:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"wf-course/react/hooks/useEffect","title":"useEffect","description":"Side effects","source":"@site/docs/wf-course/react/hooks/useEffect.md","sourceDirName":"wf-course/react/hooks","slug":"/wf-course/react/hooks/useEffect","permalink":"/webframeworks-cursus/wf-course/react/hooks/useEffect","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"wfCourse","previous":{"title":"Hooks","permalink":"/webframeworks-cursus/wf-course/react/hooks/"},"next":{"title":"useRef","permalink":"/webframeworks-cursus/wf-course/react/hooks/useRef"}}');var o=t(74848),a=t(28453);const d={},i="useEffect",s={},c=[{value:"Side effects",id:"side-effects",level:2},{value:"Dependencies array",id:"dependencies-array",level:2},{value:"Geen dependencies",id:"geen-dependencies",level:3},{value:"Een lege array",id:"een-lege-array",level:3},{value:"Een array van states en props",id:"een-array-van-states-en-props",level:3},{value:"Side-effect cleanup",id:"side-effect-cleanup",level:2},{value:"Praktische voorbeelden",id:"praktische-voorbeelden",level:2},{value:"Oproepen van een API",id:"oproepen-van-een-api",level:3},{value:"Opslaan in LocalStorage",id:"opslaan-in-localstorage",level:3},{value:"Strict mode",id:"strict-mode",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"useeffect",children:"useEffect"})}),"\n",(0,o.jsx)(n.h2,{id:"side-effects",children:"Side effects"}),"\n",(0,o.jsx)(n.p,{children:"Een React component gebruikt props en/of state en bepaalt hiermee een output van het component (renderen van het component). Als het react component lijnen code bevat die niet rechtstreeks bijdragen aan deze output, dan noemen we deze side-effects."}),"\n",(0,o.jsx)(n.p,{children:"Voorbeelden van side-effects zijn fetch requests (API), DOM manipulaties, gebruiken van timer functies (setTimeout, setInterval), ..."}),"\n",(0,o.jsx)(n.p,{children:"We willen deze side-effect logica zo hard mogelijk scheiden van de de rest van het component. We willen nooit side-effect logica rechtsreeks in het component schrijven. We hebben geen controle over hoeveel keer een component zal worden gerendered. Dit betekent dus als we side-effect logica gewoon in het component zouden schrijven dat deze ook telkens zou worden uitgevoerd als het component gerendered wordt."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-non-strict", "filename": "src/App.tsx"}',children:'interface GreetProps {\n    name: string\n}\n\nconst Greet = ({ name } : GreetProps) => {\n  const message = `Hello, ${name}!`;       // Output gerelateerd\n  // Niet doen:\n  document.title = `Greetings to ${name}`; // Side-effect!\n  return <div>{message}</div>;             // Output gerelateerd\n}\n//hide-start\nconst App = () => {\n    return <Greet name="Andie"/>\n}\n\nexport default App;\n//hide-end\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Hoe kunnen we nu er voor zorgen dat de side-effect losgekoppeld wordt van de rest van onze rendering code? Hiervoor hebben we de ",(0,o.jsx)(n.code,{children:"useEffect()"})," hook. Aan deze hook kan je code meegeven die los van de rendering code wordt uitgevoerd."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-non-strict", "filename": "src/App.tsx"}',children:'import { useEffect } from "react";\n\ninterface GreetProps {\n    name: string\n}\n\nconst Greet = ({ name } : GreetProps) => {\n  const message = `Hello, ${name}!`;       // Output gerelateerd\n  useEffect(() => {\n    document.title = `Greetings to ${name}`; // Side-effect!\n  }, [name]);\n  return <div>{message}</div>;             // Output gerelateerd\n}\n//hide-start\nconst App = () => {\n    return <Greet name="Andie"/>\n}\n\nexport default App;\n//hide-end\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Het updaten van de titel van het document is duidelijk een side-effect omdat het niet rechtstreeks te bijdraagt tot de output van het component. Daarom plaatsen we ",(0,o.jsx)(n.code,{children:"document.title"})," in de callback en geven we die mee met de ",(0,o.jsx)(n.code,{children:"useEffect()"})," functie."]}),"\n",(0,o.jsxs)(n.p,{children:["We willen ook niet dat de titel van het document geupdated wordt elke keer dat het ",(0,o.jsx)(n.code,{children:"Greet"})," component gerendered wordt. Deze code mag enkel alleen maar uitgevoerd worden als de ",(0,o.jsx)(n.code,{children:"name"})," property veranderd. Dat is de reden waarom we deze meegeven in de dependency array."]}),"\n",(0,o.jsx)(n.h2,{id:"dependencies-array",children:"Dependencies array"}),"\n",(0,o.jsxs)(n.p,{children:["We hebben tot nu toe al kort gezien dat er een tweede argument kan worden meegegeven aan de ",(0,o.jsx)(n.code,{children:"useEffect()"})," hook. Deze bepaald wanneer de meegegeven callback zal worden uitgevoerd."]}),"\n",(0,o.jsx)(n.p,{children:"Er zijn een aantal manieren om deze dependency array te gebruiken:"}),"\n",(0,o.jsx)(n.h3,{id:"geen-dependencies",children:"Geen dependencies"}),"\n",(0,o.jsx)(n.p,{children:"De side-effect callback zal worden uitgevoerd na elke render van het component."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-non-strict", "filename": "src/App.tsx"}',children:'import { useEffect } from "react";\nconst App = () => {\n  useEffect(() => {\n    console.log("useEffect called");\n  });\n}\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,o.jsx)(n.p,{children:"Deze wordt in principe niet veel gebruikt."}),"\n",(0,o.jsx)(n.h3,{id:"een-lege-array",children:"Een lege array"}),"\n",(0,o.jsx)(n.p,{children:"De side-effect wordt 1 keer uitgevoerd na de eerste render. Daarna niet meer"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-non-strict", "filename": "src/App.tsx"}',children:'import { useEffect } from "react";\nconst App = () => {\n  useEffect(() => {\n    console.log("useEffect called only once!");\n  },[]);\n}\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,o.jsx)(n.p,{children:"Een voorbeeldgebruik hiervoor is bijvoorbeeld het inladen van gegevens van een API. Gewoonlijk wil je dit maar 1 keer doen."}),"\n",(0,o.jsx)(n.h3,{id:"een-array-van-states-en-props",children:"Een array van states en props"}),"\n",(0,o.jsx)(n.p,{children:"De side-effect wordt enkel uitgevoerd als een van de meegegeven dependencies veranderen."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-non-strict", "filename": "src/App.tsx"}',children:'//hide-start\nimport { useEffect, useState } from "react";\n//hide-end\nconst App = ({}) => {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    console.log("useEffect called when count changes");\n  },[count]);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,o.jsx)(n.h2,{id:"side-effect-cleanup",children:"Side-effect cleanup"}),"\n",(0,o.jsx)(n.p,{children:"Sommige side-effects hebben cleanup nodig: afsluiten van verbindingen, timers clearen."}),"\n",(0,o.jsx)(n.p,{children:"Je kan de cleanup code plaatsen in een functie die je als return waarde teruggeeft:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"useEffect(() => {\n  // Side-effect...\n  return () => {\n    // Side-effect cleanup...\n  };\n}, []);\n"})}),"\n",(0,o.jsx)(n.p,{children:"Een concreet voorbeeld hiervan is het zetten van een timer. Als we geen cleanup code voorzien worden timers nooit gestopt en blijven die gewoon lopen zelfs al veranderd hier de interval."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-non-strict", "filename": "src/App.tsx"}',children:'import { useEffect,useState } from "react";\n\ninterface TimerProps {\n  interval: number\n}\n\nconst Timer = ({interval} : TimerProps) => {\n  const [number, setNumber] = useState(0);\n  useEffect(() => {\n    let handle = setInterval(() => {\n       setNumber(number => number + 1);\n    },interval);\n\n    return () => {\n      clearInterval(handle);\n    }\n  },[interval]);\n\n  return <p>{number}</p>\n}\n\n\nconst App = () => {\n    const [timerInterval, setTimerInterval] = useState(1000);\n    return (\n      <>\n        <div>\n            <input type="range" min="1" max="2000" value={interval} onChange={(e) => setTimerInterval(parseInt(e.target.value))}/>\n            <label htmlFor="volume">{interval}</label>\n        </div>\n        <Timer interval={timerInterval} />\n      </>\n    );\n}\n\nexport default App;\n'})}),"\n",(0,o.jsx)(n.h2,{id:"praktische-voorbeelden",children:"Praktische voorbeelden"}),"\n",(0,o.jsx)(n.h3,{id:"oproepen-van-een-api",children:"Oproepen van een API"}),"\n",(0,o.jsxs)(n.p,{children:["Een perfect voorbeeld waar ",(0,o.jsx)(n.code,{children:"useEffect()"})," wordt gebruikt is het ophalen van data uit een API. We gaan in dit voorbeeld gebruik maken van de World Time API:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"http://worldtimeapi.org/api/timezone/Europe/Brussels\n"})}),"\n",(0,o.jsx)(n.p,{children:"De data voldoet aan de volgende interface:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface TimezoneInfo {\n    abbreviation: string;\n    client_ip: string;\n    datetime: Date;\n    day_of_week: number;\n    day_of_year: number;\n    dst: boolean;\n    dst_from: Date;\n    dst_offset: number;\n    dst_until: Date;\n    raw_offset: number;\n    timezone: string;\n    unixtime: number;\n    utc_datetime: Date;\n    utc_offset: string;\n    week_number: number;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Het ophalen van data heeft nooit direct invloed op het renderen van het component. Dit komt omdat dit asynchroon gebeurd, dus op de moment dat de API aangeroepen wordt is er nog geen data beschikbaar en het renderen van componenten in react kan nooit asynchroon gebeuren. Daarom moet deze code in een side effect gebeuren."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'//hide-start\nimport { useState, useEffect } from "react";\n\ninterface TimezoneInfo {\n    abbreviation: string;\n    client_ip: string;\n    datetime: Date;\n    day_of_week: number;\n    day_of_year: number;\n    dst: boolean;\n    dst_from: Date;\n    dst_offset: number;\n    dst_until: Date;\n    raw_offset: number;\n    timezone: string;\n    unixtime: number;\n    utc_datetime: Date;\n    utc_offset: string;\n    week_number: number;\n}\n//hide-end\nconst App = () => {\n    const [timezoneInfo, setTimezoneInfo] = useState<TimezoneInfo>();\n\n    useEffect(() => {\n        const fetchFunction = async() => {\n            let result = await fetch("https://worldtimeapi.org/api/timezone/Europe/Brussels");\n            let json : TimezoneInfo = await result.json(); \n\n            setTimezoneInfo(json);\n        }\n        fetchFunction();\n    },[]);\n\n    return (\n        <>\n            {timezoneInfo && (\n                <ul>\n                    <li>IP: {timezoneInfo.client_ip}</li>\n                    <li>TimeZone: {timezoneInfo.timezone}</li>\n                    <li>Time: {timezoneInfo.datetime}</li>\n                </ul>\n            )}\n\n        </>\n    );\n}\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,o.jsxs)(n.p,{children:["We gebruiken hier een ",(0,o.jsx)(n.code,{children:"useEffect"})," met een lege dependency array omdat we deze API call maar 1 keer willen uitvoeren bij het mounten van dit component."]}),"\n",(0,o.jsxs)(n.p,{children:["De callback die we meegeven aan ",(0,o.jsx)(n.code,{children:"useEffect"})," mag niet ",(0,o.jsx)(n.code,{children:"async"})," zijn dus we maken een aparte asynchrone functie die we dan in de ",(0,o.jsx)(n.code,{children:"useEffect"})," callback oproepen."]}),"\n",(0,o.jsx)(n.h3,{id:"opslaan-in-localstorage",children:"Opslaan in LocalStorage"}),"\n",(0,o.jsx)(n.p,{children:"Local storage laat toe bepaalde configuraties of user settings bij te houden in de browser van de gebruiker. Local storage kan bijvoorbeeld gebruikt worden om de inhoud van een veld op te slaan, zodat dit terug kan worden ingevuld wanneer de gebruiker de pagina opnieuw opent."}),"\n",(0,o.jsx)(n.p,{children:"We kunnen deze waarde alvast uitlezen bij het zetten van de default waarde van onze state. Veronderstel bijvoorbeeld een veld name voor de naam van de gebruiker:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'const [name, setName] = useState<string>(localStorage.getItem("name") ?? "");\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsx)(n.p,{children:"De operator ?? staat toe een defaultwaarde te voorzien. Als de waarde langs de linkerkant null of undefined is, wordt de waarde langs de rechterkant gebruikt."})}),"\n",(0,o.jsxs)(n.p,{children:["Door middel van een side-effect kunnen we elke wijziging aan de state variabele ",(0,o.jsx)(n.code,{children:"name"})," opslaan. Om dit te verwezenlijken moeten we ",(0,o.jsx)(n.code,{children:"name"})," in de dependency array meenemen zodat onze callback functie telkens wordt opgeroepen als deze veranderd."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-non-strict", "filename": "src/App.tsx"}',children:'//hide-start\nimport {useEffect, useState} from "react";\n//hide-end\nconst App = () => {\n  const [name, setName] = useState<string>(localStorage.getItem("name") ?? "");\n\n  useEffect(() => {\n    localStorage.setItem("name", name);\n  },[name]);\n\n  return (\n    <>\n      <input type="text" value={name} onChange={(e) => setName(e.target.value)}/>\n    </>\n  )\n}\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,o.jsx)(n.h2,{id:"strict-mode",children:"Strict mode"}),"\n",(0,o.jsx)(n.admonition,{type:"warning",children:(0,o.jsx)(n.p,{children:"Dit is geavanceerde leerstof. Dit legt uit waarom effects onverwacht twee keer worden uitgevoerd en hoe we dit kunnen oplossen. Begrijp je dit niet? Geen probleem, je kan dit overslaan. Dit zal je geen problemen geven bij het maken van de oefeningen."})}),"\n",(0,o.jsxs)(n.p,{children:["In de vorige voorbeelden hebben we gezegd dat de ",(0,o.jsx)(n.code,{children:"useEffect"})," hook met een lege dependency array maar 1 keer wordt uitgevoerd. Je zult opmerken dat deze useEffect hook toch 2 keer wordt uitgevoerd. Dit komt omdat de ",(0,o.jsx)(n.code,{children:"App"})," component in strict mode staat. Dit is een feature van React die ervoor zorgt dat componenten in development mode altijd een tweede keer worden gerendered. Dit is om te controleren of de rendering van het component geen side-effects heeft. Bijvoorbeeld: dat je useEffect hook een cleanup functie teruggeeft."]}),"\n",(0,o.jsxs)(n.p,{children:["Je kan dit uitschakelen door de ",(0,o.jsx)(n.code,{children:"React.StrictMode"})," component te verwijderen uit de ",(0,o.jsx)(n.code,{children:"index.tsx"})," file."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Zonder de ",(0,o.jsx)(n.code,{children:"StrictMode"})," component zal de ",(0,o.jsx)(n.code,{children:"useEffect"})," hook maar 1 keer worden uitgevoerd."]}),"\n",(0,o.jsxs)(n.p,{children:["Is het dan best dat je deze afzet? ",(0,o.jsx)(n.strong,{children:"Nee"})," want het kan je fouten in je code helpen opsporen. Je zal er dus voor moeten zorgen dat je altijd een ",(0,o.jsx)(n.code,{children:"cleanup"})," functie voorziet voor het opruimen van je vorige effect."]}),"\n",(0,o.jsxs)(n.p,{children:["Dit is vaak gemakkelijker gezegd dan gedaan. Want bijvoorbeeld wat doen we dan bij een API call? We kunnen de ",(0,o.jsx)(n.code,{children:"fetch"})," functie niet zomaar stoppen. We moeten dus een manier hebben waar we het resultaat kunnen negeren als de fetch nog bezig is op de moment dat de cleanup functie is aangeroepen."]}),"\n",(0,o.jsx)(n.p,{children:"We gaan in dit voorbeeld een aantal todos inlezen bij het mounten van een component"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'useEffect(( ) => {\n  let ignore = false;\n  fetch("https://jsonplaceholder.typicode.com/todos")\n    .then(response => response.json())\n    .then(todos =>{\n        if (!ignore) {\n          console.log("SET TODO")\n          setTodos(todos);\n        }\n    });\n  return () => {\n    // cleanup code\n    ignore = true;\n  }\n}, [])\n'})}),"\n",(0,o.jsx)(n.p,{children:"met async/await:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'useEffect(( ) => {\n  let ignore = false;\n  const fetchFunction = async() => {\n    let result = await fetch("https://jsonplaceholder.typicode.com/todos");\n    let json = await result.json(); \n    if (!ignore) {\n      console.log("SET TODO")\n      setTodos(json);\n    }\n  }\n  fetchFunction();\n  return () => {\n    // cleanup code\n    ignore = true;\n  }\n}, [])\n'})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}}}]);