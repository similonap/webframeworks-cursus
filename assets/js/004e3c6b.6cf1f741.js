"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[5240],{28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var o=r(96540);const t={},s=o.createContext(t);function a(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(s.Provider,{value:n},e.children)}},54373:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"wf-course/nextjs/proxy","title":"Proxy","description":"Een proxy is een soort middleware functie die verzoeken onderschept voordat ze worden afgehandeld door de eigenlijke route-handler. Dit kan nuttig zijn voor verschillende doeleinden, zoals authenticatie, logging, of het wijzigen van verzoeken en antwoorden.","source":"@site/docs/wf-course/nextjs/proxy.md","sourceDirName":"wf-course/nextjs","slug":"/wf-course/nextjs/proxy","permalink":"/webframeworks-cursus/wf-course/nextjs/proxy","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"wfCourse","previous":{"title":"Form Handling","permalink":"/webframeworks-cursus/wf-course/nextjs/forms"},"next":{"title":"Routing","permalink":"/webframeworks-cursus/wf-course/nextjs/routing"}}');var t=r(74848),s=r(28453);const a={},i="Proxy",d={},l=[{value:"De proxy implementeren",id:"de-proxy-implementeren",level:2},{value:"Auth Database functies",id:"auth-database-functies",level:2},{value:"Login Action aanmaken",id:"login-action-aanmaken",level:2},{value:"Opvragen van de gebruiker in het dashboard",id:"opvragen-van-de-gebruiker-in-het-dashboard",level:2},{value:"Uitloggen",id:"uitloggen",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"proxy",children:"Proxy"})}),"\n",(0,t.jsxs)(n.p,{children:["Een proxy is een soort ",(0,t.jsx)(n.code,{children:"middleware"})," functie die verzoeken onderschept voordat ze worden afgehandeld door de eigenlijke route-handler. Dit kan nuttig zijn voor verschillende doeleinden, zoals authenticatie, logging, of het wijzigen van verzoeken en antwoorden."]}),"\n",(0,t.jsx)(n.p,{children:"We gaan in dit hoofdstuk een eenvoudige proxy implementeren om authenticatie toe te voegen aan onze Next.js applicatie. We zullen een proxy maken die controleert of een gebruiker is ingelogd voordat ze toegang krijgen tot bepaalde routes. We gaan hier gebruik maken van JSON Web Tokens (JWT) voor authenticatie."}),"\n",(0,t.jsx)(n.h2,{id:"de-proxy-implementeren",children:"De proxy implementeren"}),"\n",(0,t.jsxs)(n.p,{children:["Om een proxy te implementeren in Next.js, maken we een bestand genaamd ",(0,t.jsx)(n.code,{children:"proxy.ts"})," in de root van onze applicatie. In dit bestand zullen we de logica schrijven om te controleren of een gebruiker is ingelogd."]}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"proxy.ts"})," kunnen we de volgende code toevoegen:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { cookies } from "next/headers";\nimport { NextResponse } from "next/server";\nimport type { NextRequest } from "next/server";\n \nexport async function proxy(request: NextRequest) {\n    return NextResponse.next();\n}\n\nexport const config = {\n  matcher: ["/","/dashboard"],\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Momenteel staat de proxy alleen maar toe dat alle verzoeken doorgaan. De matcher zorgt ervoor dat de proxy alleen wordt toegepast op de routes ",(0,t.jsx)(n.code,{children:"/"})," en ",(0,t.jsx)(n.code,{children:"/dashboard"}),". Dit wil zeggen dat we alleen authenticatie gaan afdwingen op deze routes."]}),"\n",(0,t.jsxs)(n.p,{children:["Voor authenticatie gaan we gebruik maken van JWT tokens die we opslaan in een http-only cookie. We gaan de proxy aanpassen om te controleren of deze cookie aanwezig is en geldig is. Hiervoor installeren we eerst de ",(0,t.jsx)(n.code,{children:"jsonwebtoken"})," package:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"npm install jsonwebtoken\n"})}),"\n",(0,t.jsx)(n.p,{children:"Nu kunnen we de proxy aanpassen om de JWT te verifi\xebren:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const cookieStore = await cookies();\nconst jwtCookie = cookieStore.get("jwt");\n\nif (jwtCookie) {\n    jwt.verify(jwtCookie.value, process.env.JWT_SECRET!, (err, decoded) => {\n        if (err) return NextResponse.redirect(new URL("/auth/login", request.url));\n        return NextResponse.next();\n    });\n} else {\n    return NextResponse.redirect(new URL("/auth/login", request.url));\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Je kan heel eenvoudig de cookies uitlezen met de ",(0,t.jsx)(n.code,{children:"cookies"})," functie van Next.js. We proberen de JWT cookie op te halen en verifi\xebren deze met behulp van de ",(0,t.jsx)(n.code,{children:"jsonwebtoken"})," package. Als de cookie geldig is, laten we het verzoek doorgaan met ",(0,t.jsx)(n.code,{children:"NextResponse.next()"}),". Als de cookie ontbreekt of ongeldig is, wordt de gebruiker doorgestuurd naar de inlogpagina. Je moet ervoor zorgen dat je een geheim sleutel (",(0,t.jsx)(n.code,{children:"JWT_SECRET"}),") hebt ingesteld in je omgevingsvariabelen voor het verifi\xebren van de JWT."]}),"\n",(0,t.jsx)(n.h2,{id:"auth-database-functies",children:"Auth Database functies"}),"\n",(0,t.jsxs)(n.p,{children:["We hebben een functie nodig om gebruikers op te halen uit onze database. We maken een bestand ",(0,t.jsx)(n.code,{children:"database/auth.ts"})," aan met de volgende inhoud:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Collection, MongoClient } from "mongodb";\nimport { User } from "@/types";\nimport bcrypt from "bcrypt";\n\nconst client = new MongoClient(process.env.MONGODB_URI!);\n\nexport const userCollection: Collection<User> = client.db("auth-jwt").collection<User>("users");\n\nconst DUMMY_USERS: User[] = [\n    {\n        id: "1",\n        email: "jon.doe@acme.com",\n        name: "Jon Doe",\n        avatar: "jon-doe.jpg",\n        passwordHash: bcrypt.hashSync("password123", 10)\n    },\n    {\n        id: "2",\n        email: "alice.doe@acme.com",\n        name: "Alice Doe",\n        avatar: "alice-doe.jpg",\n        passwordHash: bcrypt.hashSync("mypassword", 10)\n    }\n]\n\nexport const seedDummyUsers = async () => {\n    const existingUsers = await userCollection.find({}).toArray();\n    if (existingUsers.length === 0) {\n        await userCollection.insertMany(DUMMY_USERS);\n        console.log("Dummy users seeded to the database.");\n    } else {\n        console.log("Database already has users. Skipping seeding.");\n    }\n}\n\nexport const findUserByEmail = async (email: string): Promise<User | null> => {\n    return await userCollection.findOne({ email });\n}\n\nexport const createUser = async (user: User): Promise<void> => {\n    await userCollection.insertOne(user);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Als je de ",(0,t.jsx)(n.code,{children:"seedDummyUsers"})," functie wil aanroepen bij het opstarten van de applicatie, kun je dit doen in een apart bestand genaamd ",(0,t.jsx)(n.code,{children:"instrumentation.ts"}),". Deze naam is misschien wat verwarrend, maar we gebruiken dit bestand om code uit te voeren bij het opstarten van de applicatie. Deze moet in de root van de applicatie staan:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { seedDummyUsers } from "@/database/auth";\n\n \nexport function register() {\n  seedDummyUsers().catch(err => console.error("Error seeding dummy users:", err));\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"login-action-aanmaken",children:"Login Action aanmaken"}),"\n",(0,t.jsxs)(n.p,{children:["We maken een bestand ",(0,t.jsx)(n.code,{children:"actions/authActions.ts"})," aan om de login actie te verwerken. Hier is een voorbeeld van hoe je dit kunt implementeren:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'"use server";\n\nimport { validateEmail, validatePassword } from "@/utils/validation";\nimport jwt from "jsonwebtoken";\nimport { redirect } from "next/navigation";\nimport { cookies } from "next/headers";\nimport { findUserByEmail } from "@/database/auth";\n\ninterface LoginState {\n    errors: {\n        email: string[];\n        password: string[];\n        general: string[];\n    };\n    email: string;\n    success: boolean;\n}\n\nexport const login = async (prevState: LoginState, formData: FormData): Promise<LoginState> => {\n    let email = formData.get("email")?.toString() ?? "";\n    let password = formData.get("password")?.toString() ?? "";\n\n    let emailErrors: string[] = validateEmail(email);\n    let passwordErrors: string[] = validatePassword(password);\n\n    if (emailErrors.length > 0 || passwordErrors.length > 0) {\n        return {\n            errors: {\n                email: emailErrors,\n                password: passwordErrors,\n                general: []\n            },\n            email: email,\n            success: false\n        }\n    }\n\n    const user = await findUserByEmail(email);\n\n    if (!user) {\n        return {\n            errors: {\n                general: ["Invalid email or password"],\n                email: [],\n                password: []\n            },\n            email: email,\n            success: false\n        }\n    }\n\n    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);\n\n    if (!isPasswordValid) {\n        return {\n            errors: {\n                general: ["Invalid email or password"],\n                email: [],\n                password: []\n            },\n            email: email,            \n            success: false\n        }\n    }\n\n    const token = jwt.sign(\n        {\n            id: user.id,\n            email: user.email,\n            name: user.name,\n            avatar: user.avatar\n        },\n        process.env.JWT_SECRET!,\n        {\n            expiresIn: "1h"\n        }\n    );\n\n    const cookieStore = await cookies();\n\n    cookieStore.set({\n        name: "jwt",\n        value: token,\n        httpOnly: true,\n        sameSite: "lax",\n        secure: true,\n    });\n\n    redirect("/dashboard");\n\n    return {\n        success: true,\n        email: email,\n        errors: {\n            email: [],\n            password: [],\n            general: []\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We geven hier een ",(0,t.jsx)(n.code,{children:"LoginState"})," interface mee om de status van de login actie bij te houden. De ",(0,t.jsx)(n.code,{children:"login"})," functie valideert de invoer, controleert de gebruikersgegevens in de database, genereert een JWT token en stelt deze in als een http-only cookie. Als de login succesvol is, wordt de gebruiker doorgestuurd naar het dashboard."]}),"\n",(0,t.jsx)(n.p,{children:"Hier onder een voorbeeld van hoe je de login actie kunt aanroepen vanuit een React component:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'"use client";\n\nimport { useActionState } from "react";\nimport { login } from "@/actions/authActions";\n\nconst LoginPage = () => {\n  const [state, loginAction, pending] = useActionState(login, {\n    success: false,\n    email: "",\n    errors: { email: [], password: [], general: [] },\n  });\n\n  return (\n    <div className="flex min-h-screen items-center justify-center p-4">\n      <div className="w-full max-w-sm rounded-lg border border-gray-200 p-6 shadow-sm">\n        \n        <h1 className="mb-2 text-2xl font-bold">Login</h1>\n        <p className="mb-6 text-sm text-gray-500">\n          Enter your email below to login to your account\n        </p>\n\n        {state.errors.general.length > 0 && (\n          <div className="mb-4 rounded bg-red-50 p-3 text-sm text-red-600">\n            {state.errors.general.join(", ")}\n          </div>\n        )}\n\n        <form action={loginAction} className="space-y-4">\n          <div>\n            <label htmlFor="email" className="mb-1 block text-sm font-medium">\n              Email\n            </label>\n            <input\n              id="email"\n              name="email"\n              type="text"\n              placeholder="m@example.com"\n              defaultValue={state.email}\n              className={`w-full rounded-md border px-3 py-2 text-sm outline-none focus:ring-2 ${\n                state.errors.email.length > 0\n                  ? "border-red-500 focus:ring-red-500"\n                  : "border-gray-300 focus:ring-blue-500"\n              }`}\n            />\n            {state.errors.email.map((error, index) => (\n              <p key={index} className="mt-1 text-xs text-red-500">\n                {error}\n              </p>\n            ))}\n          </div>\n          <div>\n            <label htmlFor="password" className="mb-1 block text-sm font-medium">\n              Password\n            </label>\n            <input\n              id="password"\n              name="password"\n              type="password"\n              placeholder="Your password"\n              className={`w-full rounded-md border px-3 py-2 text-sm outline-none focus:ring-2 ${\n                state.errors.password.length > 0\n                  ? "border-red-500 focus:ring-red-500"\n                  : "border-gray-300 focus:ring-blue-500"\n              }`}\n            />\n            {state.errors.password.map((error, index) => (\n              <p key={index} className="mt-1 text-xs text-red-500">\n                {error}\n              </p>\n            ))}\n          </div>\n          <button\n            type="submit"\n            disabled={pending}\n            className="w-full rounded-md bg-black px-4 py-2 text-sm font-medium text-white hover:bg-gray-800 disabled:cursor-not-allowed disabled:opacity-50"\n          >\n            {pending ? "Logging in..." : "Login"}\n          </button>\n        </form>\n      </div>\n    </div>\n  );\n};\n\nexport default LoginPage;\n'})}),"\n",(0,t.jsx)(n.h2,{id:"opvragen-van-de-gebruiker-in-het-dashboard",children:"Opvragen van de gebruiker in het dashboard"}),"\n",(0,t.jsxs)(n.p,{children:["In het dashboard kunnen we de gebruiker opvragen door de JWT token uit de cookie te lezen en te decoderen. Hier is een voorbeeld van hoe je dit kunt doen in de ",(0,t.jsx)(n.code,{children:"dashboard/page.tsx"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { getCurrentUser, logout } from "@/actions/authActions";\nimport Image from "next/image";\n\nexport default async function Page() {\n  const user = await getCurrentUser();\n\n  return (\n    <div className="flex min-h-screen flex-col items-center justify-center bg-gray-100 p-4">\n      <div className="w-full max-w-md rounded-lg border border-gray-200 bg-white shadow-sm">\n        <div className="p-6">\n            <h1 className="text-2xl font-bold tracking-tight">Dashboard</h1>\n        </div>\n        <div className="flex flex-col items-center gap-6 p-6 pt-0">\n          {user.avatar && (\n            <div className="overflow-hidden rounded-full border border-gray-200">\n                <Image\n                src={`/${user.avatar}`}\n                alt={user.name}\n                width={100}\n                height={100}\n                className="h-[100px] w-[100px] object-cover"\n                />\n            </div>\n          )}\n          <div className="text-center">\n            <p className="text-lg font-medium text-gray-900">Welcome, {user.name}!</p>\n            <p className="text-sm text-gray-500">Your email: {user.email}</p>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["en de ",(0,t.jsx)(n.code,{children:"getCurrentUser"})," actie in de ",(0,t.jsx)(n.code,{children:"actions/authActions.ts"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export const getCurrentUser = async (): Promise<User> => {\n    const cookieStore = await cookies();\n    const jwtCookie = cookieStore.get("jwt");\n\n    if (!jwtCookie) {\n        throw new Error("You\'re not logged in");\n    }\n\n    try {\n        const decoded = jwt.verify(jwtCookie.value, process.env.JWT_SECRET!) as User;\n        return decoded;\n    } catch (e) {\n        throw new Error("Invalid token");\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"uitloggen",children:"Uitloggen"}),"\n",(0,t.jsxs)(n.p,{children:["We kunnen een eenvoudige uitlogactie toevoegen die de JWT cookie verwijdert. Hier is een voorbeeld van hoe je dit kunt implementeren in de ",(0,t.jsx)(n.code,{children:"actions/authActions.ts"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export const logout = async () => {\n    const cookieStore = await cookies();\n\n    cookieStore.delete("jwt");\n\n    redirect("/auth/login");\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"en een knop in het dashboard om uit te loggen:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'<form action={logout} className="w-full">\n    <button\n        type="submit"\n        className="w-full rounded-md bg-black px-4 py-2 text-sm font-medium text-white transition-colors hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2"\n    >\n        Logout\n    </button>\n</form>\n'})})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);