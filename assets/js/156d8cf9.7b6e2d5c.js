"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[2563],{28453:(e,n,o)=>{o.d(n,{R:()=>i,x:()=>s});var t=o(96540);const a={},r=t.createContext(a);function i(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(r.Provider,{value:n},e.children)}},95484:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"wf-course/nextjs/forms","title":"Form Handling","description":"Server Actions","source":"@site/docs/wf-course/nextjs/forms.md","sourceDirName":"wf-course/nextjs","slug":"/wf-course/nextjs/forms","permalink":"/webframeworks-cursus/wf-course/nextjs/forms","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"wfCourse","previous":{"title":"Fonts en Image Optimization","permalink":"/webframeworks-cursus/wf-course/nextjs/font-image-optimization"},"next":{"title":"Proxy","permalink":"/webframeworks-cursus/wf-course/nextjs/proxy"}}');var a=o(74848),r=o(28453);const i={},s="Form Handling",d={},l=[{value:"Server Actions",id:"server-actions",level:2},{value:"Formulier (Server Component)",id:"formulier-server-component",level:2},{value:"Formulier (Client Component)",id:"formulier-client-component",level:3},{value:"revalidatePath",id:"revalidatepath",level:3},{value:"Use case: Todo List",id:"use-case-todo-list",level:2},{value:"Database setup",id:"database-setup",level:3},{value:"Todo model",id:"todo-model",level:3},{value:"Actions",id:"actions",level:3},{value:"Add Todo Form component",id:"add-todo-form-component",level:3},{value:"Todo List component",id:"todo-list-component",level:3},{value:"Todo Item component",id:"todo-item-component",level:3},{value:"Page component",id:"page-component",level:3},{value:"Pending state voor checkbox",id:"pending-state-voor-checkbox",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"form-handling",children:"Form Handling"})}),"\n",(0,a.jsx)(n.h2,{id:"server-actions",children:"Server Actions"}),"\n",(0,a.jsx)(n.p,{children:"React Server Actions maken het mogelijk om asynchrone code rechtstreeks op de server uit te voeren. Dat betekent dat je geen aparte API-endpoints meer hoeft te schrijven om data te wijzigen. In plaats daarvan schrijf je asynchrone functies die op de server draaien, maar die je kunt aanroepen vanuit zowel Client Components als Server Components. Zo kan je bijvoorbeeld een formulier rechtstreeks koppelen aan een serverfunctie: wanneer de gebruiker het formulier indient, wordt die functie op de server uitgevoerd met directe toegang tot de database en andere back-endlogica. Er is geen extra fetch-request nodig, geen CORS-configuratie en ook geen aparte router of JSON-parsing \u2014 alles zit in \xe9\xe9n plek."}),"\n",(0,a.jsx)(n.p,{children:"Vroeger moest dit heel anders. Je had een aparte backend nodig, bijvoorbeeld een Express-server of een .NET Core API. Daarin moest je routes defini\xebren zoals een POST-endpoint voor het verwerken van formulieren en een GET-endpoint voor het ophalen van data. Op de clientkant moest je in React met fetch of axios een request sturen naar dat endpoint, wachten op een JSON-response en daarna zelf de UI bijwerken. Je moest zorgen voor correcte headers, validatie, beveiliging tegen CSRF en CORS-problemen, en vaak ook dubbele type-definities maken voor zowel frontend als backend. Dat werkte prima, maar voor een eenvoudige use-case zoals het versturen van een contactformulier was er behoorlijk wat boilerplate nodig."}),"\n",(0,a.jsx)(n.p,{children:'Met Server Actions valt al die extra code weg: je definieert \xe9\xe9n enkele functie in je Next.js-project, markeert die met "use server" en koppelt ze direct aan je formulier. De data gaat automatisch naar de server, de actie wordt uitgevoerd en je kunt na afloop meteen de UI opnieuw valideren of een redirect doen. Dit maakt de code veel overzichtelijker, veiliger en makkelijker te onderhouden. Een aparte API is alleen nog nodig als je data wil delen met externe clients, zoals mobiele apps of andere systemen.'}),"\n",(0,a.jsx)(n.h2,{id:"formulier-server-component",children:"Formulier (Server Component)"}),"\n",(0,a.jsxs)(n.p,{children:["We gaan een eenvoudig formulier maken dat een bericht opslaagt in een mongodb database. Hiervoor hebben we al een voor gedefinieerde ",(0,a.jsx)(n.code,{children:"database.ts"})," file die de connectie met de database maakt en een ",(0,a.jsx)(n.code,{children:"Message"})," model die we kunnen gebruiken om berichten op te slaan in de database."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { Collection, MongoClient } from "mongodb";\nimport { Message } from "@/types";\n\nconsole.log(process.env.MONGODB_URI);\n\nconst client = new MongoClient(process.env.MONGODB_URI!);\n\nexport const messageCollection: Collection<Message> = client.db("messages").collection<Message>("message");\n\nexport const saveMessage = async (message: Message) => {  \n    const result = await messageCollection.insertOne(message);\n    return result;\n}\n\nexport const getMessages = async() => {\n    const messages = await messageCollection.find().toArray();\n    return messages;\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"en"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface Message {\n    _id?: string;\n    firstName: string;\n    lastName: string;\n    email: string;\n    message: string;\n    createdAt?: Date;\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"We gaan nu een formulier maken in een server component. Dit formulier zal de data doorsturen naar een server action die we later gaan maken."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import React from "react";\nimport "./page.css";\n\nexport default function ContactPage() {\n    return (\n        <div className="form-container">\n            <div className="form-card">\n                <div className="form-header">\n                    <h1>Send a Message</h1>\n                    <p>Fill in the form below. Fields marked with * are required.</p>\n                </div>\n                <form className="form-body">\n                    <div className="form-grid">\n                        <div className="form-group">\n                            <label htmlFor="firstName">First name *</label>\n                            <input\n                                id="firstName"\n                                name="firstName"\n                                type="text"\n                                required\n                                placeholder="Ada"\n                            />\n                        </div>\n\n                        <div className="form-group">\n                            <label htmlFor="lastName">Last name *</label>\n                            <input\n                                id="lastName"\n                                name="lastName"\n                                type="text"\n                                required\n                                placeholder="Lovelace"\n                            />\n                        </div>\n\n                        <div className="form-group form-full">\n                            <label htmlFor="email">Email *</label>\n                            <input\n                                id="email"\n                                name="email"\n                                type="email"\n                                required\n                                placeholder="ada@example.com"\n                            />\n                        </div>\n\n                        <div className="form-group form-full">\n                            <label htmlFor="message">Message *</label>\n                            <textarea\n                                id="message"\n                                name="message"\n                                rows={6}\n                                required\n                                placeholder="Write your message here..."\n                            />\n                            <p className="form-hint">Keep it clear and concise.</p>\n                        </div>\n                    </div>\n\n                    <div className="form-actions">\n                        <button type="reset" className="btn-secondary">\n                            Reset\n                        </button>\n                        <button type="submit" className="btn-primary">\n                            Send\n                        </button>\n                    </div>\n                </form>\n            </div>\n        </div>\n    );\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:['Nu hebben we een formulier, maar het doet nog niets als we op de knop "Send" klikken. We gaan nu een server action maken die de data van het formulier zal verwerken. Meestal maken we een aparte file aan voor server actions, bijvoorbeeld ',(0,a.jsx)(n.code,{children:"actions.ts"}),". Op dit moment willen we gewoon een ",(0,a.jsx)(n.code,{children:"console.log"})," doen met de data die we ontvangen van het formulier."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'"use server";\n\nconst createMessage = async (formData: FormData) => {\n    const firstName = formData.get("firstName")?.toString();\n    const lastName = formData.get("lastName")?.toString();\n    const email = formData.get("email")?.toString();\n    const message = formData.get("message")?.toString();\n\n    console.log({ firstName, lastName, email, message });\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["FormData bevat de data van het formulier. We kunnen deze data ophalen met de ",(0,a.jsx)(n.code,{children:"get"})," methode. De naam die we meegeven aan de ",(0,a.jsx)(n.code,{children:"get"})," methode moet overeenkomen met de naam die we hebben meegegeven aan het ",(0,a.jsx)(n.code,{children:"name"})," attribuut van het input veld in het formulier. Nu moeten we deze server action koppelen aan het formulier. Dit doen we door de ",(0,a.jsx)(n.code,{children:"action"})," attribute van het ",(0,a.jsx)(n.code,{children:"form"})," element te gebruiken."]}),"\n",(0,a.jsxs)(n.p,{children:["Vergeet hier niet om bovenaan de file ",(0,a.jsx)(n.code,{children:"use server"})," toe te voegen anders gaan de server actions niet werken."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'<form className="form-body" action={createMessage}>\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Let op dat we hier geen methode zoals ",(0,a.jsx)(n.code,{children:"POST"})," of ",(0,a.jsx)(n.code,{children:"GET"}),' moeten meegeven. Als je nu op de knop "Send" klikt, dan zal de server action worden aangeroepen en zal de data van het formulier worden gelogd in de console van de server. Vervolgens kunnen we de data opslaan in de database. Hiervoor moeten we de ',(0,a.jsx)(n.code,{children:"saveMessage"})," functie importeren uit de ",(0,a.jsx)(n.code,{children:"database.ts"})," file die we eerder hebben gemaakt."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'"use server"\n\nimport { redirect } from "next/navigation";\nimport { saveMessage } from "./database";\n\nexport const createMessage = async (formData: FormData) => {\n    const firstName = formData.get("firstName")?.toString();\n    const lastName = formData.get("lastName")?.toString();\n    const email = formData.get("email")?.toString();\n    const message = formData.get("message")?.toString();\n\n    if (!firstName || !lastName || !email || !message) {\n        throw new Error("All fields are required");\n    }\n\n    await saveMessage({\n        firstName,\n        lastName,\n        email,\n        message,\n        createdAt: new Date()\n    });\n    \n    redirect("/contact/thank-you");\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"Hier doen we een aantal dingen:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"We controleren of alle velden zijn ingevuld. Als dit niet het geval is, dan gooien we een error. In een echte applicatie zou je hier een betere foutafhandeling moeten implementeren. Hoe we deze fout kunnen afhandelen komt later aan bod."}),"\n",(0,a.jsxs)(n.li,{children:["We slaan het bericht op in de database met de ",(0,a.jsx)(n.code,{children:"saveMessage"})," functie. Deze functie is asynchroon, dus we moeten hier ",(0,a.jsx)(n.code,{children:"await"})," voor gebruiken."]}),"\n",(0,a.jsx)(n.li,{children:'We redirecten de gebruiker naar een "Thank you" pagina nadat het bericht is opgeslagen.'}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:['Je moet uiteraard nog wel een nieuwe pagina aanmaken voor de "Thank you" pagina, bijvoorbeeld ',(0,a.jsx)(n.code,{children:"app/contact/thank-you/page.tsx"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import React from "react";\nimport "../page.css";\n\nconst MessageForm = () => {\n  return (\n    <div className="form-container">\n      <div className="form-card">\n        <div className="form-header">\n          <h1>Thank you</h1>\n          <p>Your message has been sent successfully. We will get back to you shortly.</p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default MessageForm;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Als we de error message nu willen afhandelen op een heel eenvoudige manier kunnen we gebruik maken van een ",(0,a.jsx)(n.code,{children:"error.tsx"})," file. Deze file wordt automatisch gebruikt door Next.js als er een error wordt gegooid in een server component. We kunnen deze file aanmaken in de ",(0,a.jsx)(n.code,{children:"app/contact"})," folder."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'"use client";\n\nconst ErrorPage = ({ error, reset }: { error: Error; reset: () => void }) => {\n    return (\n        <div className="form-container">\n            <div className="form-card">\n                <div className="form-header">\n                    <h1>Something went wrong</h1>\n                    <p>{error.message}</p>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default ErrorPage;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Wil je er voor zorgen dat de button even gedisabled wordt nadat je de knop hebt ingedrukt, dan kan je gebruik maken van een kleine Client Component die we kunnen inladen in het formulier. Deze component zorgt er voor dat de button even disabled wordt nadat je op de knop hebt geklikt. We maken hiervoor een nieuwe component aan ",(0,a.jsx)(n.code,{children:"SubmitButton.tsx"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'"use client"\n\nimport { useFormStatus } from "react-dom";\n\nconst SubmitButton = () => {\n    const status = useFormStatus();\n\n    return (\n        <button type="submit" className={`btn-primary`} disabled={status.pending}>\n            Send\n        </button>\n    )\n}\n\nexport default SubmitButton;\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Hier gebruiken we dus de ",(0,a.jsx)(n.code,{children:"useFormStatus"})," hook die ons vertelt of het formulier aan het verzenden is. We gebruiken deze status om de button te disablen als het formulier aan het verzenden is. We kunnen deze component nu gebruiken in het formulier."]}),"\n",(0,a.jsx)(n.h3,{id:"formulier-client-component",children:"Formulier (Client Component)"}),"\n",(0,a.jsxs)(n.p,{children:["Soms is het nodig om meer controle te hebben over het formulier, bijvoorbeeld om validatie te doen of om de UI bij te werken zonder de pagina te herladen. In dat geval kunnen we een Client Component maken die het formulier bevat. Hiervoor hebben we de ",(0,a.jsx)(n.code,{children:"useActionState"})," hook nodig die we kunnen importeren uit ",(0,a.jsx)(n.code,{children:"react-dom"}),". Deze hook geeft ons de status van de server action en maakt het mogelijk om de UI bij te werken op basis van deze status."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const [state, createMessageAction, pending] = useActionState(createMessage, {success: false, error: null});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Deze hook geeft ons drie dingen:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"state"}),": de huidige status van de actie. Dit is een object dat we kunnen gebruiken om de status bij te houden. In dit geval houden we bij of de actie succesvol is geweest of dat er een error is opgetreden."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"createMessageAction"}),": een functie die we kunnen aanroepen om de server action uit te voeren."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"pending"}),": een boolean die aangeeft of de actie aan het uitvoeren is (een soort van loading state)."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["We hoeven hier dus zelf geen verschillende states bij te houden zoals loading, success of error. Dit wordt allemaal voor ons gedaan door de ",(0,a.jsx)(n.code,{children:"useActionState"})," hook."]}),"\n",(0,a.jsxs)(n.p,{children:["We moeten hier ook onze ",(0,a.jsx)(n.code,{children:"createMessage"})," server action een klein beetje aanpassen zodat hij als parameter de vorige state meekrijgt en deze kan updaten. We moeten hier ook de return value aanpassen zodat we de nieuwe state teruggeven."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'export interface CreateMessageState {\n    error: string | null;\n    success: boolean;\n}\n\nexport const createMessage = async (state: CreateMessageState, formData: FormData) => {\n    const firstName = formData.get("firstName")?.toString();\n    const lastName = formData.get("lastName")?.toString();\n    const email = formData.get("email")?.toString();\n    const message = formData.get("message")?.toString();\n\n    let error : string | null = null;\n\n    if (!firstName || !lastName || !email || !message) {\n        error = "All fields are required";\n    } else {\n        await saveMessage({\n            firstName,\n            lastName,\n            email,\n            message,\n            createdAt: new Date()\n        });\n    }   \n\n    return {\n        success: true,\n        error: error\n    }\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Vervolgens kunnen we nu de ",(0,a.jsx)(n.code,{children:"createMessageAction"})," meegeven aan het formulier."]}),"\n",(0,a.jsx)(n.h3,{id:"revalidatepath",children:"revalidatePath"}),"\n",(0,a.jsxs)(n.p,{children:["Soms wil je na het indienen van een formulier de pagina of een deel van de pagina opnieuw valideren om de nieuwste data weer te geven. In Next.js kun je hiervoor de ",(0,a.jsx)(n.code,{children:"revalidatePath"})," functie gebruiken, die je kunt importeren uit ",(0,a.jsx)(n.code,{children:"next/cache"}),". Met deze functie kun je een specifiek pad opgeven dat opnieuw gevalideerd moet worden. Dit veroorzaakt dat Next.js de data voor dat pad opnieuw ophaalt en de bijbehorende componenten opnieuw rendert."]}),"\n",(0,a.jsxs)(n.p,{children:["Stel dat je een formulier hebt waarmee gebruikers reacties kunnen plaatsen op een blogpost. Nadat een gebruiker een reactie heeft ingediend, wil je dat de lijst met reacties automatisch wordt bijgewerkt om de nieuwe reactie weer te geven. Je kunt dit doen door ",(0,a.jsx)(n.code,{children:"revalidatePath"})," aan te roepen met het pad van de blogpost nadat de reactie is opgeslagen."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { revalidatePath } from "next/cache";\n\nexport const submitComment = async (formData: FormData) => {\n    // Code om de reactie op te slaan in de database\n\n    // Na het opslaan van de reactie, hervalideer het pad van de blogpost\n    revalidatePath("/blog/my-post");\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"use-case-todo-list",children:"Use case: Todo List"}),"\n",(0,a.jsx)(n.p,{children:"We gaan een eenvoudige Todo List maken waarbij we een formulier hebben om nieuwe todo's toe te voegen en een lijst om de bestaande todo's weer te geven. We zullen gebruik maken van Server Actions om de todo's op te slaan in een MongoDB database en de lijst opnieuw te valideren nadat een nieuwe todo is toegevoegd."}),"\n",(0,a.jsx)(n.h3,{id:"database-setup",children:"Database setup"}),"\n",(0,a.jsxs)(n.p,{children:["We hebben een ",(0,a.jsx)(n.code,{children:"database.ts"})," file nodig om de connectie met de database te maken en een ",(0,a.jsx)(n.code,{children:"Todo"})," model om de todo's op te slaan."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { Collection, MongoClient } from "mongodb";\nimport { Todo } from "@/types";\n\nconst client = new MongoClient(process.env.MONGODB_URI!);\n\nexport const todosCollection: Collection<Todo> = client.db("todos").collection<Todo>("todos");\n\nexport const getTodos = async (): Promise<Todo[]> => {\n    let todos = await todosCollection.find().toArray();\n    return todos.map(todo => ({\n        id: todo.id,\n        title: todo.title,\n        completed: todo.completed,\n    }));\n}\n\nexport const addTodo = async (title: string): Promise<void> => {\n    let max = await todosCollection.find().sort({ id: -1 }).limit(1).toArray();\n    let id = max[0]?.id + 1 || 1;\n    await todosCollection.insertOne({\n        id: id,\n        title,\n        completed: false,\n    });\n}\n\nexport const getTodoById = async (id: number): Promise<Todo | null> => {\n    return await todosCollection.findOne({ id });\n}\n\nexport const updateTodo = async (id: number, completed: boolean): Promise<void> => {\n    await todosCollection.updateOne({ id }, { $set: { completed } });\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"todo-model",children:"Todo model"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface Todo {\n    id: number;\n    title: string;\n    completed: boolean;\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"actions",children:"Actions"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'"use server";\n\nimport { addTodo, getTodoById, updateTodo } from "@/database";\nimport { revalidatePath } from "next/cache";\n\nexport const addTodoAction = async (formData: FormData): Promise<void> => {\n    const title = formData.get("title") as string;\n    if (!title) {\n        return;\n    }\n    await addTodo(title);\n    revalidatePath("/");\n}\n\nexport const toggleTodoCompletion = async (formdata: FormData): Promise<void> => {\n    const id = Number(formdata.get("id"));\n    let todo = await getTodoById(id);\n    if (!todo) return;\n\n    await updateTodo(id, !todo.completed);\n\n    revalidatePath("/");\n\n    return ;\n\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"add-todo-form-component",children:"Add Todo Form component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { addTodoAction } from "@/actions";\nimport SubmitButton from "./SubmitButton";\n\nconst AddTodoForm = () => {\n    return (\n        <form className="mb-4" action={addTodoAction}>\n            <input\n                type="text"\n                name="title"\n                placeholder="New todo"\n                className="border border-gray-300 rounded px-3 py-2 mr-2 w-64"\n            />\n            <SubmitButton/>\n        </form>\n    )\n}\n\nexport default AddTodoForm;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"todo-list-component",children:"Todo List component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import { getTodos } from "@/database";\nimport TodoItem from "./TodoItem";\n\nconst TodoList = async () => {\n\n    const todos = await getTodos();\n\n    return (\n        <div className="max-w-md mx-auto mt-10">\n            <ul>\n                {todos.map(todo => (\n                    <TodoItem key={todo.id} todo={todo} />\n                ))}\n            </ul>\n        </div>\n    );\n};\n\nexport default TodoList;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"todo-item-component",children:"Todo Item component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'"use client";\n\nimport { toggleTodoCompletion } from "@/actions";\nimport { Todo } from "@/types"\n\nexport interface TodoItemProps {\n    todo: Todo\n}\n\nconst TodoItem = ({ todo }: TodoItemProps) => {\n    return (\n        <li className="mb-2 w-lg p-4 bg-white rounded shadow flex items-center justify-between">\n            <span className={todo.completed ? "line-through text-gray-500" : ""}>\n                {todo.title}\n            </span>\n            <form action={toggleTodoCompletion}>\n                <input type="hidden" name="id" value={todo.id} />\n                <input type="checkbox" defaultChecked={todo.completed} onChange={(e) => {\n                    e.currentTarget.form?.requestSubmit();\n                }}/>\n            </form>\n        </li>\n    );\n}\n\nexport default TodoItem;\n'})}),"\n",(0,a.jsx)(n.h3,{id:"page-component",children:"Page component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import AddTodoForm from "@/components/AddTodoForm";\nimport TodoList from "@/components/TodoList";\nimport { Suspense } from "react";\n\nexport default function Home() {\n  return (\n    <div className="flex flex-1 flex-col items-center justify-center min-h-screen py-2">\n        <h1 className="text-2xl font-bold mb-4">Todo List</h1>\n\n        <AddTodoForm/>\n        <Suspense fallback={<div>Loading...</div>}>\n            <TodoList/>\n        </Suspense>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"pending-state-voor-checkbox",children:"Pending state voor checkbox"}),"\n",(0,a.jsxs)(n.p,{children:["In de ",(0,a.jsx)(n.code,{children:"TodoItem"})," component kunnen we de ",(0,a.jsx)(n.code,{children:"useActionState"})," hook gebruiken om een pending state te krijgen voor de checkbox. Op die manier kunnen we de checkbox disablen terwijl de actie aan het uitvoeren is."]}),"\n",(0,a.jsxs)(n.p,{children:["We moeten dan wel de ",(0,a.jsx)(n.code,{children:"toggleTodoCompletion"})," actie een klein beetje aanpassen zodat hij de vorige state meekrijgt en deze kan updaten."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'interface ToggleTodoCompletionState {\n    error: string | null;\n}\n\nexport const toggleTodoCompletion = async (previousState: ToggleTodoCompletionState, formdata: FormData): Promise<ToggleTodoCompletionState> => {\n    const id = Number(formdata.get("id"));\n    let todo = await getTodoById(id);\n    if (!todo) {\n        return { error: "Todo not found" };\n    }\n\n    await updateTodo(id, !todo.completed);\n\n    revalidatePath("/");\n\n    return {\n        error: null\n    }\n\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Vervolgens kunnen we nu de ",(0,a.jsx)(n.code,{children:"useActionState"})," hook gebruiken in de ",(0,a.jsx)(n.code,{children:"TodoItem"})," component."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"    const [state, toggleTodoCompletionAction, pending] = useActionState(toggleTodoCompletion, { error: null})\n"})}),"\n",(0,a.jsxs)(n.p,{children:["We kunnen nu de ",(0,a.jsx)(n.code,{children:"toggleTodoCompletionAction"})," meegeven aan het formulier en de checkbox disablen als de actie aan het uitvoeren is."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'    <form action={toggleTodoCompletionAction}>\n        <input type="hidden" name="id" value={todo.id} />\n        <input type="checkbox" defaultChecked={todo.completed} disabled={pending} onChange={(e) => {\n            e.currentTarget.form?.requestSubmit();\n        }}/>\n    </form>\n'})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);