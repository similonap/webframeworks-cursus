"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[527],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=r,g=c["".concat(p,".").concat(m)]||c[m]||u[m]||o;return n?a.createElement(g,i(i({ref:t},l),{},{components:n})):a.createElement(g,i({ref:t},l))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=c;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3555:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:9},i="State",s={unversionedId:"state/README",id:"state/README",title:"State",description:"State en Props zijn een van de meest essenti\xeble concepten die je moet begrijpen in React. Props dienen om informatie door een componenten structuur te geven, en state wordt gebruikt om applicaties interactief te maken. State wordt gebruikt om informatie bij te houden en deze aan te passen over de looptijd van je applicatie.",source:"@site/docs/state/README.md",sourceDirName:"state",slug:"/state/",permalink:"/webframeworks-cursus/state/",draft:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Event Handling",permalink:"/webframeworks-cursus/event-handling/"},next:{title:"Regels van useState",permalink:"/webframeworks-cursus/state/regels"}},p={},d=[{value:"useState hook",id:"usestate-hook",level:2},{value:"setState met callback",id:"setstate-met-callback",level:2}],l={toc:d};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"state"},"State"),(0,r.kt)("p",null,"State en Props zijn een van de meest essenti\xeble concepten die je moet begrijpen in React. Props dienen om informatie door een componenten structuur te geven, en state wordt gebruikt om applicaties interactief te maken. State wordt gebruikt om informatie bij te houden en deze aan te passen over de looptijd van je applicatie."),(0,r.kt)("h2",{id:"usestate-hook"},"useState hook"),(0,r.kt)("p",null,"We zullen dat laatste demonstreren aan de hand van een voorbeeld. We gaan hiervoor terug naar ons ",(0,r.kt)("inlineCode",{parentName:"p"},"InputView")," voorbeeld. Stel dat we elke keer de gebruiker iets intypt in de input box, dat we deze text willen laten tonen ergens anders in de applicatie. Dit is dus informatie die aangepast wordt over de looptijd van de applicatie. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',codesandbox:'{"template":','"react",':!0,'"filename":':!0,'"src/App.tsx"}':!0},'const InputView = () => {\n  const handleChange: React.ChangeEventHandler<HTMLInputElement> = (event) => {\n    console.log(event.target.value);\n  }\n  return (\n    <input type="text" id="name" onChange={handleChange} />\n  )\n}\n//hide-start\nconst App = () => {\n    return <InputView/>\n}\n\nexport default App;\n//hide-end\n')),(0,r.kt)("p",null,"We zouden foutief kunnen veronderstellen dat we dit probleem kunnen oplossen door een variabele te maken die de ingetypte tekst opslaat. Een verstaanbare poging is deze:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',codesandbox:'{"template":','"react",':!0,'"filename":':!0,'"src/App.tsx"}':!0},'// DEZE CODE IS FOUT\nconst InputView = () => {\n  let name = "";\n  const handleChange: React.ChangeEventHandler<HTMLInputElement> = (event) => {\n    event = event.target.value;\n  }\n  return (\n    <>\n      <input type="text" id="name" onChange={handleChange} />\n      <p>\n        The name you typed is {name}\n      </p>\n    </>\n  );\n}\n//hide-start\nconst App = () => {\n    return <InputView/>\n}\n\nexport default App;\n//hide-end\n')),(0,r.kt)("p",null,"Wijzigingen in het input veld hebben ",(0,r.kt)("strong",{parentName:"p"},"geen effect")," op de rest van de pagina. Elke render (en er vindt er niet eens een plaats wanneer de handler de waarde wijzigt) runt de code voor de component opnieuw. Er wordt dus telkens een nieuwe variabele name met beginwaarde ",(0,r.kt)("inlineCode",{parentName:"p"},'""')," aangemaakt."),(0,r.kt)("p",null,"In plaats van een gewone variabele is een state variabele nodig. ",(0,r.kt)("strong",{parentName:"p"},"Bij een wijziging hiervan wordt de component hertekend en de waarde wordt bijgehouden over uitvoeringen heen.")," Deze variabele kan aangemaakt worden door middel van de useState hook."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const [name, setName] = useState<string>('');\n")),(0,r.kt)("p",null,"De ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," functie heeft als argument een initi\xeble state. Dit is de start waarde die de state zal krijgen als de component voor de eerste keer gerenderd wordt. De functie geeft een array terug met twee elementen in: het eerste element is de huidige state en het tweede element is een functie waarmee je de state ",(0,r.kt)("strong",{parentName:"p"},"kan en moet")," aanpassen. We geven aan welk type onze state zal bevatten door ",(0,r.kt)("inlineCode",{parentName:"p"},"<string>")," mee te geven aan de ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," functie."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',codesandbox:'{"template":','"react",':!0,'"filename":':!0,'"src/App.tsx"}':!0},'import { useState } from "react";\n\nconst InputView = () => {\n  const [name, setName] = useState<string>(\'\');\n\n  const handleChange: React.ChangeEventHandler<HTMLInputElement> = (event) => {\n    setName(event.target.value);\n  }\n\n  return (\n    <>\n      <input type="text" id="name" onChange={handleChange} value={name}/>\n      <p>\n        The name you typed is {name}\n      </p>\n    </>\n  );\n}\n//hide-start\nconst App = () => {\n    return <InputView/>\n}\n\nexport default App;\n//hide-end\n')),(0,r.kt)("p",null,"Het value attribuut wordt ingesteld op de huidige waarde van de state. Zo zorgen we ervoor dat het inputveld altijd up-to-date is met de huidige waarde van de state. Dit noemen ze in react ",(0,r.kt)("strong",{parentName:"p"},"controlled components"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Je mag meerdere keren ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," gebruiken in 1 component. Bijvoorbeeld als je meerdere input velden hebt in je formulier zal je ook meerdere states hebben.")),(0,r.kt)("h2",{id:"setstate-met-callback"},"setState met callback"),(0,r.kt)("p",null,"Soms is de nieuwe waarde van een state afhankelijk van de vorige waarde van de state. In dit geval moeten we de ",(0,r.kt)("inlineCode",{parentName:"p"},"setState")," aanroepen met een callback functie als argument. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'{8,9} codesandbox={"template": "react", "filename": "src/App.tsx"}',"{8,9}":!0,codesandbox:'{"template":','"react",':!0,'"filename":':!0,'"src/App.tsx"}':!0},'//hide-start\nimport {useState} from "react";\n//hide-end\nconst App = () => {\n  const [count, setCount] = useState(0);\n  return (\n    <>\n      Count: {count}\n      <button onClick={() => setCount(0)}>Reset</button>\n      <button onClick={() => {\n        setCount(count + 1); \n        setCount(count + 1); // count is nog niet geupdated.\n       }\n      }>+</button>\n    </>\n  );\n}\n//hide-start\nexport default App;\n//hide-end\n')),(0,r.kt)("p",null,"In het bovenstaande voorbeeld zou je denken dat de count altijd met twee omhoog gaat. Maar dat is niet het geval. Als de tweede ",(0,r.kt)("inlineCode",{parentName:"p"},"setCount")," wordt aangeroepen is de ",(0,r.kt)("inlineCode",{parentName:"p"},"count")," state nog niet aangepast. "),(0,r.kt)("p",null,"Wil je dit doen dan moet je dit op de volgende manier doen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'{8,9} codesandbox={"template": "react", "filename": "src/App.tsx"}',"{8,9}":!0,codesandbox:'{"template":','"react",':!0,'"filename":':!0,'"src/App.tsx"}':!0},'//hide-start\nimport {useState} from "react";\n//hide-end\nconst App = () => {\n  const [count, setCount] = useState(0);\n  return (\n    <>\n      Count: {count}\n      <button onClick={() => setCount(0)}>Reset</button>\n      <button onClick={() => {\n        setCount(prevCount => prevCount + 1); \n        setCount(prevCount => prevCount + 1);\n       }\n      }>+</button>\n    </>\n  );\n}\n//hide-start\nexport default App;\n//hide-end\n')))}u.isMDXComponent=!0}}]);