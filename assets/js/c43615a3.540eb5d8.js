"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[1119],{11110:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"wf-course/react/child-parent/context","title":"Context","description":"Delen van data via context","source":"@site/docs/wf-course/react/child-parent/context.md","sourceDirName":"wf-course/react/child-parent","slug":"/wf-course/react/child-parent/context","permalink":"/webframeworks-cursus/wf-course/react/child-parent/context","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"wfCourse","previous":{"title":"Callbacks en properties","permalink":"/webframeworks-cursus/wf-course/react/child-parent/props"},"next":{"title":"Recepten voor React.js","permalink":"/webframeworks-cursus/wf-course/react/recepten/"}}');var a=t(74848),r=t(28453);const s={},d="Context",i={},c=[{value:"Delen van data via context",id:"delen-van-data-via-context",level:2},{value:"Functies in context",id:"functies-in-context",level:2},{value:"Data Context",id:"data-context",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"context",children:"Context"})}),"\n",(0,a.jsx)(n.h2,{id:"delen-van-data-via-context",children:"Delen van data via context"}),"\n",(0,a.jsx)(n.p,{children:"In een React applicatie wordt data van het bovenste component doorgegeven naar het onderste component aan de hand van props. Dit is mogelijk in een applicatie waar de component structuur niet heel diep is, maar naar mate de applicatie groeit, groeit meestal ook de diepte van je componenten structuur. Je zal dan vaak een prop verschillende niveau's diep moeten doorgeven. Dit concept heet property drilling, en is in grote applicaties niet wenselijk."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Alt text",src:t(57950).A+"",width:"1216",height:"870"})}),"\n",(0,a.jsx)(n.p,{children:"Stel dat we een light theme en een dark theme willen ondersteunen in onze applicatie. Elk component heeft deze prop nodig want elk component moet zijn UI aanpassen als de theme light of dark is."}),"\n",(0,a.jsx)(n.p,{children:"Hieronder kan je een voorbeeld hiervan zien:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'//hide-start\nimport { useState } from "react";\n\nconst getThemeStyle = (theme: string, color: string) => {\n    return { backgroundColor: theme === "dark" ? "black" : "white", padding: 10, border: "10px solid " + color }\n}\n//hide-end\nconst ComponentA = ({ theme }: { theme: string }) => {\n  return (\n    <div style={getThemeStyle(theme, "red")}>\n      <ComponentB theme={theme} />\n    </div>\n  );\n};\nconst ComponentB = ({ theme }: { theme: string }) => {\n  return (\n    <div style={getThemeStyle(theme, "green")}>\n      <ComponentC theme={theme} />\n    </div>\n  );\n};\nconst ComponentC = ({ theme }: { theme: string }) => {\n  return (\n    <div style={getThemeStyle(theme, "blue")}>\n      <ComponentD theme={theme} />\n    </div>\n  );\n};\nconst ComponentD = ({ theme }: { theme: string }) => {\n  return <p style={{color: theme === "dark" ? "white" : "black"}}>{theme}</p>;\n};\n\nconst App = () => {\n  const [theme, setTheme] = useState("light");\n  \n  return (\n    <>\n      <button onClick={()=>{ setTheme(theme => theme == "dark" ? "light" : "dark")}}>Toggle theme!</button>\n      <ComponentA theme={theme} />\n    </>\n  );\n};\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,a.jsx)(n.p,{children:"Je ziet dat zelfs voor een kleine applicatie, zoals die hierboven, dat we deze theme prop al moeten doorgeven doorheen 3 niveaus van componenten. Bij grotere applicaties gaat dit nog veel erger worden. Daarom heeft React voor de Context API gezorgd. Dit is een manier om data te gaan delen doorheen componenten zonder door heel de structuur te moeten doorgegeven worden. Dit is zeer handig als de tussenliggende lagen geen nood hebben aan deze data. Deze hoeven dan ook niet de context te gebruiken."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.img,{alt:"Alt text",src:t(58205).A+"",width:"1216",height:"870"})}),"\n",(0,a.jsx)(n.p,{children:"Het eerste wat we moeten doen is een Context aanmaken aan de hand van de createContext"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"interface IThemeContext {\n    theme: string\n}\n\nexport const ThemeContext = React.createContext<IThemeContext>({theme: 'light'});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Je moet altijd een default waarde meegeven aan de context. Deze default waarde wordt enkel gebruikt als er geen provider aanwezig is bovenaan in de component structuur. We geven hier een object met een mode property. Dus in ons geval zal onze layout dus standaard in light mode staan."}),"\n",(0,a.jsx)(n.p,{children:"Nu moeten we een Provider maken van onze ThemeContext zodat we de values kunnen meegeven die we in de componenten willen gebruiken. De provider moet rond de bovenste component staan die onze context willen gebruiken."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const App = () => {\n  const [theme, setTheme] = useState("light");\n\n  return (\n    <ThemeContext.Provider value={{theme: theme}}>\n       <...>\n\n       </...>\n    </ThemeContext.Provider>\n  );\n};\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Nu kan je de values van de ThemeContext provider opvragen aan de hand van de ",(0,a.jsx)(n.code,{children:"useContext"})," hook."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'//hide-start\nimport React, { useState, useContext } from "react";\n\ninterface IThemeContext {\n    theme: string\n}\nexport const ThemeContext = React.createContext<IThemeContext>({theme: \'light\'});\n\nconst getThemeStyle = (theme: string, color: string) => {\n  return { backgroundColor: theme === "dark" ? "black" : "white", padding: 10, border: "10px solid " + color }\n}\n//hide-end\nconst ComponentA = () => {\n  const {theme} = useContext(ThemeContext);\n  return (\n    <div style={getThemeStyle(theme, "red")}>\n      <ComponentB/>\n    </div>\n  );\n};\nconst ComponentB = () => {\n  const {theme} = useContext(ThemeContext);\n  return (\n    <div style={getThemeStyle(theme, "green")}>\n      <ComponentC />\n    </div>\n  );\n};\nconst ComponentC = () => {\n  const {theme} = useContext(ThemeContext);\n  return (\n    <div style={getThemeStyle(theme, "blue")}>\n      <ComponentD  />\n    </div>\n  );\n};\nconst ComponentD = () => {\n  const {theme} = useContext(ThemeContext);\n  return <p style={{color: theme === "dark" ? "white" : "black"}}>{theme}</p>;\n};\n\nconst App = () => {\n  const [theme, setTheme] = useState("light");\n\n  return (\n    <ThemeContext.Provider value={{theme: theme}}>\n        <>\n            <button onClick={()=>{ setTheme(theme => theme == "dark" ? "light" : "dark")}}>Toggle theme!</button>\n            <ComponentA />\n        </>\n    </ThemeContext.Provider>\n  );\n};\n//hide-start\nexport default App;\n//hide-end\n'})}),"\n",(0,a.jsx)(n.p,{children:"Je ziet nu dat elk component toegang heeft tot de mode variabele die we in de context hebben aangeboden zonder dat we deze moeten doorgeven doorheen de component hierarchie."}),"\n",(0,a.jsx)(n.h2,{id:"functies-in-context",children:"Functies in context"}),"\n",(0,a.jsxs)(n.p,{children:["We kunnen ook functies toevoegen in onze ",(0,a.jsx)(n.code,{children:"ThemeContext"})," zodat we bijvoorbeeld ook vanuit elk component de theme kunnen aanpassen. We voegen nu aan de createContext functie een setMode functie toe. We moeten hier een default value voor aanbieden, op dit moment hebben we nog geen handler dus we geven een lege functie mee."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'interface IThemeContext {\n    theme: string,\n    setTheme: (theme: string) => void\n}\n\nexport const ThemeContext = React.createContext<IThemeContext>({theme: "light", setTheme: (theme: string) => {}});\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We geven hier bij de createContext een interface mee tussen de ",(0,a.jsx)(n.code,{children:"<>"})," haken zodat TypeScript weet welke keys er in de context zullen voorkomen en welke types deze hebben."]}),"\n",(0,a.jsxs)(n.p,{children:["Als we nu de ",(0,a.jsx)(n.code,{children:"setTheme"})," functie (van de useState) meegeven aan de provider dan is deze functie beschikbaar in elk component."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'{2} codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'//hide-start\nimport React, { useState, useContext } from "react";\n\ninterface IThemeContext {\n    theme: string,\n    setTheme: (theme: string) => void\n}\nexport const ThemeContext = React.createContext<IThemeContext>({theme: \'light\', setTheme: (theme: string)=>{}});\n\nconst getThemeStyle = (theme: string, color: string) => {\n  return { backgroundColor: theme === "dark" ? "black" : "white", padding: 10, border: "10px solid " + color }\n}\n\nconst ComponentA = () => {\n  const {theme} = useContext(ThemeContext);\n  return (\n    <div style={getThemeStyle(theme, "red")}>\n      <ComponentB/>\n    </div>\n  );\n};\nconst ComponentB = () => {\n  const {theme} = useContext(ThemeContext);\n  return (\n    <div style={getThemeStyle(theme, "green")}>\n      <ComponentC />\n    </div>\n  );\n};\nconst ComponentC = () => {\n  const {theme} = useContext(ThemeContext);\n  return (\n    <div style={getThemeStyle(theme, "blue")}>\n      <ComponentD  />\n    </div>\n  );\n};\n//hide-end\nconst ComponentD = () => {\n  const {theme,setTheme} = useContext(ThemeContext);\n  return <button onClick={() => { setTheme(theme === "dark" ? "light" : "dark")}} style={{backgroundColor: theme === "dark" ? "black" : "white", color: theme === "dark" ? "white" : "black"}}>{theme}</button>;\n};\n//hide-start\nconst App = () => {\n  const [theme, setTheme] = useState("light");\n\n  return (\n    <ThemeContext.Provider value={{theme: theme, setTheme: setTheme}}>\n        <>\n            <button onClick={()=>{ setTheme(theme => theme == "dark" ? "light" : "dark")}}>Toggle theme!</button>\n            <ComponentA />\n        </>\n    </ThemeContext.Provider>\n  );\n};\nexport default App;\n//hide-end\n'})}),"\n",(0,a.jsx)(n.h2,{id:"data-context",children:"Data Context"}),"\n",(0,a.jsx)(n.p,{children:"Een veel voorkomend patroon is dat je data vanuit een API ophaalt en deze data dan doorgeeft aan verschillende componenten. Dit kan je doen door de data in de state van de bovenste component te plaatsen en deze dan door te geven aan de onderliggende componenten. Je zou dit kunnen doen aan de hand van props, maar dit is niet altijd even handig. Dit wordt meestal gedaan aan de hand van de Context API."}),"\n",(0,a.jsxs)(n.p,{children:["In dit voorbeeld gaan we gebruik maken van de API op ",(0,a.jsx)(n.a,{href:"https://jsonplaceholder.typicode.com/posts",children:"https://jsonplaceholder.typicode.com/posts"}),". Deze API geeft een lijst van posts terug. We maken een interface aan voor een post."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export interface Post {\n    userId: number;\n    id: number;\n    title: string;\n    body: string;\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Om onze code wat overzichtelijker te maken gaan we alle code die te maken heeft met de data van de API in een apart bestand plaatsen. We noemen dit bestand ",(0,a.jsx)(n.code,{children:"dataContext.tsx"}),"."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'import React, { useState, useContext, useEffect } from "react";\n\nexport interface DataContext {\n  posts: Post[];\n  loading: boolean;\n  loadData: () => void;\n}\n\nexport const DataContext = React.createContext<DataContext>({posts: [], loading: false, loadData: () => {}});\n\nexport const DataProvider = ({children}: {children: React.ReactNode}) => {\n  const [posts, setPosts] = useState<Post[]>([]);\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const loadData = async () => {\n      setLoading(true);\n      const response = await fetch("https://jsonplaceholder.typicode.com/posts");\n      const json = await response.json();\n      setPosts(json);\n      setLoading(false);\n  }\n\n  useEffect(() => {\n      loadData();\n  }, []);\n\n  return (\n      <DataContext.Provider value={{posts: posts, loadData: loadData, loading: loading}}>\n          {children}\n      </DataContext.Provider>\n  )\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["In de ",(0,a.jsx)(n.code,{children:"DataProvider"})," component maken we een state aan voor de posts. We maken ook een functie aan om de data op te halen van de API. Deze functie wordt aangeroepen in de ",(0,a.jsx)(n.code,{children:"useEffect"})," hook zodat de data wordt opgehaald als de component gemount wordt. We geven de posts en de loadData functie mee aan de provider zodat deze beschikbaar zijn in de onderliggende componenten. We voorzien ook een loading property zodat we kunnen zien of de data aan het laden is of niet."]}),"\n",(0,a.jsxs)(n.p,{children:["Nu kunnen we de ",(0,a.jsx)(n.code,{children:"DataProvider"})," component gebruiken in onze ",(0,a.jsx)(n.code,{children:"App"})," component. Je kan zien dat het nu zeer eenvoudig is de data te gebruiken in de onderliggende componenten. We moeten enkel de ",(0,a.jsx)(n.code,{children:"useContext"})," hook gebruiken om de data op te halen."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:"//hide-start\nimport React, { useEffect, useState } from 'react';\nimport { useContext } from 'react';\n\nexport interface Post {\n  userId: number;\n  id: number;\n  title: string;\n  body: string;\n}\n\nexport interface DataContext {\n  posts: Post[];\n  loading: boolean;\n  loadData: () => void;\n}\n\nexport const DataContext = React.createContext<DataContext>({posts: [], loading: false, loadData: () => {}});\n\nexport const DataProvider = ({children}: {children: React.ReactNode}) => {\n  const [posts, setPosts] = useState<Post[]>([]);\n  const [loading, setLoading] = useState<boolean>(false);\n\n  const loadData = async () => {\n      setLoading(true);\n      setPosts([]);\n      const response = await fetch(\"https://jsonplaceholder.typicode.com/posts\");\n      const json = await response.json();\n      setPosts(json);\n      setLoading(false);\n  }\n\n  useEffect(() => {\n      loadData();\n  }, []);\n\n  return (\n      <DataContext.Provider value={{posts: posts, loadData: loadData, loading: loading}}>\n          {children}\n      </DataContext.Provider>\n  )\n}\n//hide-end\nconst ReloadButton = () => {\n  const { loadData, loading } = useContext(DataContext);\n  return (\n    <button disabled={loading} onClick={() => loadData()}>reload</button>\n  )\n}\n\nconst PostList = () => {\n  const { posts } = useContext(DataContext);\n  return (\n    <div>\n      <h1>Posts</h1>\n      <ul>\n        {posts.map((post, index) => (\n          <li key={index}>{post.title}</li>\n        ))}\n      </ul>\n    </div>\n  )\n}\n\nconst App = () => {\n  return (\n    <DataProvider>\n      <ReloadButton/>\n      <PostList/>\n    </DataProvider>\n  )\n}\n\n//hide-start\nexport default App\n//hide-end\n"})}),"\n",(0,a.jsx)(n.p,{children:"Het is ook mogelijk om functies toe te voegen om de data te gaan aanpassen. Zo kan je functies voorzien om posts toe te voegen, te verwijderen of te updaten. Deze functies worden dan ook meegegeven aan de provider zodat deze beschikbaar zijn in de onderliggende componenten. Je kan dit in de array zelf doen of een POST request maken naar een backend."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const createPost = async (post: Post) => {\n  setPosts([...posts, post]);\n  await fetch("https://jsonplaceholder.typicode.com/posts", {\n    method: "POST",\n    body: JSON.stringify(post),\n    headers: {\n      "Content-type": "application/json; charset=UTF-8"\n    }\n  });\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Vergeet niet om de ",(0,a.jsx)(n.code,{children:"createPost"})," functie mee te geven aan de provider."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"<DataContext.Provider value={{posts: posts, loadData: loadData, loading: loading, createPost: createPost}}>\n"})}),"\n",(0,a.jsx)(n.p,{children:"Het volledige voorbeeld kan je hier vinden:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react-context", "filename": "src/App.tsx"}',children:"import { DataProvider } from './dataContext';\nimport ReloadButton from './components/ReloadButton';\nimport PostForm from './components/PostForm';\nimport PostList from './components/PostList';\n\nconst App = () => {\n  return (\n    <DataProvider>\n      <PostForm/>\n      <ReloadButton/>\n      <PostList/>\n    </DataProvider>\n  )\n}\n\nexport default App\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var o=t(96540);const a={},r=o.createContext(a);function s(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(r.Provider,{value:n},e.children)}},57950:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/propdrill-b51bd5f943b919d0d9f14256fcf5c744.png"},58205:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/context-3e52eed91b829f8f28bc0b83285e1f43.png"}}]);