"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[3814],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(96540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}},38223:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"wf-course/typescript-revisited/optional-chaining","title":"Omgaan met null/undefined","description":"Optional","source":"@site/docs/wf-course/typescript-revisited/optional-chaining.md","sourceDirName":"wf-course/typescript-revisited","slug":"/wf-course/typescript-revisited/optional-chaining","permalink":"/webframeworks-cursus/wf-course/typescript-revisited/optional-chaining","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"wfCourse","previous":{"title":"Arrays/Objecten kopieren","permalink":"/webframeworks-cursus/wf-course/typescript-revisited/arrays-objecten-kopieren"},"next":{"title":"Array/Object Destructuring","permalink":"/webframeworks-cursus/wf-course/typescript-revisited/array-object-destructuring"}}');var r=i(74848),s=i(28453);const o={sidebar_position:2},a="Omgaan met null/undefined",l={},d=[{value:"Optional",id:"optional",level:3},{value:"Optional chaining",id:"optional-chaining",level:3},{value:"?? Operator (Nullish Coalescing)",id:"-operator-nullish-coalescing",level:3},{value:"&amp;&amp; operator",id:"-operator",level:3},{value:".! operator (Non-null assertion)",id:"-operator-non-null-assertion",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"omgaan-met-nullundefined",children:"Omgaan met null/undefined"})}),"\n",(0,r.jsx)(n.h3,{id:"optional",children:"Optional"}),"\n",(0,r.jsxs)(n.p,{children:["Soms heb je objecten waarbij niet alle properties een waarde hebben. In TypeScript moet je dit aangeven in de interface van dat object. Stel dat we een ",(0,r.jsx)(n.code,{children:"Options"})," interface hebben die gebruikt wordt om een scherm in te stellen."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Options {\n  title: string;\n  width: number;\n  height: number;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Als je nu"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"let options : Options = {\n    title: 'Hello World'\n};\n// Type '{ title: string; }' is missing the following properties from type 'Options': width, height(2739)\n"})}),"\n",(0,r.jsx)(n.p,{children:"doet dan krijg je een error in typescript want width en height zijn hier niet opgegeven."}),"\n",(0,r.jsx)(n.p,{children:"Wil je dit toch toelaten dan moet je dit aangeven in de interface van Options aan de hand van de ? operator. Dit geeft aan dat een property optional is."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"interface Options {\n  title: string;\n  width?: number;\n  height?: number;\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"optional-chaining",children:"Optional chaining"}),"\n",(0,r.jsxs)(n.p,{children:["Stel dat we de interface iets aanpassen en de ",(0,r.jsx)(n.code,{children:"width"})," en de ",(0,r.jsx)(n.code,{children:"height"})," in een apart object plaatsen. Dan krijgen we de volgende situatie"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:"interface Size {\n  width: number;\n  height: number;\n}\ninterface Options {\n  title: string;\n  size: Size\n}\n\nlet options: Options = {\n  title: 'Hello World',\n  size: {\n    width: 100,\n    height: 100\n  }\n};\n\nconsole.log(options.size.width); // 100\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Als we nu ",(0,r.jsx)(n.code,{children:"size"})," optioneel maken zoals hiervoor geraken we in de problemen. Onze compiler zal ons dan de volgende foutmelding geven:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:"interface Size {\n  width: number;\n  height: number;\n}\ninterface Options {\n  title: string;\n  size?: Size\n}\n\nlet options: Options = {\n  title: 'Hello World',\n  size: {\n    width: 100,\n    height: 100\n  }\n};\n\nconsole.log(options.size.width); // Object is possibly 'undefined'\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Omdat we ",(0,r.jsx)(n.code,{children:"size"})," optioneel hebben gemaakt bestaat er een kans dat size undefined zou zijn. Dus de typescript compiler waarschuwt ons hiervoor. Hier kunnen we een aantal dingen aan doen. Je zou expliciet kunnen kijken of options.size gelijk is aan undefined aan de hand van een if statement:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:"//hide-start\ninterface Size {\n  width: number;\n  height: number;\n}\ninterface Options {\n  title: string;\n  size?: Size\n}\n//hide-end\nlet options: Options = {\n  title: 'Hello World'\n};\n\nif (options.size != undefined) {\n    console.log(options.size.height);\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["of je kan hier optional chaining gebruiken. Je gebruikt hier ",(0,r.jsx)(n.code,{children:".?"})," in plaats van de ",(0,r.jsx)(n.code,{children:"."})," operator:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:"//hide-start\ninterface Size {\n  width: number;\n  height: number;\n}\ninterface Options {\n  title: string;\n  size?: Size\n}\nlet options: Options = {\n  title: 'Hello World'\n};\n//hide-end\nconsole.log(options.size?.height); // undefined\n"})}),"\n",(0,r.jsxs)(n.p,{children:["en dan krijg je ook geen errors meer te zien.  Als je optional chaining gebruikt dan zal de hele expressie als undefined gezien worden als een van de elementen undefined is. In dit geval is ",(0,r.jsx)(n.code,{children:"size"})," undefined, dus dan zal de height hiervan ook undefined zijn."]}),"\n",(0,r.jsx)(n.h3,{id:"-operator-nullish-coalescing",children:"?? Operator (Nullish Coalescing)"}),"\n",(0,r.jsxs)(n.p,{children:["Soms wil je een default waarde gebruiken als een property undefined is. Je kan dit doen met de ",(0,r.jsx)(n.code,{children:"??"})," operator:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:"//hide-start\ninterface Size {\n  width: number;\n  height: number;\n}\ninterface Options {\n  title: string;\n  size?: Size\n}\nlet options: Options = {\n  title: 'Hello World'\n};\n//hide-end\nconsole.log(options.size?.height ?? 180); // 180\n"})}),"\n",(0,r.jsx)(n.p,{children:"In dit geval wordt de height 180 als de height undefined is."}),"\n",(0,r.jsx)(n.h3,{id:"-operator",children:"&& operator"}),"\n",(0,r.jsxs)(n.p,{children:["De ",(0,r.jsx)(n.code,{children:"&&"})," operator wordt gebruikt om een expressie te evalueren als de linkerkant ",(0,r.jsx)(n.code,{children:"true"})," is. Als de linkerkant niet waar is dan zal de rechterkant niet ge\xebvalueerd worden."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:"const hasLight = false;\n\nconst turnOffLight = () => {\n  console.log('Light is turned off');\n};\n\nhasLight && turnOffLight();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["In dit geval zal de ",(0,r.jsx)(n.code,{children:"turnOffLight"})," functie niet aangeroepen worden omdat de ",(0,r.jsx)(n.code,{children:"hasLight"})," false is."]}),"\n",(0,r.jsx)(n.p,{children:"Dit werkt ook met null en undefined:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:"const light = undefined;\n\nconst turnOffLight = () => {\n  console.log('Light is turned off');\n};\n\nlight && turnOffLight();\n"})}),"\n",(0,r.jsx)(n.p,{children:"Er zijn veel waarden in JavaScript die als false/true gezien worden. Deze noemen we gewoonlijke truethy en falsy."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Falsy",children:"https://developer.mozilla.org/en-US/docs/Glossary/Falsy"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Glossary/Truthy",children:"https://developer.mozilla.org/en-US/docs/Glossary/Truthy"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"-operator-non-null-assertion",children:".! operator (Non-null assertion)"}),"\n",(0,r.jsxs)(n.p,{children:["Heel zelden kom je in situaties terecht dat TypeScript denkt dat een bepaald veld ",(0,r.jsx)(n.strong,{children:"undefined"})," of ",(0,r.jsx)(n.strong,{children:"null"})," kan zijn. Als je zeker bent dat een bepaald veld nooit undefined kan zijn dan kan je ook de ",(0,r.jsx)(n.code,{children:"!"}),' operator gebruiken om een "Object is possibly undefined" error te vermijden.']}),"\n",(0,r.jsx)(n.p,{children:"Bij de onderstaande code is de TypeScript compilator niet in staat zelf te bepalen of text undefined is of niet. Daarom moet je achter text een uitroepteken zetten om deze error te vermijden."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "typescript", "filename": "index.ts" }',children:'const duplicate = (text?: string) => {\n  let fixString = () => {\n    if (text === null || text === undefined) {\n      text = "";\n    }\n  };\n  fixString();\n\n  return text!.concat(text!);\n}\n\nconsole.log(duplicate("hello"));\n'})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["Gebruik dit alleen als je zeker bent dat het veld nooit undefined kan zijn. Anders kan je beter de ",(0,r.jsx)(n.code,{children:".?"})," operator gebruiken. Of zet je een default waarde aan de hand van de ",(0,r.jsx)(n.code,{children:"??"})," operator."]})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}}}]);