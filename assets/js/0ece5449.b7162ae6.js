"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[6193],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>u});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),d=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=d(t),u=r,k=m["".concat(l,".").concat(u)]||m[u]||c[u]||o;return t?a.createElement(k,i(i({ref:n},p),{},{components:t})):a.createElement(k,i({ref:n},p))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1474:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(7462),r=(t(7294),t(3905));const o={},i="Server Components",s={unversionedId:"wf-course/nextjs/csr-ssr",id:"wf-course/nextjs/csr-ssr",title:"Server Components",description:"Tot nu toe hebben we gebruik gemaakt van client side rendering (CSR) om onze React applicaties te maken. Dit betekend dat de volledige applicatie in de browser wordt geladen en daar gerenderd wordt. Dit is een goede manier om applicaties te maken, maar het heeft ook enkele nadelen. Een van de nadelen is dat de eerste keer dat de applicatie geladen wordt, er een lege pagina getoond wordt terwijl de JavaScript code gedownload en uitgevoerd wordt. Dit kan ervoor zorgen dat de gebruiker een tijdje naar een lege pagina moet kijken voordat de applicatie getoond wordt. Dit is niet ideaal voor de gebruikerservaring.",source:"@site/docs/wf-course/nextjs/csr-ssr.md",sourceDirName:"wf-course/nextjs",slug:"/wf-course/nextjs/csr-ssr",permalink:"/webframeworks-cursus/wf-course/nextjs/csr-ssr",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"wfCourse",previous:{title:"Next.js",permalink:"/webframeworks-cursus/wf-course/nextjs/"},next:{title:"Fonts en Image Optimization",permalink:"/webframeworks-cursus/wf-course/nextjs/font-image-optimization"}},l={},d=[{value:"Client Components",id:"client-components",level:2},{value:"Server Components",id:"server-components-1",level:2},{value:"Data Fetching in Server Components",id:"data-fetching-in-server-components",level:3},{value:"loading.tsx",id:"loadingtsx",level:3},{value:"Combineren van Server en Client Components",id:"combineren-van-server-en-client-components",level:3},{value:"Use case: MongoDB",id:"use-case-mongodb",level:2}],p={toc:d};function c(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"server-components"},"Server Components"),(0,r.kt)("p",null,"Tot nu toe hebben we gebruik gemaakt van client side rendering (CSR) om onze React applicaties te maken. Dit betekend dat de volledige applicatie in de browser wordt geladen en daar gerenderd wordt. Dit is een goede manier om applicaties te maken, maar het heeft ook enkele nadelen. Een van de nadelen is dat de eerste keer dat de applicatie geladen wordt, er een lege pagina getoond wordt terwijl de JavaScript code gedownload en uitgevoerd wordt. Dit kan ervoor zorgen dat de gebruiker een tijdje naar een lege pagina moet kijken voordat de applicatie getoond wordt. Dit is niet ideaal voor de gebruikerservaring."),(0,r.kt)("p",null,"Sinds React 19 is het mogelijk om server components te gebruiken. Dit zijn componenten die op de server gerenderd worden en als HTML naar de browser gestuurd worden. Dit zorgt ervoor dat de gebruiker meteen een volledige pagina te zien krijgt zonder dat hij moet wachten tot de JavaScript code gedownload en uitgevoerd is. Dit zorgt voor een betere gebruikerservaring."),(0,r.kt)("h2",{id:"client-components"},"Client Components"),(0,r.kt)("p",null,"Voor we in detail treden over server components, is het belangrijk om eerst te begrijpen wat client components zijn. Client components zijn componenten die in de browser gerenderd worden. Dit is de standaard manier om React componenten te maken. In een client component kan je state en effects gebruiken om interactiviteit toe te voegen aan je applicatie. Dit zijn dus de componenten die we tot nu toe altijd gebruikt hebben in onze React applicaties."),(0,r.kt)("p",null,"Ook belangrijk is dat Next.js standaard alle componenten als server components behandelt. Dit betekend dat als je een nieuw component aanmaakt, dit standaard een server component is. Wil je een client component maken, dan moet je bovenaan het bestand ",(0,r.kt)("inlineCode",{parentName:"p"},"use client")," zetten. Dit is nodig omdat client components state en effects kunnen gebruiken en server components niet."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { useState } from "react";\n\nconst Home = () => {\n  const [counter, setCounter] = useState(0);\n\n  return (\n    <div>\n      <button onClick={() => setCounter(counter => counter + 1)}>{counter}</button>\n    </div>\n  );\n}\n\nexport default Home;\n')),(0,r.kt)("p",null,"Dit zal een fout geven omdat we state gebruiken in een server component. Om dit op te lossen moeten we bovenaan het bestand ",(0,r.kt)("inlineCode",{parentName:"p"},"use client")," zetten"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\nimport { useState } from "react";\n\nconst Home = () => {\n  const [counter, setCounter] = useState(0);\n\n    return (\n        <div>\n            <button onClick={() => setCounter(counter => counter + 1)}>{counter}</button>\n        </div>\n    );\n}\nexport default Home;\n')),(0,r.kt)("p",null,"Dit wil zeggen dat alles van het onderdeel React.js dat we tot nu toe geleerd hebben, nog steeds geldig is. We kunnen nog steeds state en effects gebruiken in onze componenten. We moeten alleen bovenaan het bestand ",(0,r.kt)("inlineCode",{parentName:"p"},"use client")," zetten om aan te geven dat het een client component is."),(0,r.kt)("p",null,"Over het algemeen is de regel dat je een component een client component maakt als je een van de volgende dingen wil doen:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"State gebruiken met ",(0,r.kt)("inlineCode",{parentName:"li"},"useState")),(0,r.kt)("li",{parentName:"ul"},"Side effects gebruiken met ",(0,r.kt)("inlineCode",{parentName:"li"},"useEffect")),(0,r.kt)("li",{parentName:"ul"},"Event handlers gebruiken zoals ",(0,r.kt)("inlineCode",{parentName:"li"},"onClick"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"onChange"),", ..."),(0,r.kt)("li",{parentName:"ul"},"Browser-only APIs gebruiken zoals ",(0,r.kt)("inlineCode",{parentName:"li"},"localStorage"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"document"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"window"),", ..."),(0,r.kt)("li",{parentName:"ul"},"Externe libraries gebruiken die niet op de server werken, zoals ",(0,r.kt)("inlineCode",{parentName:"li"},"react-router"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"leaflet"),", ...")),(0,r.kt)("h2",{id:"server-components-1"},"Server Components"),(0,r.kt)("p",null,"Zoals al eerder vermeld, zijn server components componenten die op de server gerenderd worden. Dit is nuttig voor componenten als je: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Data wil ophalen van een server of database"),(0,r.kt)("li",{parentName:"ul"},"Componenten wil maken die geen state of effects nodig hebben"),(0,r.kt)("li",{parentName:"ul"},"De hoeveelheid JavaScript die naar de browser gestuurd wordt wil verminderen"),(0,r.kt)("li",{parentName:"ul"},"De First Contentful Paint (FCP) wil verbeteren. Dit is de tijd die het duurt voordat de gebruiker iets op het scherm ziet.")),(0,r.kt)("p",null,"By default zijn Next.js applicaties gebaseerd op React Server Components. Het ophalen van data met Server Components is een relatief nieuwe aanpak en er zijn een paar voordelen aan het gebruik ervan:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Server Components ondersteunen JavaScript Promises, wat een oplossing biedt voor asynchrone taken zoals het ophalen van data. Je kan de async/await syntax gebruiken zonder dat je useEffect, useState of andere data fetching libraries nodig hebt."),(0,r.kt)("li",{parentName:"ul"},"Server Components draaien op de server, dus je kan zware data fetches en logica op de server houden en alleen het resultaat naar de client sturen."),(0,r.kt)("li",{parentName:"ul"},"Omdat Server Components op de server draaien, kan je rechtstreeks de database bevragen zonder een extra API laag. Dit bespaart je het schrijven en onderhouden van extra code.")),(0,r.kt)("h3",{id:"data-fetching-in-server-components"},"Data Fetching in Server Components"),(0,r.kt)("p",null,"Stel je hebt het volgende client component dat data ophaalt van een API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\nimport { useState, useEffect } from "react";\nimport { User } from "@/types";\n\nconst Home = () => {\n    const [users, setUsers] = useState<User[]>([]);\n\n    const fetchUsers = async() => {\n        const response = await fetch("https://jsonplaceholder.typicode.com/users");\n        const data : User[] = await response.json();\n        setUsers(data);\n    }\n\n    useEffect(() => {\n        fetchUsers();\n    },[]);\n\n    return (\n      <div>\n        <h1 className="text-2xl font-bold mb-4">User List</h1>\n        {\n          users.map(user => (\n            <div key={user.id} className="mb-4 p-4 border border-gray-200 rounded">{user.name}</div>))\n        }\n      </div>\n    )\n}\n\nexport default Home;\n')),(0,r.kt)("p",null,"Hier maken we gebruik van ",(0,r.kt)("inlineCode",{parentName:"p"},"useState")," en ",(0,r.kt)("inlineCode",{parentName:"p"},"useEffect")," om data op te halen van een API. Dit is de standaard manier om data op te halen in een React applicatie. Het nadeel hiervan is dat de gebruiker eerst een lege lijst ziet voor een paar milliseconden terwijl de data opgehaald wordt. We zouden dit kunnen oplossen door een loading indicator te tonen, maar dit is niet ideaal voor de gebruikerservaring."),(0,r.kt)("p",null,"Het alternatief in Next.js is om een server component te maken dat de data ophaalt. Dit kan je doen door het ",(0,r.kt)("inlineCode",{parentName:"p"},"use client")," statement weg te laten. In een server component kan je namelijk gewoon ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," functies gebruiken om data op te halen. Dit zorgt ervoor dat de data al opgehaald is voordat de HTML naar de browser gestuurd wordt. De gebruiker ziet dus meteen de volledige lijst zonder dat hij moet wachten."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { User } from "@/types";\n\nconst fetchUsers = async() => {\n    const response = await fetch("https://jsonplaceholder.typicode.com/users");\n    const data : User[] = await response.json();\n    return data;\n}\n\nconst Home = async() => {\n    const users = await fetchUsers();\n\n    return (\n      <div>\n        <h1 className="text-2xl font-bold mb-4">User List</h1>\n        {\n          users.map(user => (\n            <div key={user.id} className="mb-4 p-4 border border-gray-200 rounded">{user.name}</div>))\n        }\n      </div>\n    )\n}\n\nexport default Home;\n')),(0,r.kt)("p",null,"Je ziet hier dat het component ",(0,r.kt)("inlineCode",{parentName:"p"},"Home")," nu een ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," functie is. Dit is mogelijk omdat het een server component is. We kunnen dus gewoon ",(0,r.kt)("inlineCode",{parentName:"p"},"await")," gebruiken om de data op te halen. Dit zorgt ervoor dat de data al opgehaald is voordat de HTML naar de browser gestuurd wordt. De gebruiker ziet dus meteen de volledige lijst zonder dat hij moet wachten."),(0,r.kt)("p",null,"Opgelet: dit is alleen mogelijk in server components. In client components kan je geen ",(0,r.kt)("inlineCode",{parentName:"p"},"async")," functies gebruiken voor het component zelf."),(0,r.kt)("h3",{id:"loadingtsx"},"loading.tsx"),(0,r.kt)("p",null,"Een handige feature van Next.js is dat je een ",(0,r.kt)("inlineCode",{parentName:"p"},"loading.tsx")," bestand kan maken in een directory om een loading indicator te tonen terwijl een server component aan het laden is. Je plaatst deze file in dezelfde directory als waar je loading pagina wil."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'const Loading = () => {\n    return (\n        <div className="p-4">\n            <h1 className="text-2xl font-bold mb-4">Loading...</h1>\n        </div>\n    )\n}\nexport default Loading;\n')),(0,r.kt)("h3",{id:"combineren-van-server-en-client-components"},"Combineren van Server en Client Components"),(0,r.kt)("p",null,"Het is perfect mogelijk om server en client components te combineren in een Next.js applicatie. Een goede vuistregel is om zoveel mogelijk server components te gebruiken en alleen client components te maken als het echt nodig is. Dit zorgt ervoor dat je applicatie snel laadt en dat de hoeveelheid JavaScript die naar de browser gestuurd wordt minimaal is."),(0,r.kt)("p",null,"Zo kan je bijvoorbeeld een server component maken dat data ophaalt en deze data doorgeven aan een client component dat de data toont. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { User } from "@/types";\nimport UserCard from "@/components/UserCard";\n\nconst fetchUsers = async() => {\n    const response = await fetch("https://jsonplaceholder.typicode.com/users");\n    const data : User[] = await response.json();\n    return data;\n}\n\nconst Home = async() => {\n    const users = await fetchUsers();\n\n    return (\n      <div>\n        <h1 className="text-2xl font-bold mb-4">User List</h1>\n        {\n          users.map(user => (\n            <UserCard key={user.id} user={user} />))\n        }\n      </div>\n    )\n}\n\nexport default Home;\n')),(0,r.kt)("p",null,"en "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\n\nimport { User } from "@/types";\n\ninterface UserCardProps {\n    user: User;\n}\n\nconst UserCard = ({ user }: UserCardProps) => {\n    return (\n        <div className="mb-4 p-4 border border-gray-200 rounded">\n            {user.name}\n        </div>\n    )\n}\n\nexport default UserCard;\n')),(0,r.kt)("p",null,'Op dit moment is het uiteraard niet nodig om deze component als client component te maken, maar stel dat je toch interactiviteit wil toevoegen, dan is dit perfect mogelijk. Zonder interactie mag je de "use client" regel weglaten en wordt het een server component.'),(0,r.kt)("p",null,"Bijvoorbeeld als we de user card klikbaar willen maken met een ",(0,r.kt)("inlineCode",{parentName:"p"},"onClick")," event handler en willen aanduiden dat deze geselecteerd is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\n\nimport { User } from "@/types";\nimport { useState } from "react";\n\ninterface UserCardProps {\n    user: User\n}\n\nconst UserCard = ({user} : UserCardProps) => {\n    const [selected, setSelected] = useState(false);\n\n    return (\n        <div key={user.id} className={`mb-4 p-4 border ${selected ? "border-blue-500 bg-blue-50" : "border-gray-200"} rounded cursor-pointer`} onClick={() => setSelected(selected => !selected)}>{ user.name }</div>\n    )\n}\n\nexport default UserCard;\n')),(0,r.kt)("p",null,"De ",(0,r.kt)("inlineCode",{parentName:"p"},"Home")," component blijft een server component die de data ophaalt en de ",(0,r.kt)("inlineCode",{parentName:"p"},"UserCard")," component is een client component die de interactiviteit afhandelt."),(0,r.kt)("h2",{id:"use-case-mongodb"},"Use case: MongoDB"),(0,r.kt)("p",null,"Een veel voorkomende use case voor server components is het ophalen van data uit een database. We hebben in vorige cursus gezien dat als we data uit een database willen ophalen, dat we daar een backend server voor nodig hebben zoals Express.js. In Next.js is dit niet nodig omdat we server components kunnen gebruiken om direct data uit een database op te halen. Dit kan bijvoorbeeld met MongoDB. "),(0,r.kt)("p",null,"Stel dat je de volgende ",(0,r.kt)("inlineCode",{parentName:"p"},"database.ts")," file hebt die de connectie met MongoDB afhandelt:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { Collection, MongoClient } from "mongodb";\nimport { Joke } from "./types";\n\nconst client = new MongoClient("mongodb+srv://Webontwikkeling:Webontwikkeling@webontwikkling.n0nvawd.mongodb.net/?retryWrites=true&w=majority");\n\nexport const jokesCollection: Collection<Joke> = client.db("jokes").collection<Joke>("joke");\n\nexport const getJokes = async() => {\n    await jokesCollection.deleteMany({});\n    if (await jokesCollection.countDocuments() === 0) {\n        const response = await fetch("https://sampleapis.assimilate.be/jokes/goodJokes");\n        const json : Joke[] = await response.json();\n        await jokesCollection.insertMany(json);\n    }\n\n    const jokes = await jokesCollection.find().toArray();\n\n    return jokes;\n}\n')),(0,r.kt)("p",null,"We kunnen deze functie ",(0,r.kt)("inlineCode",{parentName:"p"},"getJokes")," nu gebruiken in een server component om de data op te halen en te tonen:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},'import { getJokes } from "@/database";\n\nconst JokesPage = async() => {\n    const jokes = await getJokes();\n\n    return (\n        <div className="p-4">\n            <h1 className="text-2xl font-bold mb-4">Jokes Page</h1>\n            <ul className="space-y-4">\n                {jokes.map((joke) => (\n                    <li key={joke.id} className="border p-4 rounded shadow">\n                        <h2 className="text-xl font-semibold">{joke.setup}</h2>\n                        <p className="mt-2 text-gray-700">{joke.punchline}</p>\n                    </li>\n                ))}\n            </ul>\n        </div>\n    )\n}\n\nexport default JokesPage;\n')))}c.isMDXComponent=!0}}]);