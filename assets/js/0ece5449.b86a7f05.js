"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[6193],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=r.createContext({}),l=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(d.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=l(t),u=a,g=m["".concat(d,".").concat(u)]||m[u]||p[u]||o;return t?r.createElement(g,i(i({ref:n},c),{},{components:t})):r.createElement(g,i({ref:n},c))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},1474:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=t(7462),a=(t(7294),t(3905));const o={},i="Server Components",s={unversionedId:"wf-course/nextjs/csr-ssr",id:"wf-course/nextjs/csr-ssr",title:"Server Components",description:"Tot nu toe hebben we gebruik gemaakt van client side rendering (CSR) om onze React applicaties te maken. Dit betekend dat de volledige applicatie in de browser wordt geladen en daar gerenderd wordt. Dit is een goede manier om applicaties te maken, maar het heeft ook enkele nadelen. Een van de nadelen is dat de eerste keer dat de applicatie geladen wordt, er een lege pagina getoond wordt terwijl de JavaScript code gedownload en uitgevoerd wordt. Dit kan ervoor zorgen dat de gebruiker een tijdje naar een lege pagina moet kijken voordat de applicatie getoond wordt. Dit is niet ideaal voor de gebruikerservaring.",source:"@site/docs/wf-course/nextjs/csr-ssr.md",sourceDirName:"wf-course/nextjs",slug:"/wf-course/nextjs/csr-ssr",permalink:"/webframeworks-cursus/wf-course/nextjs/csr-ssr",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"wfCourse",previous:{title:"Next.js",permalink:"/webframeworks-cursus/wf-course/nextjs/"},next:{title:"Routing",permalink:"/webframeworks-cursus/wf-course/nextjs/routing"}},d={},l=[{value:"Client Components",id:"client-components",level:2},{value:"Server Components",id:"server-components-1",level:2},{value:"Data Fetching in Server Components",id:"data-fetching-in-server-components",level:3},{value:"Combineren van Server en Client Components",id:"combineren-van-server-en-client-components",level:3}],c={toc:l};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"server-components"},"Server Components"),(0,a.kt)("p",null,"Tot nu toe hebben we gebruik gemaakt van client side rendering (CSR) om onze React applicaties te maken. Dit betekend dat de volledige applicatie in de browser wordt geladen en daar gerenderd wordt. Dit is een goede manier om applicaties te maken, maar het heeft ook enkele nadelen. Een van de nadelen is dat de eerste keer dat de applicatie geladen wordt, er een lege pagina getoond wordt terwijl de JavaScript code gedownload en uitgevoerd wordt. Dit kan ervoor zorgen dat de gebruiker een tijdje naar een lege pagina moet kijken voordat de applicatie getoond wordt. Dit is niet ideaal voor de gebruikerservaring."),(0,a.kt)("p",null,"Sinds React 19 is het mogelijk om server components te gebruiken. Dit zijn componenten die op de server gerenderd worden en als HTML naar de browser gestuurd worden. Dit zorgt ervoor dat de gebruiker meteen een volledige pagina te zien krijgt zonder dat hij moet wachten tot de JavaScript code gedownload en uitgevoerd is. Dit zorgt voor een betere gebruikerservaring."),(0,a.kt)("h2",{id:"client-components"},"Client Components"),(0,a.kt)("p",null,"Voor we in detail treden over server components, is het belangrijk om eerst te begrijpen wat client components zijn. Client components zijn componenten die in de browser gerenderd worden. Dit is de standaard manier om React componenten te maken. In een client component kan je state en effects gebruiken om interactiviteit toe te voegen aan je applicatie. Dit zijn dus de componenten die we tot nu toe altijd gebruikt hebben in onze React applicaties."),(0,a.kt)("p",null,"Ook belangrijk is dat Next.js standaard alle componenten als server components behandelt. Dit betekend dat als je een nieuw component aanmaakt, dit standaard een server component is. Wil je een client component maken, dan moet je bovenaan het bestand ",(0,a.kt)("inlineCode",{parentName:"p"},"use client")," zetten. Dit is nodig omdat client components state en effects kunnen gebruiken en server components niet."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { useState } from "react";\n\nconst Home = () => {\n  const [counter, setCounter] = useState(0);\n\n  return (\n    <div>\n      <button onClick={() => setCounter(counter => counter + 1)}>{counter}</button>\n    </div>\n  );\n}\n\nexport default Home;\n')),(0,a.kt)("p",null,"Dit zal een fout geven omdat we state gebruiken in een server component. Om dit op te lossen moeten we bovenaan het bestand ",(0,a.kt)("inlineCode",{parentName:"p"},"use client")," zetten"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\nimport { useState } from "react";\n\nconst Home = () => {\n  const [counter, setCounter] = useState(0);\n\n    return (\n        <div>\n            <button onClick={() => setCounter(counter => counter + 1)}>{counter}</button>\n        </div>\n    );\n}\nexport default Home;\n')),(0,a.kt)("p",null,"Dit wil zeggen dat alles van het onderdeel React.js dat we tot nu toe geleerd hebben, nog steeds geldig is. We kunnen nog steeds state en effects gebruiken in onze componenten. We moeten alleen bovenaan het bestand ",(0,a.kt)("inlineCode",{parentName:"p"},"use client")," zetten om aan te geven dat het een client component is."),(0,a.kt)("p",null,"Over het algemeen is de regel dat je een component een client component maakt als je een van de volgende dingen wil doen:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"State gebruiken met ",(0,a.kt)("inlineCode",{parentName:"li"},"useState")),(0,a.kt)("li",{parentName:"ul"},"Side effects gebruiken met ",(0,a.kt)("inlineCode",{parentName:"li"},"useEffect")),(0,a.kt)("li",{parentName:"ul"},"Event handlers gebruiken zoals ",(0,a.kt)("inlineCode",{parentName:"li"},"onClick"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"onChange"),", ..."),(0,a.kt)("li",{parentName:"ul"},"Browser-only APIs gebruiken zoals ",(0,a.kt)("inlineCode",{parentName:"li"},"localStorage"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"document"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"window"),", ..."),(0,a.kt)("li",{parentName:"ul"},"Externe libraries gebruiken die niet op de server werken, zoals ",(0,a.kt)("inlineCode",{parentName:"li"},"react-router"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"leaflet"),", ...")),(0,a.kt)("h2",{id:"server-components-1"},"Server Components"),(0,a.kt)("p",null,"Zoals al eerder vermeld, zijn server components componenten die op de server gerenderd worden. Dit is nuttig voor componenten als je: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Data wil ophalen van een server of database"),(0,a.kt)("li",{parentName:"ul"},"Componenten wil maken die geen state of effects nodig hebben"),(0,a.kt)("li",{parentName:"ul"},"De hoeveelheid JavaScript die naar de browser gestuurd wordt wil verminderen"),(0,a.kt)("li",{parentName:"ul"},"De First Contentful Paint (FCP) wil verbeteren. Dit is de tijd die het duurt voordat de gebruiker iets op het scherm ziet.")),(0,a.kt)("h3",{id:"data-fetching-in-server-components"},"Data Fetching in Server Components"),(0,a.kt)("p",null,"Stel je hebt het volgende client component dat data ophaalt van een API:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\nimport { useState, useEffect } from "react";\nimport { User } from "@/types";\n\nconst Home = () => {\n    const [users, setUsers] = useState<User[]>([]);\n\n    const fetchUsers = async() => {\n        const response = await fetch("https://jsonplaceholder.typicode.com/users");\n        const data : User[] = await response.json();\n        setUsers(data);\n    }\n\n    useEffect(() => {\n        fetchUsers();\n    },[]);\n\n    return (\n      <div>\n        <h1 className="text-2xl font-bold mb-4">User List</h1>\n        {\n          users.map(user => (\n            <div key={user.id} className="mb-4 p-4 border border-gray-200 rounded">{user.name}</div>))\n        }\n      </div>\n    )\n}\n\nexport default Home;\n')),(0,a.kt)("p",null,"Hier maken we gebruik van ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," en ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," om data op te halen van een API. Dit is de standaard manier om data op te halen in een React applicatie. Het nadeel hiervan is dat de gebruiker eerst een lege lijst ziet voor een paar milliseconden terwijl de data opgehaald wordt. We zouden dit kunnen oplossen door een loading indicator te tonen, maar dit is niet ideaal voor de gebruikerservaring."),(0,a.kt)("p",null,"Het alternatief in Next.js is om een server component te maken dat de data ophaalt. Dit kan je doen door het ",(0,a.kt)("inlineCode",{parentName:"p"},"use client")," statement weg te laten. In een server component kan je namelijk gewoon ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," functies gebruiken om data op te halen. Dit zorgt ervoor dat de data al opgehaald is voordat de HTML naar de browser gestuurd wordt. De gebruiker ziet dus meteen de volledige lijst zonder dat hij moet wachten."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { User } from "@/types";\n\nconst fetchUsers = async() => {\n    const response = await fetch("https://jsonplaceholder.typicode.com/users");\n    const data : User[] = await response.json();\n    return data;\n}\n\nconst Home = async() => {\n    const users = await fetchUsers();\n\n    return (\n      <div>\n        <h1 className="text-2xl font-bold mb-4">User List</h1>\n        {\n          users.map(user => (\n            <div key={user.id} className="mb-4 p-4 border border-gray-200 rounded">{user.name}</div>))\n        }\n      </div>\n    )\n}\n\nexport default Home;\n')),(0,a.kt)("p",null,"Je ziet hier dat het component ",(0,a.kt)("inlineCode",{parentName:"p"},"Home")," nu een ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," functie is. Dit is mogelijk omdat het een server component is. We kunnen dus gewoon ",(0,a.kt)("inlineCode",{parentName:"p"},"await")," gebruiken om de data op te halen. Dit zorgt ervoor dat de data al opgehaald is voordat de HTML naar de browser gestuurd wordt. De gebruiker ziet dus meteen de volledige lijst zonder dat hij moet wachten."),(0,a.kt)("p",null,"Opgelet: dit is alleen mogelijk in server components. In client components kan je geen ",(0,a.kt)("inlineCode",{parentName:"p"},"async")," functies gebruiken voor het component zelf."),(0,a.kt)("h3",{id:"combineren-van-server-en-client-components"},"Combineren van Server en Client Components"),(0,a.kt)("p",null,"Het is perfect mogelijk om server en client components te combineren in een Next.js applicatie. Een goede vuistregel is om zoveel mogelijk server components te gebruiken en alleen client components te maken als het echt nodig is. Dit zorgt ervoor dat je applicatie snel laadt en dat de hoeveelheid JavaScript die naar de browser gestuurd wordt minimaal is."),(0,a.kt)("p",null,"Zo kan je bijvoorbeeld een server component maken dat data ophaalt en deze data doorgeven aan een client component dat de data toont. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'import { User } from "@/types";\nimport UserCard from "@/components/UserCard";\n\nconst fetchUsers = async() => {\n    const response = await fetch("https://jsonplaceholder.typicode.com/users");\n    const data : User[] = await response.json();\n    return data;\n}\n\nconst Home = async() => {\n    const users = await fetchUsers();\n\n    return (\n      <div>\n        <h1 className="text-2xl font-bold mb-4">User List</h1>\n        {\n          users.map(user => (\n            <UserCard key={user.id} user={user} />))\n        }\n      </div>\n    )\n}\n\nexport default Home;\n')),(0,a.kt)("p",null,"en "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\n\nimport { User } from "@/types";\n\ninterface UserCardProps {\n    user: User;\n}\n\nconst UserCard = ({ user }: UserCardProps) => {\n    return (\n        <div className="mb-4 p-4 border border-gray-200 rounded">\n            {user.name}\n        </div>\n    )\n}\n\nexport default UserCard;\n')),(0,a.kt)("p",null,'Op dit moment is het uiteraard niet nodig om deze component als client component te maken, maar stel dat je toch interactiviteit wil toevoegen, dan is dit perfect mogelijk. Zonder interactie mag je de "use client" regel weglaten en wordt het een server component.'),(0,a.kt)("p",null,"Bijvoorbeeld als we de user card klikbaar willen maken met een ",(0,a.kt)("inlineCode",{parentName:"p"},"onClick")," event handler en willen aanduiden dat deze geselecteerd is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'"use client"\n\nimport { User } from "@/types";\nimport { useState } from "react";\n\ninterface UserCardProps {\n    user: User\n}\n\nconst UserCard = ({user} : UserCardProps) => {\n    const [selected, setSelected] = useState(false);\n\n    return (\n        <div key={user.id} className={`mb-4 p-4 border ${selected ? "border-blue-500 bg-blue-50" : "border-gray-200"} rounded cursor-pointer`} onClick={() => setSelected(selected => !selected)}>{ user.name }</div>\n    )\n}\n\nexport default UserCard;\n')),(0,a.kt)("p",null,"De ",(0,a.kt)("inlineCode",{parentName:"p"},"Home")," component blijft een server component die de data ophaalt en de ",(0,a.kt)("inlineCode",{parentName:"p"},"UserCard")," component is een client component die de interactiviteit afhandelt."))}p.isMDXComponent=!0}}]);