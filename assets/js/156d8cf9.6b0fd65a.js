"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[2563],{28453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>i});var a=r(96540);const t={},o=a.createContext(t);function s(e){const n=a.useContext(o);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),a.createElement(o.Provider,{value:n},e.children)}},95484:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"wf-course/nextjs/forms","title":"Form Handling","description":"Server Actions","source":"@site/docs/wf-course/nextjs/forms.md","sourceDirName":"wf-course/nextjs","slug":"/wf-course/nextjs/forms","permalink":"/webframeworks-cursus/wf-course/nextjs/forms","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"wfCourse","previous":{"title":"Fonts en Image Optimization","permalink":"/webframeworks-cursus/wf-course/nextjs/font-image-optimization"},"next":{"title":"Routing","permalink":"/webframeworks-cursus/wf-course/nextjs/routing"}}');var t=r(74848),o=r(28453);const s={},i="Form Handling",d={},l=[{value:"Server Actions",id:"server-actions",level:2},{value:"Formulier (Server Component)",id:"formulier-server-component",level:2},{value:"Formulier (Client Component)",id:"formulier-client-component",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"form-handling",children:"Form Handling"})}),"\n",(0,t.jsx)(n.h2,{id:"server-actions",children:"Server Actions"}),"\n",(0,t.jsx)(n.p,{children:"React Server Actions maken het mogelijk om asynchrone code rechtstreeks op de server uit te voeren. Dat betekent dat je geen aparte API-endpoints meer hoeft te schrijven om data te wijzigen. In plaats daarvan schrijf je asynchrone functies die op de server draaien, maar die je kunt aanroepen vanuit zowel Client Components als Server Components. Zo kan je bijvoorbeeld een formulier rechtstreeks koppelen aan een serverfunctie: wanneer de gebruiker het formulier indient, wordt die functie op de server uitgevoerd met directe toegang tot de database en andere back-endlogica. Er is geen extra fetch-request nodig, geen CORS-configuratie en ook geen aparte router of JSON-parsing \u2014 alles zit in \xe9\xe9n plek."}),"\n",(0,t.jsx)(n.p,{children:"Vroeger moest dit heel anders. Je had een aparte backend nodig, bijvoorbeeld een Express-server of een .NET Core API. Daarin moest je routes defini\xebren zoals een POST-endpoint voor het verwerken van formulieren en een GET-endpoint voor het ophalen van data. Op de clientkant moest je in React met fetch of axios een request sturen naar dat endpoint, wachten op een JSON-response en daarna zelf de UI bijwerken. Je moest zorgen voor correcte headers, validatie, beveiliging tegen CSRF en CORS-problemen, en vaak ook dubbele type-definities maken voor zowel frontend als backend. Dat werkte prima, maar voor een eenvoudige use-case zoals het versturen van een contactformulier was er behoorlijk wat boilerplate nodig."}),"\n",(0,t.jsx)(n.p,{children:'Met Server Actions valt al die extra code weg: je definieert \xe9\xe9n enkele functie in je Next.js-project, markeert die met "use server" en koppelt ze direct aan je formulier. De data gaat automatisch naar de server, de actie wordt uitgevoerd en je kunt na afloop meteen de UI opnieuw valideren of een redirect doen. Dit maakt de code veel overzichtelijker, veiliger en makkelijker te onderhouden. Een aparte API is alleen nog nodig als je data wil delen met externe clients, zoals mobiele apps of andere systemen.'}),"\n",(0,t.jsx)(n.h2,{id:"formulier-server-component",children:"Formulier (Server Component)"}),"\n",(0,t.jsxs)(n.p,{children:["We gaan een eenvoudig formulier maken dat een bericht opslaagt in een mongodb database. Hiervoor hebben we al een voor gedefinieerde ",(0,t.jsx)(n.code,{children:"database.ts"})," file die de connectie met de database maakt en een ",(0,t.jsx)(n.code,{children:"Message"})," model die we kunnen gebruiken om berichten op te slaan in de database."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { Collection, MongoClient } from "mongodb";\nimport { Message } from "@/types";\n\nconsole.log(process.env.MONGODB_URI);\n\nconst client = new MongoClient(process.env.MONGODB_URI!);\n\nexport const messageCollection: Collection<Message> = client.db("messages").collection<Message>("message");\n\nexport const saveMessage = async (message: Message) => {  \n    const result = await messageCollection.insertOne(message);\n    return result;\n}\n\nexport const getMessages = async() => {\n    const messages = await messageCollection.find().toArray();\n    return messages;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"en"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export interface Message {\n    _id?: string;\n    firstName: string;\n    lastName: string;\n    email: string;\n    message: string;\n    createdAt?: Date;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"We gaan nu een formulier maken in een server component. Dit formulier zal de data doorsturen naar een server action die we later gaan maken."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import React from "react";\nimport "./page.css";\n\nexport default function ContactPage() {\n    return (\n        <div className="form-container">\n            <div className="form-card">\n                <div className="form-header">\n                    <h1>Send a Message</h1>\n                    <p>Fill in the form below. Fields marked with * are required.</p>\n                </div>\n                <form className="form-body">\n                    <div className="form-grid">\n                        <div className="form-group">\n                            <label htmlFor="firstName">First name *</label>\n                            <input\n                                id="firstName"\n                                name="firstName"\n                                type="text"\n                                required\n                                placeholder="Ada"\n                            />\n                        </div>\n\n                        <div className="form-group">\n                            <label htmlFor="lastName">Last name *</label>\n                            <input\n                                id="lastName"\n                                name="lastName"\n                                type="text"\n                                required\n                                placeholder="Lovelace"\n                            />\n                        </div>\n\n                        <div className="form-group form-full">\n                            <label htmlFor="email">Email *</label>\n                            <input\n                                id="email"\n                                name="email"\n                                type="email"\n                                required\n                                placeholder="ada@example.com"\n                            />\n                        </div>\n\n                        <div className="form-group form-full">\n                            <label htmlFor="message">Message *</label>\n                            <textarea\n                                id="message"\n                                name="message"\n                                rows={6}\n                                required\n                                placeholder="Write your message here..."\n                            />\n                            <p className="form-hint">Keep it clear and concise.</p>\n                        </div>\n                    </div>\n\n                    <div className="form-actions">\n                        <button type="reset" className="btn-secondary">\n                            Reset\n                        </button>\n                        <button type="submit" className="btn-primary">\n                            Send\n                        </button>\n                    </div>\n                </form>\n            </div>\n        </div>\n    );\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:['Nu hebben we een formulier, maar het doet nog niets als we op de knop "Send" klikken. We gaan nu een server action maken die de data van het formulier zal verwerken. Meestal maken we een aparte file aan voor server actions, bijvoorbeeld ',(0,t.jsx)(n.code,{children:"actions.ts"}),". Op dit moment willen we gewoon een ",(0,t.jsx)(n.code,{children:"console.log"})," doen met de data die we ontvangen van het formulier."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'"use server";\n\nconst createMessage = async (formData: FormData) => {\n    const firstName = formData.get("firstName")?.toString();\n    const lastName = formData.get("lastName")?.toString();\n    const email = formData.get("email")?.toString();\n    const message = formData.get("message")?.toString();\n\n    console.log({ firstName, lastName, email, message });\n};\n'})}),"\n",(0,t.jsxs)(n.p,{children:["FormData bevat de data van het formulier. We kunnen deze data ophalen met de ",(0,t.jsx)(n.code,{children:"get"})," methode. De naam die we meegeven aan de ",(0,t.jsx)(n.code,{children:"get"})," methode moet overeenkomen met de naam die we hebben meegegeven aan het ",(0,t.jsx)(n.code,{children:"name"})," attribuut van het input veld in het formulier. Nu moeten we deze server action koppelen aan het formulier. Dit doen we door de ",(0,t.jsx)(n.code,{children:"action"})," attribute van het ",(0,t.jsx)(n.code,{children:"form"})," element te gebruiken."]}),"\n",(0,t.jsxs)(n.p,{children:["Vergeet hier niet om bovenaan de file ",(0,t.jsx)(n.code,{children:"use server"})," toe te voegen anders gaan de server actions niet werken."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'<form className="form-body" action={createMessage}>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Let op dat we hier geen methode zoals ",(0,t.jsx)(n.code,{children:"POST"})," of ",(0,t.jsx)(n.code,{children:"GET"}),' moeten meegeven. Als je nu op de knop "Send" klikt, dan zal de server action worden aangeroepen en zal de data van het formulier worden gelogd in de console van de server. Vervolgens kunnen we de data opslaan in de database. Hiervoor moeten we de ',(0,t.jsx)(n.code,{children:"saveMessage"})," functie importeren uit de ",(0,t.jsx)(n.code,{children:"database.ts"})," file die we eerder hebben gemaakt."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'"use server"\n\nimport { redirect } from "next/navigation";\nimport { saveMessage } from "./database";\n\nexport const createMessage = async (formData: FormData) => {\n    const firstName = formData.get("firstName")?.toString();\n    const lastName = formData.get("lastName")?.toString();\n    const email = formData.get("email")?.toString();\n    const message = formData.get("message")?.toString();\n\n    if (!firstName || !lastName || !email || !message) {\n        throw new Error("All fields are required");\n    }\n\n    await saveMessage({\n        firstName,\n        lastName,\n        email,\n        message,\n        createdAt: new Date()\n    });\n    \n    redirect("/contact/thank-you");\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Hier doen we een aantal dingen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"We controleren of alle velden zijn ingevuld. Als dit niet het geval is, dan gooien we een error. In een echte applicatie zou je hier een betere foutafhandeling moeten implementeren. Hoe we deze fout kunnen afhandelen komt later aan bod."}),"\n",(0,t.jsxs)(n.li,{children:["We slaan het bericht op in de database met de ",(0,t.jsx)(n.code,{children:"saveMessage"})," functie. Deze functie is asynchroon, dus we moeten hier ",(0,t.jsx)(n.code,{children:"await"})," voor gebruiken."]}),"\n",(0,t.jsx)(n.li,{children:'We redirecten de gebruiker naar een "Thank you" pagina nadat het bericht is opgeslagen.'}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:['Je moet uiteraard nog wel een nieuwe pagina aanmaken voor de "Thank you" pagina, bijvoorbeeld ',(0,t.jsx)(n.code,{children:"app/contact/thank-you/page.tsx"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import React from "react";\nimport "../page.css";\n\nconst MessageForm = () => {\n  return (\n    <div className="form-container">\n      <div className="form-card">\n        <div className="form-header">\n          <h1>Thank you</h1>\n          <p>Your message has been sent successfully. We will get back to you shortly.</p>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default MessageForm;\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Als we de error message nu willen afhandelen op een heel eenvoudige manier kunnen we gebruik maken van een ",(0,t.jsx)(n.code,{children:"error.tsx"})," file. Deze file wordt automatisch gebruikt door Next.js als er een error wordt gegooid in een server component. We kunnen deze file aanmaken in de ",(0,t.jsx)(n.code,{children:"app/contact"})," folder."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'"use client";\n\nconst ErrorPage = ({ error, reset }: { error: Error; reset: () => void }) => {\n    return (\n        <div className="form-container">\n            <div className="form-card">\n                <div className="form-header">\n                    <h1>Something went wrong</h1>\n                    <p>{error.message}</p>\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default ErrorPage;\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Wil je er voor zorgen dat de button even gedisabled wordt nadat je de knop hebt ingedrukt, dan kan je gebruik maken van een kleine Client Component die we kunnen inladen in het formulier. Deze component zorgt er voor dat de button even disabled wordt nadat je op de knop hebt geklikt. We maken hiervoor een nieuwe component aan ",(0,t.jsx)(n.code,{children:"SubmitButton.tsx"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'"use client"\n\nimport { useFormStatus } from "react-dom";\n\nconst SubmitButton = () => {\n    const status = useFormStatus();\n\n    return (\n        <button type="submit" className={`btn-primary`} disabled={status.pending}>\n            Send\n        </button>\n    )\n}\n\nexport default SubmitButton;\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Hier gebruiken we dus de ",(0,t.jsx)(n.code,{children:"useFormStatus"})," hook die ons vertelt of het formulier aan het verzenden is. We gebruiken deze status om de button te disablen als het formulier aan het verzenden is. We kunnen deze component nu gebruiken in het formulier."]}),"\n",(0,t.jsx)(n.h3,{id:"formulier-client-component",children:"Formulier (Client Component)"}),"\n",(0,t.jsxs)(n.p,{children:["Soms is het nodig om meer controle te hebben over het formulier, bijvoorbeeld om validatie te doen of om de UI bij te werken zonder de pagina te herladen. In dat geval kunnen we een Client Component maken die het formulier bevat. Hiervoor hebben we de ",(0,t.jsx)(n.code,{children:"useActionState"})," hook nodig die we kunnen importeren uit ",(0,t.jsx)(n.code,{children:"react-dom"}),". Deze hook geeft ons de status van de server action en maakt het mogelijk om de UI bij te werken op basis van deze status."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const [state, createMessageAction, pending] = useActionState(createMessage, {success: false, error: null});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Deze hook geeft ons drie dingen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"state"}),": de huidige status van de actie. Dit is een object dat we kunnen gebruiken om de status bij te houden. In dit geval houden we bij of de actie succesvol is geweest of dat er een error is opgetreden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"createMessageAction"}),": een functie die we kunnen aanroepen om de server action uit te voeren."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"pending"}),": een boolean die aangeeft of de actie aan het uitvoeren is (een soort van loading state)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["We hoeven hier dus zelf geen verschillende states bij te houden zoals loading, success of error. Dit wordt allemaal voor ons gedaan door de ",(0,t.jsx)(n.code,{children:"useActionState"})," hook."]}),"\n",(0,t.jsxs)(n.p,{children:["We moeten hier ook onze ",(0,t.jsx)(n.code,{children:"createMessage"})," server action een klein beetje aanpassen zodat hij als parameter de vorige state meekrijgt en deze kan updaten. We moeten hier ook de return value aanpassen zodat we de nieuwe state teruggeven."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'export interface CreateMessageState {\n    error: string | null;\n    success: boolean;\n}\n\nexport const createMessage = async (state: CreateMessageState, formData: FormData) => {\n    const firstName = formData.get("firstName")?.toString();\n    const lastName = formData.get("lastName")?.toString();\n    const email = formData.get("email")?.toString();\n    const message = formData.get("message")?.toString();\n\n    let error : string | null = null;\n\n    if (!firstName || !lastName || !email || !message) {\n        error = "All fields are required";\n    } else {\n        await saveMessage({\n            firstName,\n            lastName,\n            email,\n            message,\n            createdAt: new Date()\n        });\n    }   \n\n    return {\n        success: true,\n        error: error\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Vervolgens kunnen we nu de ",(0,t.jsx)(n.code,{children:"createMessageAction"})," meegeven aan het formulier."]})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);