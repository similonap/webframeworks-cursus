"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[3939],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>g});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),u=l(t),g=a,f=u["".concat(s,".").concat(g)]||u[g]||p[g]||o;return t?r.createElement(f,i(i({ref:n},c),{},{components:t})):r.createElement(f,i({ref:n},c))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var d={};for(var s in n)hasOwnProperty.call(n,s)&&(d[s]=n[s]);d.originalType=e,d.mdxType="string"==typeof e?e:a,i[1]=d;for(var l=2;l<o;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},6352:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>d,toc:()=>l});var r=t(7462),a=(t(7294),t(3905));const o={},i=void 0,d={unversionedId:"wf-course/advanced/nextjs/rendering/csr",id:"wf-course/advanced/nextjs/rendering/csr",title:"csr",description:"Client side rendering",source:"@site/docs/wf-course/advanced/nextjs/rendering/csr.md",sourceDirName:"wf-course/advanced/nextjs/rendering",slug:"/wf-course/advanced/nextjs/rendering/csr",permalink:"/webframeworks-cursus/wf-course/advanced/nextjs/rendering/csr",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"wfCourse",previous:{title:"API Routing",permalink:"/webframeworks-cursus/wf-course/advanced/nextjs/api-routing"},next:{title:"ssg",permalink:"/webframeworks-cursus/wf-course/advanced/nextjs/rendering/ssg"}},s={},l=[{value:"Client side rendering",id:"client-side-rendering",level:2},{value:"Data ophalen",id:"data-ophalen",level:3}],c={toc:l};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"client-side-rendering"},"Client side rendering"),(0,a.kt)("p",null,"Tot nu toe hebben we altijd gebruik gemaakt van client side rendering. Dit wil zeggen dat de applicatie wordt opgebouwd in de browser. De volledige applicatie moet dus eerst gedownload worden door de browser en wordt dan ook volledig uitgevoerd in de browser. Dit heeft als voordeel dat de applicatie heel snel reageert op interacties van de gebruiker. Het nadeel is dat de applicatie pas kan beginnen met laden als de volledige applicatie is gedownload. Dit kan ervoor zorgen dat de gebruiker een lege pagina te zien krijgt als de applicatie nog aan het laden is. Dit is niet ideaal voor de gebruikerservaring. "),(0,a.kt)("p",null,"Nog een groter probleem is dat de applicatie niet of slecht ge\xefndexeerd kan worden door zoekmachines. Als je een applicatie hebt die bijvoorbeeld een lijst van producten toont, dan wil je dat deze lijst ook getoond wordt als iemand zoekt naar een van deze producten. Als je applicatie niet ge\xefndexeerd kan worden, dan zal deze lijst niet getoond worden in de zoekresultaten. Dit is niet ideaal voor de vindbaarheid van je applicatie."),(0,a.kt)("p",null,"Tot nu toe heb je altijd gebruik gemaakt van client side rendering. Dit is de standaard manier van werken in React. "),(0,a.kt)("h3",{id:"data-ophalen"},"Data ophalen"),(0,a.kt)("p",null,"In een client side rendered applicatie wordt de data opgehaald in de browser. Dit kan je doen met behulp van de ",(0,a.kt)("inlineCode",{parentName:"p"},"fetch")," API. Deze API zorgt ervoor dat je data kan ophalen van een server. Je kan bijvoorbeeld de volgende code gebruiken om data op te halen van de ",(0,a.kt)("a",{parentName:"p",href:"https://jsonplaceholder.typicode.com/"},"JSON Placeholder API"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'interface Post {\n  id: number; \n  userId: number;\n  title: string;\n  body: string;\n};\n\nconst Posts = () => {\n  const [posts, setPosts] = useState<Post[]>([]);\n\n  useEffect(() => {\n    fetch("https://jsonplaceholder.typicode.com/posts")\n      .then((response) => response.json())\n      .then((data) => setPosts(data));\n  }, []);\n\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>{post.title}</li>\n      ))}\n    </ul>\n  );\n};\n\nexport default Posts;\n')),(0,a.kt)("p",null,"Bij een hele trage internetverbinding kan het zijn dat de data niet meteen wordt opgehaald. Dit kan ervoor zorgen dat de gebruiker een lege pagina te zien krijgt. Dit is niet ideaal voor de gebruikerservaring."))}p.isMDXComponent=!0}}]);