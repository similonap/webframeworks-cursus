"use strict";(self.webpackChunkwebframeworks_cursus=self.webpackChunkwebframeworks_cursus||[]).push([[9306],{28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(96540);const r={},o=s.createContext(r);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(o.Provider,{value:n},e.children)}},82918:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"wf-course/react/hooks/useRef","title":"useRef","description":"useRef is een geavanceerde hook die je niet vaak nodig hebt. Gebruik deze hook alleen als je echt weet wat je doet. De meeste toepassingen van useRef kunnen ook opgelost worden met useState of useEffect. Dus kijk eerst altijd of je het probleem niet op een reactievere manier kan oplossen (met useState of useEffect) voordat je useRef gebruikt.","source":"@site/docs/wf-course/react/hooks/useRef.md","sourceDirName":"wf-course/react/hooks","slug":"/wf-course/react/hooks/useRef","permalink":"/webframeworks-cursus/wf-course/react/hooks/useRef","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"wfCourse","previous":{"title":"useEffect","permalink":"/webframeworks-cursus/wf-course/react/hooks/useEffect"},"next":{"title":"custom hooks","permalink":"/webframeworks-cursus/wf-course/react/hooks/custom-hooks"}}');var r=t(74848),o=t(28453);const a={sidebar_position:2},i="useRef",d={},c=[{value:"Werking",id:"werking",level:2},{value:"Toepassingen",id:"toepassingen",level:2},{value:"TimeoutId of intervalId bijhouden",id:"timeoutid-of-intervalid-bijhouden",level:3},{value:"DOM manipulatie",id:"dom-manipulatie",level:3},{value:"Focus op een input element zetten",id:"focus-op-een-input-element-zetten",level:4},{value:"Video element bedienen",id:"video-element-bedienen",level:4},{value:"Groottes van elementen meten",id:"groottes-van-elementen-meten",level:4}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"useref",children:"useRef"})}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsx)(n.p,{children:"useRef is een geavanceerde hook die je niet vaak nodig hebt. Gebruik deze hook alleen als je echt weet wat je doet. De meeste toepassingen van useRef kunnen ook opgelost worden met useState of useEffect. Dus kijk eerst altijd of je het probleem niet op een reactievere manier kan oplossen (met useState of useEffect) voordat je useRef gebruikt."})}),"\n",(0,r.jsx)(n.h2,{id:"werking",children:"Werking"}),"\n",(0,r.jsxs)(n.p,{children:["Wanneer je wil dat een component een waarde wil onthouden, maar je wil niet dat de component opnieuw gerenderd wordt wanneer die waarde verandert, kan je gebruik maken van de ",(0,r.jsx)(n.code,{children:"useRef"})," hook. Deze hook is een manier om een waarde te onthouden tussen renders van een component."]}),"\n",(0,r.jsxs)(n.p,{children:["Om een ",(0,r.jsx)(n.code,{children:"useRef"})," te gebruiken, moet je eerst de hook importeren:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:'import { useRef } from "react";\n'})}),"\n",(0,r.jsxs)(n.p,{children:["In je component kan je dan een ",(0,r.jsx)(n.code,{children:"useRef"})," aanmaken en initialiseren met een waarde:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const myRef = useRef(initialValue);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Als je dan de waarde van de ",(0,r.jsx)(n.code,{children:"myRef"})," variabele bekijkt, zal je zien dat het een object bevat met een ",(0,r.jsx)(n.code,{children:"current"})," eigenschap. Deze eigenschap bevat de waarde die je hebt meegegeven aan ",(0,r.jsx)(n.code,{children:"useRef"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"console.log(myRef.current); // Geeft de waarde van initialValue\n// {\n//     current: 0\n// }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Je kan de waarde van een ",(0,r.jsx)(n.code,{children:"useRef"})," aanpassen door de ",(0,r.jsx)(n.code,{children:"current"})," eigenschap te veranderen:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:'import React, { useRef } from "react";\n\n\nconst App = () => {\n  const myRef = useRef(0);\n\n  const handleClick = () => {\n    myRef.current += 1;\n    console.log(myRef.current);\n  }\n\n  return (\n    <>\n      <h1>Counter</h1>\n      <p>{myRef.current}</p>\n      <button onClick={handleClick}>Increment</button>\n    </>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Merk op dat wanneer je de waarde van een ",(0,r.jsx)(n.code,{children:"useRef"})," aanpast er dus geen nieuwe render van het component wordt getriggered. Dus zelfs al verhoog je de waarde van ",(0,r.jsx)(n.code,{children:"myRef.current"}),", zal de waarde niet opnieuw in de DOM worden geupdated en dus niet op het scherm verschijnen. In de console zal je wel zien dat de waarde van ",(0,r.jsx)(n.code,{children:"myRef.current"})," is veranderd."]}),"\n",(0,r.jsx)(n.h2,{id:"toepassingen",children:"Toepassingen"}),"\n",(0,r.jsxs)(n.p,{children:["Dit is allemaal leuk en aardig, maar wat kan je nu eigenlijk doen met ",(0,r.jsx)(n.code,{children:"useRef"}),"? Hier zijn enkele toepassingen:"]}),"\n",(0,r.jsx)(n.h3,{id:"timeoutid-of-intervalid-bijhouden",children:"TimeoutId of intervalId bijhouden"}),"\n",(0,r.jsx)(n.p,{children:"Stel dat we een StopWatch component willen maken."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:"import { useState, useRef } from 'react';\n\nconst StopWatch = () => {\n  const [secondsPassed, setSecondsPassed] = useState(0);\n\n  const handleStart = () => {\n    setSecondsPassed(0);\n    setInterval(() => {\n      setSecondsPassed(passed => passed + 1);\n    }, 1000);\n  }\n\n  return (\n    <>\n      <h1>Seconds passed: {secondsPassed}</h1>\n      <button onClick={handleStart}>\n        Start\n      </button>\n    </>\n  );\n}\n\nexport default StopWatch;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Als we nu deze component willen uitbreiden met een stop knop moeten we de referentie naar de interval bijhouden. We kunnen dit niet in een gewone variabele doen of in de state, omdat dit de component zou triggeren om opnieuw te renderen en dit kan onverwachte gevolgen hebben. We kunnen dit wel doen met een ",(0,r.jsx)(n.code,{children:"useRef"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:"import { useState, useRef } from 'react';\n\nconst StopWatch = () => {\n  const [secondsPassed, setSecondsPassed] = useState(0);\n  const intervalRef = useRef<number>();\n\n  const handleStart = () => {\n    setSecondsPassed(0);\n    intervalRef.current = setInterval(() => {\n      setSecondsPassed(passed => passed + 1);\n    }, 1000);\n  }\n\n  const handleStop = () => {\n    clearInterval(intervalRef.current);\n  }\n\n  return (\n    <>\n      <h1>Seconds passed: {secondsPassed}</h1>\n      <button onClick={handleStart}>\n        Start\n      </button>\n      <button onClick={handleStop}>\n        Stop\n      </button>\n    </>\n  );\n}\n \nexport default StopWatch;\n"})}),"\n",(0,r.jsx)(n.h3,{id:"dom-manipulatie",children:"DOM manipulatie"}),"\n",(0,r.jsx)(n.h4,{id:"focus-op-een-input-element-zetten",children:"Focus op een input element zetten"}),"\n",(0,r.jsxs)(n.p,{children:["Een andere toepassing van ",(0,r.jsx)(n.code,{children:"useRef"})," is om een referentie naar een DOM element bij te houden. Dit kan handig zijn als je bijvoorbeeld de focus wil zetten op een input element wanneer de component mount:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:"import { useEffect, useRef } from 'react';\n\nconst FocusInput = () => {\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  return (\n        <>\n            <input ref={inputRef} />\n            <button onClick={() => { inputRef.current?.focus(); }}>\n                Focus the input\n            </button>\n        </>\n  );\n}\n\nexport default FocusInput;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Wat hier gebeurt is dat we een referentie naar de input bijhouden in ",(0,r.jsx)(n.code,{children:"inputRef"}),". Wanneer de button wordt geklikt, zetten we de focus op de input door de ",(0,r.jsx)(n.code,{children:"focus"})," methode aan te roepen op ",(0,r.jsx)(n.code,{children:"inputRef.current"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"video-element-bedienen",children:"Video element bedienen"}),"\n",(0,r.jsx)(n.p,{children:"Een andere toepassing is het bedienen van een video element. Stel dat we een video element hebben en we willen de video pauzeren wanneer de gebruiker op een knop klikt:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:"import { useState, useRef } from 'react';\n\nconst VideoPlayer = () => {\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  const ref = useRef();\n\n  function handleClick() {\n    const nextIsPlaying = !isPlaying;\n    if (nextIsPlaying) {\n      ref.current.play();\n    } else {\n      ref.current.pause();\n    }\n    setIsPlaying(nextIsPlaying);\n  }\n\n  return (\n    <>\n      <button onClick={handleClick}>\n        {isPlaying ? 'Pause' : 'Play'}\n      </button>\n      <video width=\"250\" ref={ref}>\n        <source\n          src=\"https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4\"\n          type=\"video/mp4\"\n        />\n      </video>\n    </>\n  )\n}\n\nexport default VideoPlayer;\n"})}),"\n",(0,r.jsx)(n.h4,{id:"groottes-van-elementen-meten",children:"Groottes van elementen meten"}),"\n",(0,r.jsx)(n.p,{children:"Een andere toepassing is het meten van de grootte van een element. Stel dat we een component hebben dat de grootte van een element moet meten en weergeven:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",metastring:'codesandbox={"template": "react", "filename": "src/App.tsx"}',children:"import { useEffect, useRef, useState } from 'react';\n\nconst SizeMeasurer = () => {\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (ref.current) {\n      setSize({\n        width: ref.current.offsetWidth,\n        height: ref.current.offsetHeight\n      });\n    }\n  }, [ref.current]);\n\n  return (\n    <div ref={ref}>\n      <h1>Width: {size.width}</h1>\n      <h1>Height: {size.height}</h1>\n    </div>\n  );\n}\n\nexport default SizeMeasurer;\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);